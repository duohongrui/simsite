[
{
	"uri": "/programming/",
	"title": "Programming Usage",
	"tags": [],
	"description": "",
	"content": "Programming Usage simpipe provides a pipeline from estimating parameters from real data, simulating new datasets from learned parameters and assessing simulated datasets. üë®‚Äçüíªüë®üèª‚Äçüíªüë®üèº‚Äçüíª\nInstallation Estimation Simulation Assessment "
},
{
	"uri": "/online/1-choose_methods/",
	"title": "Choose Methods",
	"tags": [],
	"description": "",
	"content": " Installation Guide Installation Guide A\ndevtools::install_github(\u0026quot;duohongrui/simpipe\u0026quot;) B\nprint(\u0026quot;Hello World!\u0026quot;) [1] \u0026quot;Hello World!\u0026quot; "
},
{
	"uri": "/programming/1-installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": " Choice1: Installation from Github Choice2: Download Docker Image Install Docker Desktop Download simpipe Docker Image Install simpipe2docker There are two ways to configure programming environment and execute simulation procedure:\ninstall multiple R packages and dependencies from github, it may take 5-30 mins.\ninstall Docker first and download simpipe Docker image from DockerHub. All manipulations in R can be done by a lightweight simpipe2doker package.\nChoice1: Installation from Github The first way to configure your programming environment is to install all of the packages and necessary dependencies\nYou can install the development version of simutils, simmethods and simpipe from GitHub by:\n# install.packages(\u0026quot;devtools\u0026quot;) devtools::install_github(\u0026quot;duohongrui/simutils\u0026quot;) devtools::install_github(\u0026quot;duohongrui/simmethods\u0026quot;) devtools::install_github(\u0026quot;duohongrui/simpipe\u0026quot;) If you want to use simpipe to simulate datasets with trajectory information, please install tislingshot first by:\ndevtools::install_github(\u0026quot;dynverse/ti_slingshot/package/\u0026quot;) Choice2: Download Docker Image We provide another way for users to configure your environment by Docker. To achieve the interaction between Docker and R environment, we build a lightweight R package simpipe2docker which is used for calling commands in terminal to link Docker and R. It is more easier to manipulate and suitable for different operation systems and R versions, avoiding complex configurations in various environments.\nInstall Docker Desktop If you have not installed official Docker Desktop, please click here and follow the instructions to install it. The version of Docker Desktop for Apple Chip is available\nAfter installing Docker, start Docker service, open an R session and type dynwrap::test_docker_installation(detailed = TRUE):\ndynwrap::test_docker_installation(detailed = TRUE) ‚úî Docker is installed ‚úî Docker daemon is running ‚úî Docker is at correct version (\u0026gt;1.0): 1.41 ‚úî Docker is in linux mode ‚úî Docker can pull images ‚úî Docker can run image ‚úî Docker can mount temporary volumes ‚úî Docker test successful ----------------------------------------------------------------- [1] TRUE If it is TRUE in the result, that means Docker is successfully installed.\nDownload simpipe Docker Image Use babelwhale::pull_container(\"duohongrui/simpipe\") command to pull simpipe Docker image in R (it will take 3-10 mins):\n# install.packages(\u0026quot;babelwhale\u0026quot;) babelwhale::pull_container(\u0026quot;duohongrui/simpipe\u0026quot;) Once the image has been downloaded, check the image list:\nbabelwhale::list_docker_images(\u0026quot;duohongrui/simpipe\u0026quot;) ID Repository Tag 1 a9d30539a083 duohongrui/simpipe latest Digest 1 sha256:eae62ba3d06916db8216ef8b240de2c64b691efd8ecd96735f8c111bb5911f8c CreatedSince CreatedAt Size 1 10 months ago 2022-07-13 02:11:51 +0800 CST 4.94GB Install simpipe2docker Get the simpipe2docker package from github by:\ndevtools::install_github(\u0026quot;duhongrui/simpipe2docker\u0026quot;) Load the package and check whether it is installed successfully:\nlibrary(simpipe2docker) Until now, you have successfully established the programming environment üëçüëçüëç. Go to the next page.üëàÔ∏è\n"
},
{
	"uri": "/references/1-methods_list/",
	"title": "Method Overview",
	"tags": [],
	"description": "",
	"content": " Here, we show all of collected simulation methods, their basic information and the links of usage documentation. We hope it will help you to learn the usage of the method that satisfies your simulation requirements and benefit for your research.\nThe Table of Simulation Methods ID Method Vignette Language URL DOI Journal 1 BASiCS PLoS Computational Biology 2 BEARscc Nature Communications 3 CancerInSilico PLoS Computational Biology 4 dropsim 5 dyngen Nature Communications 6 dyntoy 7 ESCO Bioinformatics 8 ESCO-traj Bioinformatics 9 ESCO-tree Bioinformatics 10 hierarchicell BMC Genomics 11 Kersplat Genome Biology 12 Lun Genome Biology 13 Lun2 Genome Biology 14 MFA Wellcome Open Research 15 muscat Nature Communications 16 phenopath bioRxiv 17 POWSC Bioinformatics 18 powsimR Bioinformatics 19 PROSSTT Bioinformatics 20 scDD Genome Biology 21 scDesign Bioinformatics 22 scDesign2 Genome Biology 23 scDesign3 Nature Biotechnology 24 scDesign3-tree Nature Biotechnology 25 scGAN Nature Communications 26 scMultiSim bioRxiv 27 scMultiSim-tree bioRxiv 28 SCRIP-BGP-commonBCV Bioinformatics 29 SCRIP-BGP-trendedBCV Bioinformatics 30 SCRIP-BP Bioinformatics 31 SCRIP-GP-commonBCV Bioinformatics 32 SCRIP-GP-trendedBCV Bioinformatics 33 SCRIP-paths Bioinformatics 34 SimBPDD Annales Mathematicae et Informaticae 35 Simple Genome Biology 36 SparseDC Nucleic Acids Research 37 SPARSim Bioinformatics 38 Splat Genome Biology 39 Splat-paths Genome Biology 40 SplatPop Genome Biology 41 SplatPop-paths Genome Biology 42 SPsimSeq Bioinformatics 43 SRTsim Genome Bilogy 44 SymSim Nature Communications 45 TedSim Nucleic Acids Research 46 VeloSim bioRxiv 47 zinbwave Nature Communications 48 zinbwaveZinger Genome Biology 49 zingeR Genome Biology "
},
{
	"uri": "/references/methods/1-splat/",
	"title": "Splat",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using Splat Datasets with default parameters Determin the number of cells and genes Simulate two or more groups Simulate two or more batches Simulate more groups and batches simutaniously Return results with different format Here Splat method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data dim(ref_data) # [1] 4000 160 Using simmethods::Splat_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::Splat_estimation(ref_data = ref_data, verbose = T, seed = 10) # Estimating parameters using Splat Simulating datasets using Splat After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Simulate two or more groups Simulate two or more batches Simulate more groups and batches simutaniously Return results with different format Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group and one batch of cells.\nsimulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 3 columns # cell_name batch group # \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; # Cell1 Cell1 Batch1 Group1 # Cell2 Cell2 Batch1 Group1 # Cell3 Cell3 Batch1 Group1 # Cell4 Cell4 Batch1 Group1 # Cell5 Cell5 Batch1 Group1 # Cell6 Cell6 Batch1 Group1 head(rowData(SCE_result)) # DataFrame with 6 rows and 1 column # gene_name # \u0026lt;character\u0026gt; # Gene1 Gene1 # Gene2 Gene2 # Gene3 Gene3 # Gene4 Gene4 # Gene5 Gene5 # Gene6 Gene6 Determin the number of cells and genes In Splat, we can not set nCells directly and should set batchCells instead. For example, if we want to simulate 500 cells, we can type other_prior = list(batchCells = 500). For genes, we can just set nGenes. Here, we simulate a new dataset with 500 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = 500, nGenes = 1000), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 Simulate two or more groups In Splat, we can not set nGroups directly and should set prob.group instead. For example, if we want to simulate 2 groups, we can type other_prior = list(prob.group = c(0.5, 0.5)). Note that the sum of prob.group numeric vector must equal to 1, so we can also set prob.group = c(0.3, 0.7).\nIn addtion, if we want to simulate three or more groups, we should obey the rules:\nThe length of prob.group vector must always equal to the number of groups. The sum of prob.group numeric vector must equal to 1. For demonstration, we will simulate three groups using the learned parameters.\nsimulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = 500, nGenes = 1000, prob.group = c(0.1, 0.3, 0.6)), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 3 # de.prob: 0.1 # nBatches: 1 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$group) # # Group1 Group2 Group3 # 46 156 298 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) ## de.prob = 0.1 # yes # 0.1 We can see that the proportion of differential expressed genes is 0.1 (equals to the default). Next, if we want to know the fold change between two groups, we will do division with the groups that we are interested in.\n## fc between group2 and group1 fc_group1_to_group2 \u0026lt;- gene_info$DEFacGroup2/gene_info$DEFacGroup1 ## fc between group3 and group1 fc_group1_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup1 ## fc between group3 and group2 fc_group2_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup2 Simulate two or more batches In Splat, we can not set nBatches directly and should set batchCells instead. For example, if we want to simulate 2 batches, we can type other_prior = list(batchCells = c(250, 250)). Note that the sum of batchCells numeric vector represents the total number of cells and the length of the vector equals to the number of batches.\nIn addtion, if we want to simulate three or more batches, we should obey the rules:\nThe length of batchCells vector always equals to the number of batches. The sum of batchCells numeric vector represents the total number of cells. For demonstration, we will simulate three batches using the learned parameters.\nsimulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = c(200, 300), nGenes = 1000), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 2 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$batch) # # Batch1 Batch2 # 200 300 Simulate more groups and batches simutaniously As mentioned before, we can set prob.group and batchCells to determine the number of groups and batches and we can also set de.prob to specify the proportion of DEGs. Here, we simulate a dataset with following settings:\n1000 cells 5000 genes three groups with 0.2 proportion of DEGs two batches simulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = c(500, 500), nGenes = 5000, de.prob = 0.2, prob.group = c(0.2, 0.3, 0.5)), seed = 111 ) # nCells: 1000 # nGenes: 5000 # nGroups: 3 # de.prob: 0.2 # nBatches: 2 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 5000 1000 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$batch) # # Batch1 Batch2 # 500 500 table(cell_info$group) # # Group1 Group2 Group3 # 186 321 493 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) # yes # 0.1932 ### fc fc_group2_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup2 Return results with different format In simmethods package, we provide four formats of results to users without data format conversion, including list, SingleCellExperiment, Seurat and h5ad. The previous three formats are compatible with R environment and the last h5ad format is suitable for Python environment and can be imported by scanpy.read_h5ad function.\nlist simulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = c(100, 100), nGenes = 1000, de.prob = 0.1, prob.group = c(0.2, 0.3, 0.5)), seed = 111 ) # nCells: 200 # nGenes: 1000 # nGroups: 3 # de.prob: 0.1 # nBatches: 2 str(simulate_result) # List of 2 # $ simulate_result :List of 3 # ..$ count_data: int [1:1000, 1:200] 16 18 14 40 5 23 9 694 27 21 ... # .. ..- attr(*, \u0026quot;dimnames\u0026quot;)=List of 2 # .. .. ..$ : chr [1:1000] \u0026quot;Gene1\u0026quot; \u0026quot;Gene2\u0026quot; \u0026quot;Gene3\u0026quot; \u0026quot;Gene4\u0026quot; ... # .. .. ..$ : chr [1:200] \u0026quot;Cell1\u0026quot; \u0026quot;Cell2\u0026quot; \u0026quot;Cell3\u0026quot; \u0026quot;Cell4\u0026quot; ... # ..$ col_meta :\u0026#39;data.frame\u0026#39;: 200 obs. of 3 variables: # .. ..$ cell_name: chr [1:200] \u0026quot;Cell1\u0026quot; \u0026quot;Cell2\u0026quot; \u0026quot;Cell3\u0026quot; \u0026quot;Cell4\u0026quot; ... # .. ..$ batch : chr [1:200] \u0026quot;Batch1\u0026quot; \u0026quot;Batch1\u0026quot; \u0026quot;Batch1\u0026quot; \u0026quot;Batch1\u0026quot; ... # .. ..$ group : Factor w/ 3 levels \u0026quot;Group1\u0026quot;,\u0026quot;Group2\u0026quot;,..: 2 2 3 2 3 3 3 2 3 3 ... # ..$ row_meta :\u0026#39;data.frame\u0026#39;: 1000 obs. of 7 variables: # .. ..$ gene_name : chr [1:1000] \u0026quot;Gene1\u0026quot; \u0026quot;Gene2\u0026quot; \u0026quot;Gene3\u0026quot; \u0026quot;Gene4\u0026quot; ... # .. ..$ de_gene : chr [1:1000] \u0026quot;no\u0026quot; \u0026quot;no\u0026quot; \u0026quot;no\u0026quot; \u0026quot;no\u0026quot; ... # .. ..$ BatchFacBatch1: num [1:1000] 0.91 0.977 1.054 1.171 1.002 ... # .. ..$ BatchFacBatch2: num [1:1000] 1.105 0.95 0.76 0.776 0.996 ... # .. ..$ DEFacGroup1 : num [1:1000] 1 1 1 1 1 1 1 1 1 1 ... # .. ..$ DEFacGroup2 : num [1:1000] 1 1 1 1 1 1 1 1 1 1 ... # .. ..$ DEFacGroup3 : num [1:1000] 1 1 1 1 1 1 1 1 1 1 ... # $ simulate_detection:\u0026#39;data.frame\u0026#39;: 1 obs. of 4 variables: # ..$ Function_Call : chr \u0026quot;simulate_result\u0026lt;-splatter::splatSimulate(parameters,method=submethod,verbose=verbose)\u0026quot; # ..$ Elapsed_Time_sec : num 0.176 # ..$ Total_RAM_Used_MiB: num 7 # ..$ Peak_RAM_Used_MiB : num 4763586 counts \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] head(cell_info) # cell_name batch group # Cell1 Cell1 Batch1 Group2 # Cell2 Cell2 Batch1 Group2 # Cell3 Cell3 Batch1 Group3 # Cell4 Cell4 Batch1 Group2 # Cell5 Cell5 Batch1 Group3 # Cell6 Cell6 Batch1 Group3 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] head(gene_info) # gene_name de_gene BatchFacBatch1 BatchFacBatch2 DEFacGroup1 DEFacGroup2 # Gene1 Gene1 no 0.9098860 1.1054169 1 1 # Gene2 Gene2 no 0.9774161 0.9501320 1 1 # Gene3 Gene3 no 1.0541276 0.7597880 1 1 # Gene4 Gene4 no 1.1708139 0.7762219 1 1 # Gene5 Gene5 no 1.0017116 0.9963063 1 1 # Gene6 Gene6 no 0.7654326 1.1497335 1 1 # DEFacGroup3 # Gene1 1 # Gene2 1 # Gene3 1 # Gene4 1 # Gene5 1 # Gene6 1 SingleCellExperiment simulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SingleCellExperiment\u0026quot;, other_prior = list(batchCells = c(100, 100), nGenes = 1000, de.prob = 0.1, prob.group = c(0.2, 0.3, 0.5)), seed = 111 ) # nCells: 200 # nGenes: 1000 # nGroups: 3 # de.prob: 0.1 # nBatches: 2 counts \u0026lt;- counts(simulate_result[[\u0026quot;simulate_result\u0026quot;]]) ## cell information cell_info \u0026lt;- as.data.frame(colData(simulate_result[[\u0026quot;simulate_result\u0026quot;]])) head(cell_info) # cell_name batch group # Cell1 Cell1 Batch1 Group2 # Cell2 Cell2 Batch1 Group2 # Cell3 Cell3 Batch1 Group3 # Cell4 Cell4 Batch1 Group2 # Cell5 Cell5 Batch1 Group3 # Cell6 Cell6 Batch1 Group3 ## gene information gene_info \u0026lt;- as.data.frame(rowData(simulate_result[[\u0026quot;simulate_result\u0026quot;]])) head(gene_info) # gene_name de_gene BatchFacBatch1 BatchFacBatch2 DEFacGroup1 DEFacGroup2 # Gene1 Gene1 no 0.9098860 1.1054169 1 1 # Gene2 Gene2 no 0.9774161 0.9501320 1 1 # Gene3 Gene3 no 1.0541276 0.7597880 1 1 # Gene4 Gene4 no 1.1708139 0.7762219 1 1 # Gene5 Gene5 no 1.0017116 0.9963063 1 1 # Gene6 Gene6 no 0.7654326 1.1497335 1 1 # DEFacGroup3 # Gene1 1 # Gene2 1 # Gene3 1 # Gene4 1 # Gene5 1 # Gene6 1 Seurat simulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;Seurat\u0026quot;, other_prior = list(batchCells = c(100, 100), nGenes = 1000, de.prob = 0.1, prob.group = c(0.2, 0.3, 0.5)), seed = 111 ) # nCells: 200 # nGenes: 1000 # nGroups: 3 # de.prob: 0.1 # nBatches: 2 seurat_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] ## Overview seurat_result # An object of class Seurat # 1000 features across 200 samples within 1 assay # Active assay: originalexp (1000 features, 0 variable features) ## count matrix counts \u0026lt;- seurat_result@assays$originalexp@counts counts[1:10, 1:10] # 10 x 10 sparse Matrix of class \u0026quot;dgCMatrix\u0026quot; # [[ suppressing 10 column names \u0026#39;Cell1\u0026#39;, \u0026#39;Cell2\u0026#39;, \u0026#39;Cell3\u0026#39; ... ]] # # Gene1 16 . 7 5 . . . 11 220 1 # Gene2 18 . 12 10 . 1 1 32 222 2 # Gene3 14 . 4 2 1 . . 23 101 5 # Gene4 40 1 13 18 . 1 1 27 464 5 # Gene5 5 . 2 4 . . . 6 93 2 # Gene6 23 . 6 11 . . . 14 334 5 # Gene7 9 . 13 2 . . . 13 189 . # Gene8 694 7 509 229 26 6 12 774 7932 61 # Gene9 27 . 16 6 2 1 . 12 311 . # Gene10 21 . 13 6 . . . 24 199 5 ## cell information cell_info \u0026lt;- seurat_result@meta.data head(cell_info) # orig.ident nCount_originalexp nFeature_originalexp cell_name batch # Cell1 SeuratProject 65963 975 Cell1 Batch1 # Cell2 SeuratProject 1167 301 Cell2 Batch1 # Cell3 SeuratProject 45665 958 Cell3 Batch1 # Cell4 SeuratProject 26395 911 Cell4 Batch1 # Cell5 SeuratProject 3059 488 Cell5 Batch1 # Cell6 SeuratProject 1998 393 Cell6 Batch1 # group # Cell1 Group2 # Cell2 Group2 # Cell3 Group3 # Cell4 Group2 # Cell5 Group3 # Cell6 Group3 ## gene information gene_info \u0026lt;- seurat_result@assays[[\u0026quot;originalexp\u0026quot;]]@meta.features head(gene_info) # gene_name de_gene BatchFacBatch1 BatchFacBatch2 DEFacGroup1 DEFacGroup2 # Gene1 Gene1 no 0.9098860 1.1054169 1 1 # Gene2 Gene2 no 0.9774161 0.9501320 1 1 # Gene3 Gene3 no 1.0541276 0.7597880 1 1 # Gene4 Gene4 no 1.1708139 0.7762219 1 1 # Gene5 Gene5 no 1.0017116 0.9963063 1 1 # Gene6 Gene6 no 0.7654326 1.1497335 1 1 # DEFacGroup3 # Gene1 1 # Gene2 1 # Gene3 1 # Gene4 1 # Gene5 1 # Gene6 1 h5ad If we select h5ad format, it is not possible to return the result in R, so you can get the path where the h5ad files save to and we can go to the path and read it in Python by scanpy.read_h5ad function (if you have already installed Python and scanpy module).\nsimulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;h5ad\u0026quot;, other_prior = list(batchCells = c(100, 100), nGenes = 1000, de.prob = 0.1, prob.group = c(0.2, 0.3, 0.5)), seed = 111 ) # nCells: 200 # nGenes: 1000 # nGroups: 3 # de.prob: 0.1 # nBatches: 2 # Creating h5Seurat file for version 3.1.5.9900 # Adding counts for originalexp # Adding data for originalexp # No variable features found for originalexp # Adding feature-level metadata for originalexp # Validating h5Seurat file # Adding data from originalexp as X # Transfering meta.features to var # Adding counts from originalexp as raw # Transfering meta.features to raw/var # Transfering meta.data to obs # Your data has been save to /var/folders/1l/xmc98tgx0m37wxtbtwnl6h7c0000gn/T//Rtmp9XZNt7/20230813094446.h5ad save_path \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;save_path\u0026quot;]] save_path # [1] \u0026quot;/var/folders/1l/xmc98tgx0m37wxtbtwnl6h7c0000gn/T//Rtmp9XZNt7/20230813094446.h5ad\u0026quot; Now, we can go to the path and check the data. Here, we read the h5ad file in R using reticulate R package (note that Python and scanpy module must have been installed).\n## install.packages(\u0026quot;reticulate\u0026quot;) scanpy \u0026lt;- reticulate::import(\u0026quot;scanpy\u0026quot;) data \u0026lt;- scanpy$read_h5ad(save_path) data ## Read h5ad file successfully # AnnData object with n_obs √ó n_vars = 200 √ó 1000 # obs: \u0026#39;orig.ident\u0026#39;, \u0026#39;nCount_originalexp\u0026#39;, \u0026#39;nFeature_originalexp\u0026#39;, \u0026#39;cell_name\u0026#39;, \u0026#39;batch\u0026#39;, \u0026#39;group\u0026#39; # var: \u0026#39;gene_name\u0026#39;, \u0026#39;de_gene\u0026#39;, \u0026#39;BatchFacBatch1\u0026#39;, \u0026#39;BatchFacBatch2\u0026#39;, \u0026#39;DEFacGroup1\u0026#39;, \u0026#39;DEFacGroup2\u0026#39;, \u0026#39;DEFacGroup3\u0026#39; "
},
{
	"uri": "/online/",
	"title": "Online Usage",
	"tags": [],
	"description": "",
	"content": "Online Usage simsite provides a guide tool for choosing suitable methods and another way for simulating single-cell or spatial transcriptome data online fast and conveniently. üíªüíªüíª\nChoose methods Simulation online "
},
{
	"uri": "/references/methods/",
	"title": "Vignettes",
	"tags": [],
	"description": "",
	"content": "Vignettes In this chapter, we will demonstrate the usage of each simulation method in detail. üìãüìãüìã\n"
},
{
	"uri": "/programming/2-estimation/",
	"title": "Estimation Parameters",
	"tags": [],
	"description": "",
	"content": " Estimate Parameters From Local R Step1: Load Packages Step2: Prepare Your Data and Prior Information Step3: Estimate Parameters Estimate Parameters From Docker in R Estimate Parameters By Simpipe Package One dataset ‚ñ∂Ô∏è Multiple Methods Multiple datasets ‚ñ∂Ô∏è Multiple Methods Estimating essential parameters from the real datasets is a necessary step before simulating a new dataset. In this vignette, we demonstrate three ways of performing estimation step, including:\nDepend on local R environment Utilize Docker and link Docker and R Special estimation scenarios by Simpipe package Estimate Parameters From Local R Make sure that you have already installed three main packages (simutils, simmethods and simpipe) before doing estimation. If not, please refer to Installation.\nStep1: Load Packages First, library our packages by:\nlibrary(simmethods) library(simpipe) Step2: Prepare Your Data and Prior Information In the estimation, real dataset or the input dataset is necessary. You can load the example dataset in simmethods by:\nref_data \u0026lt;- simmethods::data The gene expression profile should be a matrix, not the sparese one or a data frame.\nThe prior information of cell groups is also in the simmethods package, and we will demonstrate how to use it later.\ngroup_information \u0026lt;- simmethods::group_condition Step3: Estimate Parameters Example A: Splat (Only need gene expression matrix) Splat is one of the methods in Splatter package and only reference (real) data is needed to learn the useful parameters. We can directly call Splat_estimation function to do so.\nestimation_result \u0026lt;- simmethods::Splat_estimation( ref_data = ref_data, seed = 111) The list of result contains two types of information:\nestimate_result, the learned parameters by Splat estimate_detection, the running time and memory usage detected by peakRAM package. Example B: zingeR (Cell group information is needed) In zingeR method, the information of cell groups is needed. We can prepare a numeric vector to specify the identity for every cell in the expression matrix.\ngroup_information \u0026lt;- as.numeric(simmethods::group_condition) The other_prior parameter learns the list of other prior information, including:\ngroup.condition, the numeric vector of cell group labels. batch.condition, the numeric vector of cell batch labels. other names After preparing the dataset and prior information, we can use zingeR to estimate paramaters.\nestimation_result \u0026lt;- simmethods::zingeR_estimation( ref_data = ref_data, other_prior = list(group.condition = group_information), seed = 111, verbose = TRUE) # Estimating parameters using zingeR Example C: Parameter and Prior Information Sometimes users may want to know what parameters are presented in a method and what kinds of prior information are needed. Usually, user can browse the help vignette by help(function_name) or ?function_name.\nFor example, if we want to know the parameters in the SPsimSeq method, we can call help(SPsimSeq_simulation).\nhelp(SPsimSeq_simulation) We detailed the prior information and parameters that the method requires and users usually use.\n# Details # In addtion to simulate datasets with default parameters, users want to simulate other kinds of datasets, e.g. a counts matrix with 2 or more # cell groups. In SPsimSeq, you can set extra parameters to simulate datasets. # # The customed parameters you can set are below: # # nCells. In SPsimSeq, you can set nCells directly. For example, if you want to simulate 1000 cells, you can type other_prior = list(nCells = # 1000). # # nGenes. You can directly set other_prior = list(nGenes = 5000) to simulate 5000 genes. # # group.condition. You can input cell group information as an integer vector to specify which group that each cell belongs to. See Examples. # # de.prob. You can directly set other_prior = list(de.prob = 0.2) to simulate DEGs that account for 20 percent of all genes. # # fc.group. You can directly set other_prior = list(fc.group = 2) to specify the minimum fold change of DEGs. # # batch.condition. You can input cell batch information as an integer vector to specify which batch that each cell belongs to. See Examples. Example D: Default Parameters We only provide the default parameters for some of the methods:\nSplat, SplatPop, Kersplat Simple SCRIP Lun, Lun2, zinbwave BASiCS ESCO If we want to get the default parameter of SCRIP, input:\nSCRIP_param \u0026lt;- simutils::default_parameters(\u0026quot;SCRIP\u0026quot;) The object of default parameters can be directly used for simulation step.\nEstimate Parameters From Docker in R Estimating parameters by a Docker container in R is not challenging since all manipulations are the same as those that have been demonstrated above, except for the function and R package used.\nFirst, start Docker service and check:\nlibrary(simpipe2docker) simpipe2docker::test_docker_installation(detailed = TRUE) # ‚úî Docker is installed # ‚úî Docker daemon is running # ‚úî Docker is at correct version (\u0026gt;1.0): 1.41 # ‚úî Docker is in linux mode # ‚úî Docker can pull images # ‚úî Docker can run image # ‚úî Docker can mount temporary volumes # ‚úî Docker test successful ----------------------------------------------------------------- # [1] TRUE Next, prepare your data and prior information:\ndata \u0026lt;- simmethods::data group_condition \u0026lt;- as.numeric(simmethods::group_condition) Estimate parameters by Splat method:\nestimation_result \u0026lt;- simpipe2docker::estimate_parameters_container( ref_data = data, method = \u0026quot;Splat\u0026quot;, other_prior = list(group.condition = group_condition), seed = 111, verbose = TRUE ) # Learning parameters from data 1 # Running /usr/local/bin/docker run --name \\ # 20230510_151550__container__wjYWE9mSHC -e \u0026#39;TMPDIR=/tmp2\u0026#39; --workdir \\ # /home/admin/ -v \\ # \u0026#39;/var/folders/1l/xmc98tgx0m37wxtbtwnl6h7c0000gn/T//RtmpyDFvJI:/home/admin/docker_path\u0026#39; \\ # -v \\ # \u0026#39;/tmp/folders/1l/xmc98tgx0m37wxtbtwnl6h7c0000gn/T//RtmpyDFvJI/file414b397e13a0/tmp:/tmp2\u0026#39; \\ # duohongrui/simpipe # WARNING: The requested image\u0026#39;s platform (linux/amd64) does not match the detected host platform (linux/arm64/v8) and no specific platform was requested # Estimating parameters using Splat # Output is saved to /var/folders/1l/xmc98tgx0m37wxtbtwnl6h7c0000gn/T//RtmpyDFvJI # Attempting to read output into R Users can also input the list of multiple datasets and use more than one method to performe the estimation step. In this case, you can refer to the next topic Estimate Parameters By Simpipe Package and just change the function name that located in the simpipe2docker package.\nEstimate Parameters By Simpipe Package In addition to calling functions from simmethods package, users can also use estimate_parameters function in simpipe package. There are some advantages:\nOne dataset can be estimated by multiple methods Multiple datasets can be estimated by multiple methods One dataset ‚ñ∂Ô∏è Multiple Methods If you want to estimate parameters from one dataset by many other simulation methods, please make sure that you have already know the requirements of prior information of every method. For example, if we want to estimate the parameters using three methods: Splat, zingR and powsimR, we should browse the vignettes of these three methods.\nAfter checking the vignettes, we list the necessary prior information and optional cutomed parameters here:\nSplat: none (just a gene matrix) zingR: prior information (a numeric vector of cell groups) powsimR: optional parameters (RNA-seq, Protocol and Normalisation) Then we write these parameters in a list:\nother_prior = list(group.condition = as.numeric(group_condition), RNAseq = \u0026quot;singlecell\u0026quot;, Protocol = \u0026quot;UMI\u0026quot;, Normalisation = \u0026quot;scran\u0026quot;) estimation_result \u0026lt;- simpipe::estimate_parameters( method = c(\u0026quot;Splat\u0026quot;, \u0026quot;zingeR\u0026quot;, \u0026quot;powsimR\u0026quot;), ref_data = ref_data, other_prior = other_prior) # Registered S3 method overwritten by \u0026#39;gdata\u0026#39;: # method from # reorder.factor gplots # Estimating parameters using powsimR # Estimating parameters using estimateParam function # The provided count matrix has 160 out of 160 single cells and 4000 out of 4000 genes with at least 1 count. # 29 out of 160 single cells were determined to be outliers and removed prior to normalisation. # 3 genes out of 4000 were deemed unexpressed and removed prior to normalisation. # Using calculateSumFactors, i.e. deconvolution over all cells! # Estimating moments. # Fitting models. # For 3996 out of 4000 genes, mean, dispersion and dropout could be estimated. 131 out of 160 single cells were used for this. # Estimating parameters using Splat # Estimating parameters using zingeR If the necessary information is not input, the error message will turn out. You must also make sure that the names of methods are right spelled.\nYou can see a list of three elements in the result and that means the estimation is done:\nnames(estimation_result) # [1] \u0026quot;refdata_powsimR\u0026quot; \u0026quot;refdata_Splat\u0026quot; \u0026quot;refdata_zingeR\u0026quot; Multiple datasets ‚ñ∂Ô∏è Multiple Methods Multiple datasets can also be estimated by many methods using estimate_parameters function. Besides the prior information and optional parameters, the ref_data parameter in estimate_parameters function should be a named list when multiple datasets are involved.\nHere, we can first create a data list with customed names (data1 and data2):\ndata_list \u0026lt;- list(data1 = ref_data, data2 = ref_data) Then, set the prior information:\nother_prior = list(group.condition = as.numeric(group_condition), RNAseq = \u0026quot;singlecell\u0026quot;, Protocol = \u0026quot;UMI\u0026quot;, Normalisation = \u0026quot;scran\u0026quot;) Execute the procedure:\nestimation_result \u0026lt;- simpipe::estimate_parameters( method = c(\u0026quot;Splat\u0026quot;, \u0026quot;zingeR\u0026quot;, \u0026quot;powsimR\u0026quot;), ref_data = data_list, other_prior = other_prior) # Estimating parameters using powsimR # Estimating parameters using estimateParam function # The provided count matrix has 160 out of 160 single cells and 4000 out of 4000 genes with at least 1 count. # 29 out of 160 single cells were determined to be outliers and removed prior to normalisation. # 3 genes out of 4000 were deemed unexpressed and removed prior to normalisation. # Using calculateSumFactors, i.e. deconvolution over all cells! # Estimating moments. # Fitting models. # For 3996 out of 4000 genes, mean, dispersion and dropout could be estimated. 131 out of 160 single cells were used for this. # Estimating parameters using Splat # Estimating parameters using zingeR # Estimating parameters using powsimR # Estimating parameters using estimateParam function # The provided count matrix has 160 out of 160 single cells and 4000 out of 4000 genes with at least 1 count. # 29 out of 160 single cells were determined to be outliers and removed prior to normalisation. # 3 genes out of 4000 were deemed unexpressed and removed prior to normalisation. # Using calculateSumFactors, i.e. deconvolution over all cells! # Estimating moments. # Fitting models. # For 3996 out of 4000 genes, mean, dispersion and dropout could be estimated. 131 out of 160 single cells were used for this. # Estimating parameters using Splat # Estimating parameters using zingeR We will see a list of six elements in the result:\nnames(estimation_result) # [1] \u0026quot;data1_powsimR\u0026quot; \u0026quot;data1_Splat\u0026quot; \u0026quot;data1_zingeR\u0026quot; \u0026quot;data2_powsimR\u0026quot; # [5] \u0026quot;data2_Splat\u0026quot; \u0026quot;data2_zingeR\u0026quot; All of above manipulations can be done by Docker container and only the function name should be changed into estimate_parameters_container in simpipe2docker package\n"
},
{
	"uri": "/references/methods/2-simple/",
	"title": "Simple",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using Simple Datasets with default parameters Determin the number of cells and genes Here Simple method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data dim(ref_data) # [1] 4000 160 Using simmethods::Simple_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::Simple_estimation(ref_data = ref_data, verbose = T, seed = 10) # Estimating parameters using Simple Simulating datasets using Simple After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::Simple_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 1 column # cell_name # \u0026lt;character\u0026gt; # Cell1 Cell1 # Cell2 Cell2 # Cell3 Cell3 # Cell4 Cell4 # Cell5 Cell5 # Cell6 Cell6 head(rowData(SCE_result)) # DataFrame with 6 rows and 1 column # gene_name # \u0026lt;character\u0026gt; # Gene1 Gene1 # Gene2 Gene2 # Gene3 Gene3 # Gene4 Gene4 # Gene5 Gene5 # Gene6 Gene6 Determin the number of cells and genes Here, we simulate a new dataset with 500 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::Simple_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 500, nGenes = 1000), seed = 111 ) # nCells: 500 # nGenes: 1000 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 "
},
{
	"uri": "/online/2-simulation_online/",
	"title": "Simulation Online",
	"tags": [],
	"description": "",
	"content": " R Markdown Including Plots R Markdown This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com.\nWhen you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:\nsummary(cars) ## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00 Including Plots You can also embed plots, for example:\nNote that the echo = FALSE parameter was added to the code chunk to prevent printing of the R code that generated the plot.\n"
},
{
	"uri": "/references/",
	"title": "References",
	"tags": [],
	"description": "",
	"content": "References simmethods is the core package in the project. It contains 45+ simulation methods for single-cell or spatial transcriptome data. üìöüìöüìö\nMethods Overview: overview of all simulation methods and available parameters for every method Vignettes: detailed descriptional usage for each method "
},
{
	"uri": "/programming/3-simulation/",
	"title": "Data Simulation",
	"tags": [],
	"description": "",
	"content": " Simulate Datasets From Local R Step1: Prepare Estimation Results Step2: Check Availabel Parameters Step3: Simulation Simulate Datasets From Docker in R Simulate Datasets By Simpipe Package Generate Multiple Datasets For Every Estimation Result We have already known how to estimate parameters from one or more real datasets and got the estimation results. In this chapter, we will demonstrate how to simulate single-cell transcriptomics data based on the previous estimation results, especially the useful parameters that are usually customized to satisfy the different application situations.\nFor demonstrations, we use Splat method as it contains all functionalities and available parameters that we want to introduce.\nLibrary our packages first:\nlibrary(simmethods) library(simpipe) Simulate Datasets From Local R Step1: Prepare Estimation Results Load data and perform estimation:\nref_data \u0026lt;- simmethods::data estimation_result \u0026lt;- simmethods::Splat_estimation( ref_data = ref_data, verbose = TRUE, seed = 666 ) # Estimating parameters using Splat Step2: Check Availabel Parameters Next, check the optional parameters that control the size of the simulated datasets, the proportion of DEGs, the number of cell batches and datasets with cellular trajectory. In this way, you will know the essential parameters that may satisfy your simulation requirements.\nhelp(SplatPop_simulation) ## Details # In addtion to simulate datasets with default parameters, users want to simulate other kinds of datasets, e.g. a counts matrix with 2 or more cell groups. In Splat, you can set extra parameters to simulate datasets. # # The customed parameters you can set are below: # # nCells. In Splat, you can not set nCells directly and should set batchCells instead. For example, if you want to simulate 1000 cells, you can type other_prior = list(batchCells = 1000). If you type other_prior = list(batchCells = c(500, 500)), the simulated data will have two batches. # # nGenes. You can directly set other_prior = list(nGenes = 5000) to simulate 5000 genes. # # nGroups. You can not directly set other_prior = list(nGroups = 3) to simulate 3 groups. Instead, you should set other_prior = list(prob.group = c(0.2, 0.3, 0.5)) where the sum of group probabilities must equal to 1. # # de.prob. You can directly set other_prior = list(de.prob = 0.2) to simulate DEGs that account for 20 percent of all genes. # # prob.group. You can directly set other_prior = list(prob.group = c(0.2, 0.3, 0.5)) to assign three proportions of cell groups. Note that the number of groups always equals to the length of the vector. # # nBatches. You can not directly set other_prior = list(nBatches = 3) to simulate 3 batches. Instead, you should set other_prior = list(batchCells = c(500, 500, 500)) to reach the goal and the total cells are 1500. # # If users want to simulate datasets for trajectory inference, just set other_prior = list(paths = TRUE). Simulating trajectory datasets can also specify the parameters of group and batch. See Examples. These parameters can be categorized into 4 classes and respectively represent the main four functionalities in Splat method:\nparameters for cell groups\nparameters for DEGs\nparameters for batches\nparameters for cellular differentiation trajectory\nIn the next part of step3, we will describe these application situations in detail.\nStep3: Simulation Task1: The Number of Cell and Gene The first application situation is generating datasets with different number of cells and genes. After browsing the vignettes of Splat method, we know that batchCells parameter controls the number of cells and nGenes controls the number of genes.\nSimulate 1000 cells and 5000 genes:\ndata_1000_5000 \u0026lt;- simmethods::Splat_simulation( parameters = estimation_result$estimate_result, other_prior = list(batchCells = 1000, nGenes = 5000), return_format = \u0026quot;Seurat\u0026quot;, verbose = TRUE, seed = 666 ) # nCells: 1000 # nGenes: 5000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 # Simulating datasets using Splat # Getting parameters... # Creating simulation object... # Simulating library sizes... # Simulating gene means... # Simulating BCV... # Simulating counts... # Simulating dropout (if needed)... # Sparsifying assays... # Automatically converting to sparse matrices, threshold = 0.95 # Skipping \u0026#39;BatchCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BaseCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BCV\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;CellMeans\u0026#39;: estimated sparse size 1.49 * dense matrix # Skipping \u0026#39;TrueCounts\u0026#39;: estimated sparse size 1.6 * dense matrix # Skipping \u0026#39;counts\u0026#39;: estimated sparse size 1.6 * dense matrix # Done! data_1000_5000$simulate_result # An object of class Seurat # 5000 features across 1000 samples within 1 assay # Active assay: originalexp (5000 features, 0 variable features) Simulate 10000 cells and 20000 genes:\ndata_10000_20000 \u0026lt;- simmethods::Splat_simulation( parameters = estimation_result$estimate_result, other_prior = list(batchCells = 10000, nGenes = 20000), return_format = \u0026quot;Seurat\u0026quot;, verbose = TRUE, seed = 666 ) # nCells: 10000 # nGenes: 20000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 # Simulating datasets using Splat # Getting parameters... # Creating simulation object... # Simulating library sizes... # Simulating gene means... # Simulating BCV... # Simulating counts... # Simulating dropout (if needed)... # Sparsifying assays... # Automatically converting to sparse matrices, threshold = 0.95 # Skipping \u0026#39;BatchCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BaseCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BCV\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;CellMeans\u0026#39;: estimated sparse size 1.47 * dense matrix # Skipping \u0026#39;TrueCounts\u0026#39;: estimated sparse size 1.06 * dense matrix # Skipping \u0026#39;counts\u0026#39;: estimated sparse size 1.06 * dense matrix # Done! See the number of cells and genes\ndata_10000_20000$simulate_result # An object of class Seurat # 20000 features across 10000 samples within 1 assay # Active assay: originalexp (20000 features, 0 variable features) Check the execution time:\ndata_10000_20000$simulate_detection$Elapsed_Time_sec # [1] 44.628 Task2: Cell Groups If we want to simulate two groups of cells using Splat method, we can use prob.group parameter to specify the proportions of cells in two groups. The length of prob.group vector defines the number of groups.\nSimulate two groups (4:6):\ndata_4_6 \u0026lt;- simmethods::Splat_simulation( parameters = estimation_result$estimate_result, other_prior = list(batchCells = 1000, nGenes = 5000, prob.group = c(0.4, 0.6)), return_format = \u0026quot;Seurat\u0026quot;, verbose = TRUE, seed = 666 ) # nCells: 1000 # nGenes: 5000 # nGroups: 2 # de.prob: 0.1 # nBatches: 1 # Simulating datasets using Splat # Getting parameters... # Creating simulation object... # Simulating library sizes... # Simulating gene means... # Simulating group DE... # Simulating cell means... # Simulating BCV... # Simulating counts... # Simulating dropout (if needed)... # Sparsifying assays... # Automatically converting to sparse matrices, threshold = 0.95 # Skipping \u0026#39;BatchCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BaseCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BCV\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;CellMeans\u0026#39;: estimated sparse size 1.49 * dense matrix # Skipping \u0026#39;TrueCounts\u0026#39;: estimated sparse size 1.6 * dense matrix # Skipping \u0026#39;counts\u0026#39;: estimated sparse size 1.6 * dense matrix # Done! Check group labels of cells\ntable(data_4_6$simulate_result$group) # # Group1 Group2 # 407 593 Simulate five groups (1:1:2:3:3):\ndata_11233 \u0026lt;- simmethods::Splat_simulation( parameters = estimation_result$estimate_result, other_prior = list(batchCells = 1000, nGenes = 5000, prob.group = c(0.1, 0.1, 0.2, 0.3, 0.3)), return_format = \u0026quot;Seurat\u0026quot;, verbose = TRUE, seed = 666 ) # nCells: 1000 # nGenes: 5000 # nGroups: 5 # de.prob: 0.1 # nBatches: 1 # Simulating datasets using Splat # Getting parameters... # Creating simulation object... # Simulating library sizes... # Simulating gene means... # Simulating group DE... # Simulating cell means... # Simulating BCV... # Simulating counts... # Simulating dropout (if needed)... # Sparsifying assays... # Automatically converting to sparse matrices, threshold = 0.95 # Skipping \u0026#39;BatchCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BaseCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BCV\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;CellMeans\u0026#39;: estimated sparse size 1.49 * dense matrix # Skipping \u0026#39;TrueCounts\u0026#39;: estimated sparse size 1.6 * dense matrix # Skipping \u0026#39;counts\u0026#39;: estimated sparse size 1.6 * dense matrix # Done! Check group labels of cells\ntable(data_11233$simulate_result$group) # # Group1 Group2 Group3 Group4 Group5 # 95 106 206 290 303 Task3: Differential Expressed Genes Users can also set the proportion of DEGs in Splat method via de.prob parameter which ranges from 0 to 1.\nHere we set de.prob as 0.2 to simulate 20% DEGs in two cell groups.\nsimulated_data \u0026lt;- simmethods::Splat_simulation( parameters = estimation_result$estimate_result, other_prior = list(batchCells = 1000, nGenes = 5000, prob.group = c(0.4, 0.6), de.prob = 0.2), return_format = \u0026quot;list\u0026quot;, verbose = TRUE, seed = 666 ) # nCells: 1000 # nGenes: 5000 # nGroups: 2 # de.prob: 0.2 # nBatches: 1 # Simulating datasets using Splat # Getting parameters... # Creating simulation object... # Simulating library sizes... # Simulating gene means... # Simulating group DE... # Simulating cell means... # Simulating BCV... # Simulating counts... # Simulating dropout (if needed)... # Sparsifying assays... # Automatically converting to sparse matrices, threshold = 0.95 # Skipping \u0026#39;BatchCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BaseCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BCV\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;CellMeans\u0026#39;: estimated sparse size 1.49 * dense matrix # Skipping \u0026#39;TrueCounts\u0026#39;: estimated sparse size 1.6 * dense matrix # Skipping \u0026#39;counts\u0026#39;: estimated sparse size 1.6 * dense matrix # Done! Check group labels of cells\ntable(simulated_data$simulate_result$col_meta$group) # # Group1 Group2 # 407 593 Check the proportion of DEGs\nrow_meta \u0026lt;- simulated_data$simulate_result$row_meta table(row_meta$de_gene == \u0026quot;yes\u0026quot;)/length(row_meta$de_gene) # # FALSE TRUE # 0.8068 0.1932 We then simulate another dataset which contains more than 2 groups (4 groups and 40% DEGs):\nsimulated_data \u0026lt;- simmethods::Splat_simulation( parameters = estimation_result$estimate_result, other_prior = list(batchCells = 1000, nGenes = 5000, prob.group = c(0.2, 0.2, 0.3, 0.3), de.prob = 0.4), return_format = \u0026quot;list\u0026quot;, verbose = TRUE, seed = 666 ) # nCells: 1000 # nGenes: 5000 # nGroups: 4 # de.prob: 0.4 # nBatches: 1 # Simulating datasets using Splat # Getting parameters... # Creating simulation object... # Simulating library sizes... # Simulating gene means... # Simulating group DE... # Simulating cell means... # Simulating BCV... # Simulating counts... # Simulating dropout (if needed)... # Sparsifying assays... # Automatically converting to sparse matrices, threshold = 0.95 # Skipping \u0026#39;BatchCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BaseCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BCV\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;CellMeans\u0026#39;: estimated sparse size 1.49 * dense matrix # Skipping \u0026#39;TrueCounts\u0026#39;: estimated sparse size 1.6 * dense matrix # Skipping \u0026#39;counts\u0026#39;: estimated sparse size 1.6 * dense matrix # Done! Check group labels of cells\ntable(simulated_data$simulate_result$col_meta$group) # # Group1 Group2 Group3 Group4 # 201 206 290 303 Check the proportion of DEGs\nrow_meta \u0026lt;- simulated_data$simulate_result$row_meta table(row_meta$de_gene == \u0026quot;yes\u0026quot;)/length(row_meta$de_gene) # # FALSE TRUE # 0.6568 0.3432 Note that we can know the DEGs between any pair of two groups in Splat method (except for scDesign and SPARSim). For example, if we want to get the DEGs between the group1 and group2, we should extract the DEFactor in gene metadata:\ngene_meta \u0026lt;- simulated_data$simulate_result$row_meta DEFactor1 \u0026lt;- gene_meta$DEFacGroup1 DEFactor2 \u0026lt;- gene_meta$DEFacGroup2 Then we do the division:\nDEFactor \u0026lt;- DEFactor1/DEFactor2 Check the gene that whose DEFactor is not equal to 1 and they are defined as the DEGs between group1 and group2:\ntable(DEFactor != 1) # # FALSE TRUE # 4034 966 DEGs_group1_group2 \u0026lt;- rownames(gene_meta)[DEFactor != 1] DEGs_group1_group2[1:10] # [1] \u0026quot;Gene1\u0026quot; \u0026quot;Gene4\u0026quot; \u0026quot;Gene7\u0026quot; \u0026quot;Gene11\u0026quot; \u0026quot;Gene12\u0026quot; \u0026quot;Gene15\u0026quot; \u0026quot;Gene16\u0026quot; \u0026quot;Gene17\u0026quot; # [9] \u0026quot;Gene36\u0026quot; \u0026quot;Gene45\u0026quot; scDesign and SPARSim can not return the DEGs between any pair of groups when the number of cell groups is higher than 2. But when there are only two groups in a simulated data, the DEGs are valid.\nTask4: Cell Batches Simulating different cell batches is also an important application situation in many researches related to benchmarking and method development.\nIn Splat and many other methods, users can specify the number of cell batches and the cell numbers in every batch via batchCells parameter. Here, we will simulate 3 batches with cell numbers of 1000, 2000 and 3000, respectively.\nsimulated_data \u0026lt;- simmethods::Splat_simulation( parameters = estimation_result$estimate_result, other_prior = list(batchCells = c(1000, 2000, 3000), nGenes = 5000), return_format = \u0026quot;list\u0026quot;, verbose = TRUE, seed = 666 ) # nCells: 6000 # nGenes: 5000 # nGroups: 1 # de.prob: 0.1 # nBatches: 3 # Simulating datasets using Splat # Getting parameters... # Creating simulation object... # Simulating library sizes... # Simulating gene means... # Simulating batch effects... # Simulating BCV... # Simulating counts... # Simulating dropout (if needed)... # Sparsifying assays... # Automatically converting to sparse matrices, threshold = 0.95 # Skipping \u0026#39;BatchCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BaseCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BCV\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;CellMeans\u0026#39;: estimated sparse size 1.49 * dense matrix # Skipping \u0026#39;TrueCounts\u0026#39;: estimated sparse size 1.59 * dense matrix # Skipping \u0026#39;counts\u0026#39;: estimated sparse size 1.59 * dense matrix # Done! Check the batches:\ntable(simulated_data$simulate_result$col_meta$batch) # # Batch1 Batch2 Batch3 # 1000 2000 3000 Task5: Cellular Trajectory Using Splat method to simulate the data with cellular differentiation trajectory is another application situation of data simulation. Simply, we can set paths parameter as TRUE.\nsimulated_data \u0026lt;- simmethods::Splat_simulation( parameters = estimation_result$estimate_result, other_prior = list(batchCells = 1000, prob.group = c(0.3, 0.2, 0.5), nGenes = 5000, paths = TRUE), return_format = \u0026quot;SingleCellExperiment\u0026quot;, verbose = TRUE, seed = 666 ) # nCells: 1000 # nGenes: 5000 # nGroups: 3 # de.prob: 0.1 # nBatches: 1 # Simulating datasets using Splat # Simulating trajectory datasets by Splat # Getting parameters... # Creating simulation object... # Simulating library sizes... # Simulating gene means... # Simulating path endpoints... # Simulating path steps... # Simulating BCV... # Simulating counts... # Simulating dropout (if needed)... # Sparsifying assays... # Automatically converting to sparse matrices, threshold = 0.95 # Skipping \u0026#39;BatchCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BaseCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BCV\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;CellMeans\u0026#39;: estimated sparse size 1.49 * dense matrix # Skipping \u0026#39;TrueCounts\u0026#39;: estimated sparse size 1.6 * dense matrix # Skipping \u0026#39;counts\u0026#39;: estimated sparse size 1.6 * dense matrix # Done! library(scater) # Loading required package: scuttle # Loading required package: ggplot2 sim.paths \u0026lt;- logNormCounts(simulated_data$simulate_result) sim.paths \u0026lt;- runPCA(sim.paths) plotPCA(sim.paths, colour_by = \u0026quot;group\u0026quot;) If you want to set other parameters related to the trajectory in Splat method, you can browse the official vignettes represented in Splatter package and the website.\nhelp(splatSimulate, package = \u0026quot;splatter\u0026quot;) Here, we only add extra two parameters path.nSteps and path.skew:\nsimulated_data \u0026lt;- simmethods::Splat_simulation( parameters = estimation_result$estimate_result, other_prior = list(batchCells = 1000, prob.group = c(0.3, 0.2, 0.5), nGenes = 5000, paths = TRUE, path.nSteps = 20, path.skew = 0.1), return_format = \u0026quot;SingleCellExperiment\u0026quot;, verbose = TRUE, seed = 666 ) # nCells: 1000 # nGenes: 5000 # nGroups: 3 # de.prob: 0.1 # nBatches: 1 # Simulating datasets using Splat # Simulating trajectory datasets by Splat # Getting parameters... # Creating simulation object... # Simulating library sizes... # Simulating gene means... # Simulating path endpoints... # Simulating path steps... # Simulating BCV... # Simulating counts... # Simulating dropout (if needed)... # Sparsifying assays... # Automatically converting to sparse matrices, threshold = 0.95 # Skipping \u0026#39;BatchCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BaseCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BCV\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;CellMeans\u0026#39;: estimated sparse size 1.49 * dense matrix # Skipping \u0026#39;TrueCounts\u0026#39;: estimated sparse size 1.6 * dense matrix # Skipping \u0026#39;counts\u0026#39;: estimated sparse size 1.6 * dense matrix # Done! library(scater) sim.paths \u0026lt;- logNormCounts(simulated_data$simulate_result) sim.paths \u0026lt;- runPCA(sim.paths) plotPCA(sim.paths, colour_by = \u0026quot;group\u0026quot;) Simulate Datasets From Docker in R This part we will demonstrate how to simulate datasets by using Docker in R and users should make sure that Docker has been installed on your device.\nFirst, start Docker and check:\nlibrary(simpipe2docker) test_docker_installation(detailed = TRUE) # ‚úî Docker is installed # ‚úî Docker daemon is running # ‚úî Docker is at correct version (\u0026gt;1.0): 1.41 # ‚úî Docker is in linux mode # ‚úî Docker can pull images # ‚úî Docker can run image # ‚úî Docker can mount temporary volumes # ‚úî Docker test successful ----------------------------------------------------------------- # [1] TRUE Estimation parameters from Docker:\nestimation_result \u0026lt;- simpipe2docker::estimate_parameters_container( ref_data = ref_data, method = \u0026quot;Splat\u0026quot;, verbose = TRUE, seed = 666 ) # Learning parameters from data 1 # Running /usr/local/bin/docker run --name \\ # 20230807_112948__container__uxBxg1JNLM -e \u0026#39;TMPDIR=/tmp2\u0026#39; --workdir \\ # /home/admin/ -v \\ # \u0026#39;/var/folders/1l/xmc98tgx0m37wxtbtwnl6h7c0000gn/T//RtmpMrBHAW:/home/admin/docker_path\u0026#39; \\ # -v \\ # \u0026#39;/tmp/folders/1l/xmc98tgx0m37wxtbtwnl6h7c0000gn/T//RtmpMrBHAW/file8d9326fd785/tmp:/tmp2\u0026#39; \\ # duohongrui/simpipe # WARNING: The requested image\u0026#39;s platform (linux/amd64) does not match the detected host platform (linux/arm64/v8) and no specific platform was requested # Estimating parameters using Splat # Output is saved to /var/folders/1l/xmc98tgx0m37wxtbtwnl6h7c0000gn/T//RtmpMrBHAW # Attempting to read output into R Simulate new datasets from Docker:\n## simulate 1000 cells and 1000 genes simulated_data \u0026lt;- simpipe2docker::simulate_datasets_container( parameters = estimation_result, other_prior = list(batchCells = 1000, nGenes = 1000), return_format = \u0026quot;SingleCellExperiment\u0026quot;, verbose = TRUE, seed = 666 ) # Simulating dataset 1 # Running /usr/local/bin/docker run --name \\ # 20230807_113135__container__NigapuTAlX -e \u0026#39;TMPDIR=/tmp2\u0026#39; --workdir \\ # /home/admin/ -v \\ # \u0026#39;/var/folders/1l/xmc98tgx0m37wxtbtwnl6h7c0000gn/T//RtmpMrBHAW:/home/admin/docker_path\u0026#39; \\ # -v \\ # \u0026#39;/tmp/folders/1l/xmc98tgx0m37wxtbtwnl6h7c0000gn/T//RtmpMrBHAW/file8d913c1e7cb/tmp:/tmp2\u0026#39; \\ # duohongrui/simpipe # WARNING: The requested image\u0026#39;s platform (linux/amd64) does not match the detected host platform (linux/arm64/v8) and no specific platform was requested # Registered S3 method overwritten by \u0026#39;SeuratDisk\u0026#39;: # method from # as.sparse.H5Group Seurat # nCells: 1000 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 # Simulating datasets using Splat # Getting parameters... # Creating simulation object... # Simulating library sizes... # Simulating gene means... # Simulating BCV... # Simulating counts... # Simulating dropout (if needed)... # Sparsifying assays... # Automatically converting to sparse matrices, threshold = 0.95 # Skipping \u0026#39;BatchCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BaseCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BCV\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;CellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;TrueCounts\u0026#39;: estimated sparse size 2.21 * dense matrix # Skipping \u0026#39;counts\u0026#39;: estimated sparse size 2.21 * dense matrix # Done! # Output is saved to /var/folders/1l/xmc98tgx0m37wxtbtwnl6h7c0000gn/T//RtmpMrBHAW # Attempting to read output into R simulated_data$refdata_Splat_1$simulate_result # class: SingleCellExperiment # dim: 1000 1000 # metadata(1): Params # assays(6): BatchCellMeans BaseCellMeans ... TrueCounts counts # rownames(1000): Gene1 Gene2 ... Gene999 Gene1000 # rowData names(4): Gene BaseGeneMean OutlierFactor GeneMean # colnames(1000): Cell1 Cell2 ... Cell999 Cell1000 # colData names(3): Cell Batch ExpLibSize # reducedDimNames(0): # mainExpName: NULL # altExpNames(0): ## simulate 1000 cells and 1000 genes (two groups and 40% DEGs) simulated_data \u0026lt;- simpipe2docker::simulate_datasets_container( parameters = estimation_result, other_prior = list(batchCells = 1000, nGenes = 1000, prob.group = c(0.4, 0.6), de.prob = 0.4), return_format = \u0026quot;list\u0026quot;, verbose = TRUE, seed = 666 ) # Simulating dataset 1 # Running /usr/local/bin/docker run --name \\ # 20230807_113237__container__4YsDYtfOI7 -e \u0026#39;TMPDIR=/tmp2\u0026#39; --workdir \\ # /home/admin/ -v \\ # \u0026#39;/var/folders/1l/xmc98tgx0m37wxtbtwnl6h7c0000gn/T//RtmpMrBHAW:/home/admin/docker_path\u0026#39; \\ # -v \\ # \u0026#39;/tmp/folders/1l/xmc98tgx0m37wxtbtwnl6h7c0000gn/T//RtmpMrBHAW/file8d938ac09a/tmp:/tmp2\u0026#39; \\ # duohongrui/simpipe # WARNING: The requested image\u0026#39;s platform (linux/amd64) does not match the detected host platform (linux/arm64/v8) and no specific platform was requested # Registered S3 method overwritten by \u0026#39;SeuratDisk\u0026#39;: # method from # as.sparse.H5Group Seurat # nCells: 1000 # nGenes: 1000 # nGroups: 1 # de.prob: 0.4 # nBatches: 1 # Simulating datasets using Splat # Getting parameters... # Creating simulation object... # Simulating library sizes... # Simulating gene means... # Simulating BCV... # Simulating counts... # Simulating dropout (if needed)... # Sparsifying assays... # Automatically converting to sparse matrices, threshold = 0.95 # Skipping \u0026#39;BatchCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BaseCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BCV\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;CellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;TrueCounts\u0026#39;: estimated sparse size 2.21 * dense matrix # Skipping \u0026#39;counts\u0026#39;: estimated sparse size 2.21 * dense matrix # Done! # Output is saved to /var/folders/1l/xmc98tgx0m37wxtbtwnl6h7c0000gn/T//RtmpMrBHAW # Attempting to read output into R Simulate Datasets By Simpipe Package Based on simmethods package, simpipe package provides the other useful functions. Users can estimate parameters from multiple real datasets by using multiple methods. Meanwhile, users can also simulate multiple new datasets at once. In this part, we introduce some helpful functions in simpipe package.\nFirst, we should use simpipe to estimate parameters from two real datasets:\n## prepare a list of data data \u0026lt;- list(data1 = ref_data, data2 = ref_data) estimation_result \u0026lt;- simpipe::estimate_parameters( ref_data = data, method = \u0026quot;Splat\u0026quot;, verbose = TRUE, seed = 666 ) # Estimating parameters using Splat # Estimating parameters using Splat Generate Multiple Datasets For Every Estimation Result For every estimation result, we can generate multiple datasets by setting n parameter in simulate_datasets function:\nsimulated_data \u0026lt;- simpipe::simulate_datasets( parameters = estimation_result, other_prior = list(batchCells = 1000, nGenes = 1000), n = 3, return_format = \u0026quot;list\u0026quot;, verbose = TRUE, seed = 666 ) # The length of seeds is not identical to the time(s) that every method will be executed # The seed will be set as: 100 200 300 when performing every method # Simulating dataset 1 # nCells: 1000 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 # Simulating datasets using Splat # Getting parameters... # Creating simulation object... # Simulating library sizes... # Simulating gene means... # Simulating BCV... # Simulating counts... # Simulating dropout (if needed)... # Sparsifying assays... # Automatically converting to sparse matrices, threshold = 0.95 # Skipping \u0026#39;BatchCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BaseCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BCV\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;CellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;TrueCounts\u0026#39;: estimated sparse size 2.23 * dense matrix # Skipping \u0026#39;counts\u0026#39;: estimated sparse size 2.23 * dense matrix # Done! # Simulating dataset 2 # nCells: 1000 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 # Simulating datasets using Splat # Getting parameters... # Creating simulation object... # Simulating library sizes... # Simulating gene means... # Simulating BCV... # Simulating counts... # Simulating dropout (if needed)... # Sparsifying assays... # Automatically converting to sparse matrices, threshold = 0.95 # Skipping \u0026#39;BatchCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BaseCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BCV\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;CellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;TrueCounts\u0026#39;: estimated sparse size 2.25 * dense matrix # Skipping \u0026#39;counts\u0026#39;: estimated sparse size 2.25 * dense matrix # Done! # Simulating dataset 3 # nCells: 1000 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 # Simulating datasets using Splat # Getting parameters... # Creating simulation object... # Simulating library sizes... # Simulating gene means... # Simulating BCV... # Simulating counts... # Simulating dropout (if needed)... # Sparsifying assays... # Automatically converting to sparse matrices, threshold = 0.95 # Skipping \u0026#39;BatchCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BaseCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BCV\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;CellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;TrueCounts\u0026#39;: estimated sparse size 2.21 * dense matrix # Skipping \u0026#39;counts\u0026#39;: estimated sparse size 2.21 * dense matrix # Done! # Simulating dataset 4 # nCells: 1000 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 # Simulating datasets using Splat # Getting parameters... # Creating simulation object... # Simulating library sizes... # Simulating gene means... # Simulating BCV... # Simulating counts... # Simulating dropout (if needed)... # Sparsifying assays... # Automatically converting to sparse matrices, threshold = 0.95 # Skipping \u0026#39;BatchCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BaseCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BCV\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;CellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;TrueCounts\u0026#39;: estimated sparse size 2.23 * dense matrix # Skipping \u0026#39;counts\u0026#39;: estimated sparse size 2.23 * dense matrix # Done! # Simulating dataset 5 # nCells: 1000 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 # Simulating datasets using Splat # Getting parameters... # Creating simulation object... # Simulating library sizes... # Simulating gene means... # Simulating BCV... # Simulating counts... # Simulating dropout (if needed)... # Sparsifying assays... # Automatically converting to sparse matrices, threshold = 0.95 # Skipping \u0026#39;BatchCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BaseCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BCV\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;CellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;TrueCounts\u0026#39;: estimated sparse size 2.25 * dense matrix # Skipping \u0026#39;counts\u0026#39;: estimated sparse size 2.25 * dense matrix # Done! # Simulating dataset 6 # nCells: 1000 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 # Simulating datasets using Splat # Getting parameters... # Creating simulation object... # Simulating library sizes... # Simulating gene means... # Simulating BCV... # Simulating counts... # Simulating dropout (if needed)... # Sparsifying assays... # Automatically converting to sparse matrices, threshold = 0.95 # Skipping \u0026#39;BatchCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BaseCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BCV\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;CellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;TrueCounts\u0026#39;: estimated sparse size 2.21 * dense matrix # Skipping \u0026#39;counts\u0026#39;: estimated sparse size 2.21 * dense matrix # Done! We can also set seed parameter whose length is equal to the number of n:\nsimulated_data \u0026lt;- simpipe::simulate_datasets( parameters = estimation_result, other_prior = list(batchCells = 1000, nGenes = 1000), n = 3, return_format = \u0026quot;list\u0026quot;, verbose = TRUE, seed = c(666, 888, 999) ) # Simulating dataset 1 # nCells: 1000 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 # Simulating datasets using Splat # Getting parameters... # Creating simulation object... # Simulating library sizes... # Simulating gene means... # Simulating BCV... # Simulating counts... # Simulating dropout (if needed)... # Sparsifying assays... # Automatically converting to sparse matrices, threshold = 0.95 # Skipping \u0026#39;BatchCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BaseCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BCV\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;CellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;TrueCounts\u0026#39;: estimated sparse size 2.21 * dense matrix # Skipping \u0026#39;counts\u0026#39;: estimated sparse size 2.21 * dense matrix # Done! # Simulating dataset 2 # nCells: 1000 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 # Simulating datasets using Splat # Getting parameters... # Creating simulation object... # Simulating library sizes... # Simulating gene means... # Simulating BCV... # Simulating counts... # Simulating dropout (if needed)... # Sparsifying assays... # Automatically converting to sparse matrices, threshold = 0.95 # Skipping \u0026#39;BatchCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BaseCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BCV\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;CellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;TrueCounts\u0026#39;: estimated sparse size 2.21 * dense matrix # Skipping \u0026#39;counts\u0026#39;: estimated sparse size 2.21 * dense matrix # Done! # Simulating dataset 3 # nCells: 1000 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 # Simulating datasets using Splat # Getting parameters... # Creating simulation object... # Simulating library sizes... # Simulating gene means... # Simulating BCV... # Simulating counts... # Simulating dropout (if needed)... # Sparsifying assays... # Automatically converting to sparse matrices, threshold = 0.95 # Skipping \u0026#39;BatchCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BaseCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BCV\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;CellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;TrueCounts\u0026#39;: estimated sparse size 2.17 * dense matrix # Skipping \u0026#39;counts\u0026#39;: estimated sparse size 2.17 * dense matrix # Done! # Simulating dataset 4 # nCells: 1000 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 # Simulating datasets using Splat # Getting parameters... # Creating simulation object... # Simulating library sizes... # Simulating gene means... # Simulating BCV... # Simulating counts... # Simulating dropout (if needed)... # Sparsifying assays... # Automatically converting to sparse matrices, threshold = 0.95 # Skipping \u0026#39;BatchCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BaseCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BCV\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;CellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;TrueCounts\u0026#39;: estimated sparse size 2.21 * dense matrix # Skipping \u0026#39;counts\u0026#39;: estimated sparse size 2.21 * dense matrix # Done! # Simulating dataset 5 # nCells: 1000 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 # Simulating datasets using Splat # Getting parameters... # Creating simulation object... # Simulating library sizes... # Simulating gene means... # Simulating BCV... # Simulating counts... # Simulating dropout (if needed)... # Sparsifying assays... # Automatically converting to sparse matrices, threshold = 0.95 # Skipping \u0026#39;BatchCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BaseCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BCV\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;CellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;TrueCounts\u0026#39;: estimated sparse size 2.21 * dense matrix # Skipping \u0026#39;counts\u0026#39;: estimated sparse size 2.21 * dense matrix # Done! # Simulating dataset 6 # nCells: 1000 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 # Simulating datasets using Splat # Getting parameters... # Creating simulation object... # Simulating library sizes... # Simulating gene means... # Simulating BCV... # Simulating counts... # Simulating dropout (if needed)... # Sparsifying assays... # Automatically converting to sparse matrices, threshold = 0.95 # Skipping \u0026#39;BatchCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BaseCellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;BCV\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;CellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Skipping \u0026#39;TrueCounts\u0026#39;: estimated sparse size 2.17 * dense matrix # Skipping \u0026#39;counts\u0026#39;: estimated sparse size 2.17 * dense matrix # Done! "
},
{
	"uri": "/references/methods/3-kersplat/",
	"title": "Kersplat",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using Kersplat Datasets with default parameters Determin the number of cells and genes Here Kersplat method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data dim(ref_data) # [1] 4000 160 Using simmethods::Kersplat_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::Kersplat_estimation(ref_data = ref_data, verbose = T, seed = 10) # Estimating parameters using Kersplat # Warning in newKersplatParams(): The Kersplat simulation is still experimental # and may produce unreliable results. Please try it and report any issues to # https://github.com/Oshlack/splatter/issues. The development version may have # improved features. # Raw: 0.180467969462491 A: 5.24644589782513 B: 1.56749149061734 C: -3.99991188833989 Y: 0.796802242740237 # Warning in kersplatEstBCV(counts, params, verbose): Exponential corrected BCV is # negative.Using linear correction. # Warning in kersplatEstBCV(counts, params, verbose): Linear corrected BCV is # negative.Using existing bcv.common. Simulating datasets using Kersplat After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::Kersplat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 1 column # cell_name # \u0026lt;character\u0026gt; # Cell1 Cell1 # Cell2 Cell2 # Cell3 Cell3 # Cell4 Cell4 # Cell5 Cell5 # Cell6 Cell6 Determin the number of cells and genes Here, we simulate a new dataset with 500 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::Kersplat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 500, nGenes = 1000), seed = 111 ) # nCells: 500 # nGenes: 1000 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 "
},
{
	"uri": "/programming/4-evaluate_datasets/",
	"title": "Data Assessment",
	"tags": [],
	"description": "",
	"content": " Evaluate the simulated cell groups Simulate the dataset with cell groups Prepare the labels of cell groups Assess the simulated cell groups Evaluate the simulated DEGs Simulate the dataset with specified proportion of DEGs Prepare the information of DEGs Assess the validity of the simulated DEGs The situation where more than two groups are simulated Evaluate the simulated cell batches Simulate the dataset with cell batches Prepare the information of cell batches Assess the simulated cell batches Evaluate the simulated trajectories Simulate the dataset with cellular trajectory Assess the simulated trajectory Evaluate the functionalities of a method After obtaining the simulated datasets and corresponding information of cells and genes, we can assess the simulation output with the cell or gene information. For example, if we want to know how reliable the simulated groups of cells are, or how accurate the differential expressed genes between cell groups are, we can adopt the evaluation procedure implemented in the simpipe R package.\nThere are four aspects related to the simulation output that can be assessed:\nCell groups DEGs between cell groups Cell batches Cellular differentiation trajectory In this chapter, we will demonstrate how to assess a simulated gene expression data on these four aspects using the simpipe R package.\nLoad the reference data, and perform the parameter estimation.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data estimate_result \u0026lt;- simmethods::Splat_estimation(ref_data = ref_data, verbose = T, seed = 10) # Estimating parameters using Splat Evaluate the simulated cell groups Simulate the dataset with cell groups Initially, we should simulate a dataset with four cell groups using Splat method:\nsimulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = 1000, nGenes = 1000, prob.group = c(0.2, 0.3, 0.1, 0.4)), seed = 111 ) # nCells: 1000 # nGenes: 1000 # nGroups: 4 # de.prob: 0.1 # nBatches: 1 Prepare the labels of cell groups ### cell metadata cell_metadata \u0026lt;- simulate_result$simulate_result$col_meta cell_groups \u0026lt;- cell_metadata$group Assess the simulated cell groups cell_group_assess \u0026lt;- simpipe::data_functionality_summary( data = simulate_result$simulate_result$count_data, group = cell_groups ) # The group information is input... # ------------------------------------------------- # Evaluating cell groups # ------------------------------------------------- # 1-Calculating CDI... # 2-Calculating ROUGE... # Warning in simutils::calculate_cluster_properties(data = group_data, dist = NULL, : The ROUGE calculation failed # 3-Calculating silhouette... # 4-Calculating dunn... # 5-Calculating connectivity... # 6-Calculating DB index... str(cell_group_assess) # List of 4 # $ group_evaluation :List of 1 # ..$ data:List of 6 # .. ..$ CDI : num 5788015 # .. ..$ ROUGE : logi NA # .. ..$ silhouette : num -0.212 # .. ..$ dunn : num 4.41e-07 # .. ..$ connectivity: num 1055 # .. ..$ DB_index : num 35.1 # $ batch_evaluation : NULL # $ DEGs_evaluation : NULL # $ trajectory_evaluation: NULL Extract the evaluation result of cell groups:\nassess_group_result \u0026lt;- cell_group_assess$group_evaluation assess_group_result # $data # $data$CDI # [1] 5788015 # # $data$ROUGE # [1] NA # # $data$silhouette # [1] -0.2119363 # # $data$dunn # [1] 4.413479e-07 # # $data$connectivity # [1] 1055.473 # # $data$DB_index # [1] 35.06495 As you see, there are six metrics used for assessing the quality of cell groups:\nCDI: Clustering Deviation Index. If the CDI score is small, the simulated label set is close to the true label set and more reliable.\nROUGE: ROUGE is an entropy-based metric, enabling accurate, sensitive and robust assessment of cell cluster purity with the concept of quantifying the randomness of gene expression in cells. A cell population with higher purity will receive a value close to 1 and reversely close to 0.\nsilhouette: Average silouette width (ASW). The silouette width is a common internal metric to measure the extent of within-cluster distances of a cell and between-cluster distances of that cell to the closest cluster. The average silouette width (ASW) ranges from -1 to1.\ndunn: Dunn Index. Dunn Index is a clustering validity index by calculating the ratio of the smallest distance between cells which are not in the same cluster to the largest distance of cells in the same cluster. The higher the index, the better the clustering.\nconnectivity: The connectivity metric is designed to measure the connectedness degree of the partitioning clusters, which can be also used to assess the clustering performance.\nDB_index: Davies-Bouldin Index (DBI). DBI is a measurement of similarity between intra-cluster dispersion and separation of inter-clusters. The smaller the DBI is, the better the clustering.\nEvaluate the simulated DEGs Simulate the dataset with specified proportion of DEGs Firstly, we will simulate a dataset with two cell groups with 40% DEGs:\nsimulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = 1000, nGenes = 1000, prob.group = c(0.4, 0.6), de.prob = 0.4), seed = 111 ) # nCells: 1000 # nGenes: 1000 # nGroups: 2 # de.prob: 0.4 # nBatches: 1 Then, check the information of simulated DEGs\ngene_metadata \u0026lt;- simulate_result$simulate_result$row_meta table(gene_metadata$de_gene)/length(gene_metadata$de_gene) # # no yes # 0.646 0.354 Prepare the information of DEGs There are some essential information related to the DEGs to prepare:\nDEGs: A list of DEGs with the names of xxxvsxxx. Note that the names of DEGs are in the rownames of the matrix or the dataframe and the names of xxx is in the group characters. Needed if a matrix or a dataframe is input.\nDEA_method: The DEA method to get the DEGs. Choices: edgeRQLF, edgeRQLFDetRate, MASTcpmDetRate, MASTtpmDetRate, MASTcpm, MASTtpm, limmatrend, limmavoom, ttest and wilcox. Default is edgeRQLFDetRate.\nmodel_method: The method to establish the model using DEGs. SVM, Decision tree or RF (Random Forest). Default is SVM.\nNow we prepare the list of DEGs between two cell groups:\ncol_meta \u0026lt;- simulate_result$simulate_result$col_meta row_meta \u0026lt;- simulate_result$simulate_result$row_meta DEGs_list \u0026lt;- simpipe::prepare_DEGs_list(col_meta, row_meta) # Group2vsGroup1 str(DEGs_list) # List of 1 # $ Group2vsGroup1: chr [1:354] \u0026quot;Gene3\u0026quot; \u0026quot;Gene5\u0026quot; \u0026quot;Gene11\u0026quot; \u0026quot;Gene14\u0026quot; ... Then, we can chose the method for differential expression analysis and the machine learning method for modeling:\nDEA_method \u0026lt;- \u0026quot;edgeRQLFDetRate\u0026quot; model_method \u0026lt;- \u0026quot;SVM\u0026quot; Assess the validity of the simulated DEGs assess_DEGs \u0026lt;- simpipe::data_functionality_summary( data = simulate_result$simulate_result$count_data, group = col_meta$group, DEGs = DEGs_list, DEA_method = DEA_method, model_method = model_method ) # The DEGs information is input... # The group information is input... # ------------------------------------------------- # Evaluating DEGs # ------------------------------------------------- # 1--Distribution of null data... # 0 genes are removed when filtering # -------------------------------------------------- # Performing DEA with the 1/1 paired of groups. # Performing DEA using edgeR QLF model including the cellular detection rate # 2--True proportions of DEGs... # 0 genes are removed when filtering # -------------------------------------------------- # Performing DEA with the 1/1 paired of groups. # Performing DEA using edgeR QLF model including the cellular detection rate # 3--Modeling using DEGs... # Preprocessing data... # Modeling by SVM... # Predicting... # Setting levels: control = Group1, case = Group2 # Setting direction: controls \u0026lt; cases # ------------------------------------------------- # Evaluating cell groups # ------------------------------------------------- # 1-Calculating CDI... # 2-Calculating ROUGE... # Warning in simutils::calculate_cluster_properties(data = group_data, dist = NULL, : The ROUGE calculation failed # 3-Calculating silhouette... # 4-Calculating dunn... # 5-Calculating connectivity... # 6-Calculating DB index... Show the structure of the result:\nstr(assess_DEGs$DEGs_evaluation) # List of 1 # $ data:List of 3 # ..$ distribution_score:List of 2 # .. ..$ DEA_result_combinations:List of 1 # .. .. ..$ Group2vsGroup1:\u0026#39;data.frame\u0026#39;: 646 obs. of 5 variables: # .. .. .. ..$ logFC : num [1:646] -0.223 -0.199 0.21 -0.138 0.134 ... # .. .. .. ..$ logCPM: num [1:646] 8.17 8.31 7.88 9.6 9.58 ... # .. .. .. ..$ F : num [1:646] 10.9 9.08 8.66 7.35 6.1 ... # .. .. .. ..$ PValue: num [1:646] 0.000995 0.002641 0.003324 0.006807 0.013677 ... # .. .. .. ..$ FDR : num [1:646] 0.643 0.716 0.716 0.998 0.998 ... # .. ..$ distribution_score : num 1 # ..$ true_proportions :List of 2 # .. ..$ DEA_result_combinations:List of 5 # .. .. ..$ true_prop :List of 1 # .. .. .. ..$ Group2vsGroup1: num 0.853 # .. .. ..$ DEA :List of 1 # .. .. .. ..$ Group2vsGroup1:List of 1 # .. .. .. .. ..$ edgeRQLFDetRate:List of 2 # .. .. .. .. .. ..$ de_genes : chr [1:330] \u0026quot;Gene529\u0026quot; \u0026quot;Gene552\u0026quot; \u0026quot;Gene758\u0026quot; \u0026quot;Gene569\u0026quot; ... # .. .. .. .. .. ..$ DEA_result:\u0026#39;data.frame\u0026#39;: 1000 obs. of 5 variables: # .. .. .. .. .. .. ..$ logFC : num [1:1000] 1.32 -1.91 1.67 0.97 1.48 ... # .. .. .. .. .. .. ..$ logCPM: num [1:1000] 13.79 10.93 9.92 13.93 10.26 ... # .. .. .. .. .. .. ..$ F : num [1:1000] 2451 2095 1061 1037 1007 ... # .. .. .. .. .. .. ..$ PValue: num [1:1000] 7.38e-282 1.11e-256 2.44e-163 1.03e-160 2.46e-157 ... # .. .. .. .. .. .. ..$ FDR : num [1:1000] 7.38e-279 5.53e-254 8.14e-161 2.57e-158 4.92e-155 ... # .. .. ..$ DEGs_num : int 354 # .. .. ..$ DEGs_total : int 354 # .. .. ..$ weighted_true_prop: num 0.853 # .. ..$ true_proportion : num 0.853 # ..$ SVM_result :List of 6 # .. ..$ SVM_result:List of 2 # .. .. ..$ conf_matrix:List of 6 # .. .. .. ..$ positive: chr \u0026quot;Group1\u0026quot; # .. .. .. ..$ table : \u0026#39;table\u0026#39; int [1:2, 1:2] 78 1 1 120 # .. .. .. .. ..- attr(*, \u0026quot;dimnames\u0026quot;)=List of 2 # .. .. .. .. .. ..$ Prediction: chr [1:2] \u0026quot;Group1\u0026quot; \u0026quot;Group2\u0026quot; # .. .. .. .. .. ..$ Reference : chr [1:2] \u0026quot;Group1\u0026quot; \u0026quot;Group2\u0026quot; # .. .. .. ..$ overall : Named num [1:7] 0.99 0.979 0.964 0.999 0.605 ... # .. .. .. .. ..- attr(*, \u0026quot;names\u0026quot;)= chr [1:7] \u0026quot;Accuracy\u0026quot; \u0026quot;Kappa\u0026quot; \u0026quot;AccuracyLower\u0026quot; \u0026quot;AccuracyUpper\u0026quot; ... # .. .. .. ..$ byClass : Named num [1:11] 0.987 0.992 0.987 0.992 0.987 ... # .. .. .. .. ..- attr(*, \u0026quot;names\u0026quot;)= chr [1:11] \u0026quot;Sensitivity\u0026quot; \u0026quot;Specificity\u0026quot; \u0026quot;Pos Pred Value\u0026quot; \u0026quot;Neg Pred Value\u0026quot; ... # .. .. .. ..$ mode : chr \u0026quot;everything\u0026quot; # .. .. .. ..$ dots : list() # .. .. .. ..- attr(*, \u0026quot;class\u0026quot;)= chr \u0026quot;confusionMatrix\u0026quot; # .. .. ..$ roc :List of 15 # .. .. .. ..$ percent : logi FALSE # .. .. .. ..$ sensitivities : num [1:201] 1 1 1 1 1 1 1 1 1 1 ... # .. .. .. ..$ specificities : num [1:201] 0 0.0127 0.0253 0.038 0.0506 ... # .. .. .. ..$ thresholds : num [1:201] -Inf 5.54e-05 8.97e-05 1.07e-04 1.18e-04 ... # .. .. .. ..$ direction : chr \u0026quot;\u0026lt;\u0026quot; # .. .. .. ..$ cases : Named num [1:121] 0.999 0.994 0.999 1 0.999 ... # .. .. .. .. ..- attr(*, \u0026quot;names\u0026quot;)= chr [1:121] \u0026quot;Cell7\u0026quot; \u0026quot;Cell8\u0026quot; \u0026quot;Cell26\u0026quot; \u0026quot;Cell31\u0026quot; ... # .. .. .. ..$ controls : Named num [1:79] 0.011249 0.000637 0.002514 0.003981 0.000594 ... # .. .. .. .. ..- attr(*, \u0026quot;names\u0026quot;)= chr [1:79] \u0026quot;Cell29\u0026quot; \u0026quot;Cell36\u0026quot; \u0026quot;Cell43\u0026quot; \u0026quot;Cell49\u0026quot; ... # .. .. .. ..$ fun.sesp :function (thresholds, controls, cases, direction) # .. .. .. ..$ auc : \u0026#39;auc\u0026#39; num 0.999 # .. .. .. .. ..- attr(*, \u0026quot;partial.auc\u0026quot;)= logi FALSE # .. .. .. .. ..- attr(*, \u0026quot;percent\u0026quot;)= logi FALSE # .. .. .. .. ..- attr(*, \u0026quot;roc\u0026quot;)=List of 15 # .. .. .. .. .. ..$ percent : logi FALSE # .. .. .. .. .. ..$ sensitivities : num [1:201] 1 1 1 1 1 1 1 1 1 1 ... # .. .. .. .. .. ..$ specificities : num [1:201] 0 0.0127 0.0253 0.038 0.0506 ... # .. .. .. .. .. ..$ thresholds : num [1:201] -Inf 5.54e-05 8.97e-05 1.07e-04 1.18e-04 ... # .. .. .. .. .. ..$ direction : chr \u0026quot;\u0026lt;\u0026quot; # .. .. .. .. .. ..$ cases : Named num [1:121] 0.999 0.994 0.999 1 0.999 ... # .. .. .. .. .. .. ..- attr(*, \u0026quot;names\u0026quot;)= chr [1:121] \u0026quot;Cell7\u0026quot; \u0026quot;Cell8\u0026quot; \u0026quot;Cell26\u0026quot; \u0026quot;Cell31\u0026quot; ... # .. .. .. .. .. ..$ controls : Named num [1:79] 0.011249 0.000637 0.002514 0.003981 0.000594 ... # .. .. .. .. .. .. ..- attr(*, \u0026quot;names\u0026quot;)= chr [1:79] \u0026quot;Cell29\u0026quot; \u0026quot;Cell36\u0026quot; \u0026quot;Cell43\u0026quot; \u0026quot;Cell49\u0026quot; ... # .. .. .. .. .. ..$ fun.sesp :function (thresholds, controls, cases, direction) # .. .. .. .. .. ..$ auc : \u0026#39;auc\u0026#39; num 0.999 # .. .. .. .. .. .. ..- attr(*, \u0026quot;partial.auc\u0026quot;)= logi FALSE # .. .. .. .. .. .. ..- attr(*, \u0026quot;percent\u0026quot;)= logi FALSE # .. .. .. .. .. .. ..- attr(*, \u0026quot;roc\u0026quot;)=List of 8 # .. .. .. .. .. .. .. ..$ percent : logi FALSE # .. .. .. .. .. .. .. ..$ sensitivities: num [1:201] 1 1 1 1 1 1 1 1 1 1 ... # .. .. .. .. .. .. .. ..$ specificities: num [1:201] 0 0.0127 0.0253 0.038 0.0506 ... # .. .. .. .. .. .. .. ..$ thresholds : num [1:201] -Inf 5.54e-05 8.97e-05 1.07e-04 1.18e-04 ... # .. .. .. .. .. .. .. ..$ direction : chr \u0026quot;\u0026lt;\u0026quot; # .. .. .. .. .. .. .. ..$ cases : Named num [1:121] 0.999 0.994 0.999 1 0.999 ... # .. .. .. .. .. .. .. .. ..- attr(*, \u0026quot;names\u0026quot;)= chr [1:121] \u0026quot;Cell7\u0026quot; \u0026quot;Cell8\u0026quot; \u0026quot;Cell26\u0026quot; \u0026quot;Cell31\u0026quot; ... # .. .. .. .. .. .. .. ..$ controls : Named num [1:79] 0.011249 0.000637 0.002514 0.003981 0.000594 ... # .. .. .. .. .. .. .. .. ..- attr(*, \u0026quot;names\u0026quot;)= chr [1:79] \u0026quot;Cell29\u0026quot; \u0026quot;Cell36\u0026quot; \u0026quot;Cell43\u0026quot; \u0026quot;Cell49\u0026quot; ... # .. .. .. .. .. .. .. ..$ fun.sesp :function (thresholds, controls, cases, direction) # .. .. .. .. .. .. .. ..- attr(*, \u0026quot;class\u0026quot;)= chr \u0026quot;roc\u0026quot; # .. .. .. .. .. ..$ call : language roc.default(response = test_group, predictor = attr(predict_prob, \u0026quot;probabilities\u0026quot;)[, 1]) # .. .. .. .. .. ..$ original.predictor: Named num [1:200] 0.9991 0.9937 0.999 0.0112 0.9998 ... # .. .. .. .. .. .. ..- attr(*, \u0026quot;names\u0026quot;)= chr [1:200] \u0026quot;Cell7\u0026quot; \u0026quot;Cell8\u0026quot; \u0026quot;Cell26\u0026quot; \u0026quot;Cell29\u0026quot; ... # .. .. .. .. .. ..$ original.response : Factor w/ 2 levels \u0026quot;Group1\u0026quot;,\u0026quot;Group2\u0026quot;: 2 2 2 1 2 2 1 1 1 2 ... # .. .. .. .. .. ..$ predictor : Named num [1:200] 0.9991 0.9937 0.999 0.0112 0.9998 ... # .. .. .. .. .. .. ..- attr(*, \u0026quot;names\u0026quot;)= chr [1:200] \u0026quot;Cell7\u0026quot; \u0026quot;Cell8\u0026quot; \u0026quot;Cell26\u0026quot; \u0026quot;Cell29\u0026quot; ... # .. .. .. .. .. ..$ response : Factor w/ 2 levels \u0026quot;Group1\u0026quot;,\u0026quot;Group2\u0026quot;: 2 2 2 1 2 2 1 1 1 2 ... # .. .. .. .. .. ..$ levels : chr [1:2] \u0026quot;Group1\u0026quot; \u0026quot;Group2\u0026quot; # .. .. .. .. .. ..- attr(*, \u0026quot;class\u0026quot;)= chr \u0026quot;roc\u0026quot; # .. .. .. ..$ call : language roc.default(response = test_group, predictor = attr(predict_prob, \u0026quot;probabilities\u0026quot;)[, 1]) # .. .. .. ..$ original.predictor: Named num [1:200] 0.9991 0.9937 0.999 0.0112 0.9998 ... # .. .. .. .. ..- attr(*, \u0026quot;names\u0026quot;)= chr [1:200] \u0026quot;Cell7\u0026quot; \u0026quot;Cell8\u0026quot; \u0026quot;Cell26\u0026quot; \u0026quot;Cell29\u0026quot; ... # .. .. .. ..$ original.response : Factor w/ 2 levels \u0026quot;Group1\u0026quot;,\u0026quot;Group2\u0026quot;: 2 2 2 1 2 2 1 1 1 2 ... # .. .. .. ..$ predictor : Named num [1:200] 0.9991 0.9937 0.999 0.0112 0.9998 ... # .. .. .. .. ..- attr(*, \u0026quot;names\u0026quot;)= chr [1:200] \u0026quot;Cell7\u0026quot; \u0026quot;Cell8\u0026quot; \u0026quot;Cell26\u0026quot; \u0026quot;Cell29\u0026quot; ... # .. .. .. ..$ response : Factor w/ 2 levels \u0026quot;Group1\u0026quot;,\u0026quot;Group2\u0026quot;: 2 2 2 1 2 2 1 1 1 2 ... # .. .. .. ..$ levels : chr [1:2] \u0026quot;Group1\u0026quot; \u0026quot;Group2\u0026quot; # .. .. .. ..- attr(*, \u0026quot;class\u0026quot;)= chr \u0026quot;roc\u0026quot; # .. ..$ AUC : num 0.999 # .. ..$ Accuracy : num 0.99 # .. ..$ Precision : num 0.987 # .. ..$ Recall : num 0.987 # .. ..$ F1 : num 0.987 We determine three approaches to evaluate the validity of the simulated DEGs:\nnames(assess_DEGs$DEGs_evaluation$data) # [1] \u0026quot;distribution_score\u0026quot; \u0026quot;true_proportions\u0026quot; \u0026quot;SVM_result\u0026quot; distribution_score: We hypothesized that if there are no DEGs between two samples, the false positive rate of detected DEGs should be close to 0.05 and P values should follow a uniform distribution. We directly removed them from the gene expression matrix and then DEA was performed using edgeRQLFDetRate to obtain the P values. Next, we defined the null hypothesis that the P values follows a uniform distribution. The Pearson Chi-Squared test was then used to determine whether to reject the null hypothesis under the threshold (P‚â§0.05). If the null hypothesis is accepted for the dataset with only two cell groups, the distribution score is assigned to 1.\ntrue_proportions: We chosed the most optimal algorithm (edgeRQLFDetRate, edgeR QLF model including the cellular detection rate) that performed best in a previous benchmarking study to identify DEGs on the simulated data. All identified DEGs were considered as the ground truth. Then, the ratio of candidate DEGs (returned by the given simulation method) to the true DEGs was calculated. For three or more groups, it was weighted by the proportion of DEGs from pairwise groups to all of them.\nSVM_result: The third approach is to construct models using the simulated gene expression matrices with only DEGs. Accuracy, precision, recall, F1 score and area under ROC curve (AUC) were applied to assess the model performance. For multi-class classification, macro-averaged precision, recall and F1 score were computed.\nThe situation where more than two groups are simulated Splat, SCRIP, Lun and ESCO can return the DEGs from each pair of cell groups, but other methods (powsimR, muscat, scDesign, SPARSim, SPsimSeq, Lun2) only return the total DEGs of all pairs of groups when the number of simulated cell groups is higher than 2. In this special case, we can only assess their validity through the performance of the prediction models using the simulated DEGs.\nEvaluate the simulated cell batches Simulate the dataset with cell batches Firstly, we will simulate three batches:\nsimulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = c(200, 300, 500), nGenes = 2000), seed = 111 ) # nCells: 1000 # nGenes: 2000 # nGroups: 1 # de.prob: 0.1 # nBatches: 3 Then, check the batch information of cells:\ncell_metadata \u0026lt;- simulate_result$simulate_result$col_meta table(cell_metadata$batch) # # Batch1 Batch2 Batch3 # 200 300 500 Prepare the information of cell batches Some necessary parameters and information related to the cell batches are needed:\nbatch: The characters of batch names which cells belong to. k: k-nearest neighborhoods of cells. batch_labels \u0026lt;- cell_metadata$batch We can set k value as the square root of the cell number:\nk \u0026lt;- round(sqrt(length(batch_labels))) Assess the simulated cell batches assess_batches \u0026lt;- simpipe::data_functionality_summary( data = simulate_result$simulate_result$count_data, batch = batch_labels, k = k ) # The batch information is input... # ------------------------------------------------- # Evaluating cell batches # ------------------------------------------------- # Calculate cms, ILSI, Mixing Metric and Shannon entropy... # Calculate kBET... # Calculate Average Silouette Width for batch.. # Calculate principal component regression... List the assessment results of cell batches:\nstr(assess_batches$batch_evaluation) # List of 1 # $ data:List of 8 # ..$ cms : num [1:1000] 0 0.00321 0 0 0 ... # ..$ ISI : num [1:1000] 0.441 2.01 1.719 2.582 1.36 ... # ..$ LISI : num 1.59 # ..$ mm : num [1:1000] 32 16 23 15 28 27 15 16 12 12 ... # ..$ shannon_entropy: num [1:1000] 0.213 0.734 0.756 0.932 0.734 ... # ..$ kBET : num [1:1000] 1 1 1 1 1 1 1 1 1 1 ... # ..$ AWS_batch : num 0.0199 # ..$ pcr : num 0.0107 Eight metrics are used for assessing the quality of cell batches:\ncms: Cell-specific mixing score. CMS is an innovative measurement to determine whether the batch-wise distances in a KNN graph follow the same distribution using the Andersion-Darling test. Ideally, the method yields a lower CMS, indicating it can simulate more reliable data with different batches.\nISI: Inverse Simpson‚Äôs Index. ISI is an interpretable metric used to measure diversity within each neighborhood. A lower ISI score indicates the stronger batch effects. Otherwise, a higher ISI score suggests cells are well-mixed across different batches.\nLISI: Local Inverse Simpson‚Äôs Index.\nmm: Mixing metric. The mixing metric utilizes the median position of the k-th cell in the KNN graphs from each batch to determine the degree of batch effects. The lower value of this score, the better mixed the cells from different batches are.\nshannon_entropy: Shannon entropy quantifies the randomness and complexity of scRNA-seq datasets containing cells from different sources of batches.\nkBET: k-nearest neighbor batch effect test. kBET assesses the batch mixing by comparing the batch distribution within KNNs of a cell with the global one.\nAWS_batch: Average silhouette width for batch. ASW can also be used for batch evaluation, where the batch effect is more pronounced when the AWS closes to 1 or -1.\npcr: Principal component regression. The PCR score represents the total contribution of the batch variable to the variance of a dataset.\nEvaluate the simulated trajectories Simulate the dataset with cellular trajectory Firstly, we will simulate a trajectory dataset with five cell groups:\nsimulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nGenes = 1000, prob.group = rep(0.2, 5), paths = TRUE), seed = 111 ) # nCells: 160 # nGenes: 1000 # nGroups: 5 # de.prob: 0.1 # nBatches: 1 # Simulating trajectory datasets by Splat The cell numbers of the real and simulated data should be the same.\nAssess the simulated trajectory Before assessing the similarity of the reference and the simulated trajectory, we should prepare the reference data and simulated data (the information of cell groups in the real or simulated data is optionally input).\nref_data \u0026lt;- ref_data ref_data_grouping \u0026lt;- simmethods::group_condition sim_data \u0026lt;- simulate_result$simulate_result$count_data sim_data_grouping \u0026lt;- simulate_result$simulate_result$col_meta$group Calculate the metrics for quantifying the similarity of two trajectories (if the information of simulated cell groups is provided, the simulated groups are also evaluated):\nassess_traj \u0026lt;- simpipe::data_functionality_summary( data = sim_data, group = sim_data_grouping, ref_data = ref_data, ref_data_grouping = ref_data_grouping, algorithm = \u0026quot;Hungarian\u0026quot;, seed = 666 ) # The group information is input... # ------------------------------------------------- # Evaluating cell groups # ------------------------------------------------- # 1-Calculating CDI... # 2-Calculating ROUGE... # Warning in simutils::calculate_cluster_properties(data = group_data, dist = NULL, : The ROUGE calculation failed # 3-Calculating silhouette... # 4-Calculating dunn... # 5-Calculating connectivity... # 6-Calculating DB index... # ------------------------------------------------- # Evaluating trajectories # ------------------------------------------------- # The group information of reference data is input... # Performing trajectory inference by Slingshot for reference data... # Executing \u0026#39;slingshot\u0026#39; on \u0026#39;20230807_224814__data_wrapper__o90IhR6HPl\u0026#39; # With parameters: list(cluster_method = \u0026quot;pam\u0026quot;, ndim = 20L, shrink = 1L, reweight = TRUE, reassign = TRUE, thresh = 0.001, maxit = 10L, stretch = 2L, smoother = \u0026quot;smooth.spline\u0026quot;, shrink.method = \u0026quot;cosine\u0026quot;) # inputs: expression # priors : # Using full covariance matrix # Performing trajectory inference by Slingshot for simulated data... # Executing \u0026#39;slingshot\u0026#39; on \u0026#39;20230807_224814__data_wrapper__0KawbKxpqj\u0026#39; # With parameters: list(cluster_method = \u0026quot;pam\u0026quot;, ndim = 20L, shrink = 1L, reweight = TRUE, reassign = TRUE, thresh = 0.001, maxit = 10L, stretch = 2L, smoother = \u0026quot;smooth.spline\u0026quot;, shrink.method = \u0026quot;cosine\u0026quot;) # inputs: expression # priors : # Using full covariance matrix # Match cells in simulated and real data... # Performing PCA... # Performing Harmony... # Calculate correlation matrix... # # Match simulated and real cells using Hungarian... # reference simulation match_value # 1 SC_serum_45 Cell1 0.3906363 # 2 SC_serum_3 Cell2 0.2300600 # 3 SC_2i_12 Cell3 0.3109244 # 4 SC_2i_39 Cell4 0.2567587 # 5 SC_serum_64 Cell5 0.3596158 # 6 SC_serum_16 Cell6 0.3042017 # Calculating correlation of distances... # Waypoints of 9 # Waypoints of 17 # Waypoints of 25 # Waypoints of 33 # Waypoints of 41 # Waypoints of 49 # Waypoints of 57 # Waypoints of 65 # Waypoints of 73 # Waypoints of 80 # Change information in reference data... # Calculating HIM... # Warning: `data_frame()` was deprecated in tibble 1.1.0. # ‚Ñπ Please use `tibble()` instead. # ‚Ñπ The deprecated feature was likely used in the dyneval package. # Please report the issue to the authors. # This warning is displayed once every 8 hours. # Call `lifecycle::last_lifecycle_warnings()` to see where this warning was # generated. # Calculating F1 branches... # Calculating F1 milestones... # Done... Display the result:\ntraj_result \u0026lt;- assess_traj$trajectory_evaluation names(traj_result$data) # [1] \u0026quot;HIM\u0026quot; \u0026quot;F1_branches\u0026quot; \u0026quot;F1_milestones\u0026quot; \u0026quot;Cor_dist\u0026quot; str(traj_result$data) # List of 4 # $ HIM : num 0.509 # $ F1_branches : num 0.364 # $ F1_milestones: num 0.269 # $ Cor_dist :List of 2 # ..$ cor_dist :List of 2 # .. ..$ cor_dist : num 0.0167 # .. ..$ every_result: num [1:10] 0.0394 0.033 0.0339 0.0341 0.0199 ... # ..$ match_result:List of 5 # .. ..$ PCA_raw : num [1:320, 1:50] -13.74 -8.76 -46.39 -36.64 9.81 ... # .. .. ..- attr(*, \u0026quot;dimnames\u0026quot;)=List of 2 # .. .. .. ..$ : chr [1:320] \u0026quot;SC_2i_1\u0026quot; \u0026quot;SC_2i_2\u0026quot; \u0026quot;SC_2i_3\u0026quot; \u0026quot;SC_2i_4\u0026quot; ... # .. .. .. ..$ : chr [1:50] \u0026quot;PC1\u0026quot; \u0026quot;PC2\u0026quot; \u0026quot;PC3\u0026quot; \u0026quot;PC4\u0026quot; ... # .. ..$ cor_result : num [1:160, 1:160] -0.0854 0.1298 -0.1354 0.0151 0.231 ... # .. .. ..- attr(*, \u0026quot;dimnames\u0026quot;)=List of 2 # .. .. .. ..$ : chr [1:160] \u0026quot;Cell1\u0026quot; \u0026quot;Cell2\u0026quot; \u0026quot;Cell3\u0026quot; \u0026quot;Cell4\u0026quot; ... # .. .. .. ..$ : chr [1:160] \u0026quot;SC_2i_1\u0026quot; \u0026quot;SC_2i_2\u0026quot; \u0026quot;SC_2i_3\u0026quot; \u0026quot;SC_2i_4\u0026quot; ... # .. ..$ harmony_embeddings: num [1:320, 1:50] -18.22 -8.57 -52.81 -40.82 6.8 ... # .. .. ..- attr(*, \u0026quot;dimnames\u0026quot;)=List of 2 # .. .. .. ..$ : chr [1:320] \u0026quot;SC_2i_1\u0026quot; \u0026quot;SC_2i_2\u0026quot; \u0026quot;SC_2i_3\u0026quot; \u0026quot;SC_2i_4\u0026quot; ... # .. .. .. ..$ : chr [1:50] \u0026quot;PC1\u0026quot; \u0026quot;PC2\u0026quot; \u0026quot;PC3\u0026quot; \u0026quot;PC4\u0026quot; ... # .. ..$ cell_pair :\u0026#39;data.frame\u0026#39;: 160 obs. of 3 variables: # .. .. ..$ reference : chr [1:160] \u0026quot;SC_serum_45\u0026quot; \u0026quot;SC_serum_3\u0026quot; \u0026quot;SC_2i_12\u0026quot; \u0026quot;SC_2i_39\u0026quot; ... # .. .. ..$ simulation : chr [1:160] \u0026quot;Cell1\u0026quot; \u0026quot;Cell2\u0026quot; \u0026quot;Cell3\u0026quot; \u0026quot;Cell4\u0026quot; ... # .. .. ..$ match_value: num [1:160] 0.391 0.23 0.311 0.257 0.36 ... # .. ..$ cost : num -56.2 Four metrics are used in the assessment of two cellular trajectories:\nHIM: Hamming‚ÄìIpsen‚ÄìMikhailov. The HIM metric is a distance function quantifying the difference between two milestone networks, which linearly combines a local Hamming distance and a global Ipsen-Mikhailov distance.\nF1_branches: F1 score for branches. F1branches score is used to measure the accuracy of branch assignment to cells.\nF1_milestones: F1 score for milestones. F1milestones is for comparing the arrangements of cells belonging to different milestones.\nCor_dist: Correlation between geodesic distances. A cell located at the same position in the real and simulated trajectories should have equal relative distances to all other cells. Correlation between geodesic distance measures the correlation between the two relative distances of a cell from the real and simulated trajectory. To match the real and simulated cells within two trajectories, the Hungarian algorithm implemented in RcppHungarian R package was adopted.\nEvaluate the functionalities of a method "
},
{
	"uri": "/references/methods/4-splatpop/",
	"title": "SplatPop",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using SplatPop Datasets with default parameters Determin the number of cells and genes Simulate two or more groups Simulate two or more batches Simulate more groups and batches simutaniously Here SplatPop method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data dim(ref_data) # [1] 4000 160 Using simmethods::SplatPop_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::SplatPop_estimation(ref_data = ref_data, verbose = T, seed = 10) # Estimating parameters using SplatPop Simulating datasets using SplatPop After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Simulate two or more groups Simulate two or more batches Simulate more groups and batches simutaniously Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group and one batch of cells.\nsimulate_result \u0026lt;- simmethods::SplatPop_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 3 columns # cell_name batch group # \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; # Cell1 Cell1 Batch1 Group1 # Cell2 Cell2 Batch1 Group1 # Cell3 Cell3 Batch1 Group1 # Cell4 Cell4 Batch1 Group1 # Cell5 Cell5 Batch1 Group1 # Cell6 Cell6 Batch1 Group1 head(rowData(SCE_result)) # DataFrame with 6 rows and 1 column # gene_name # \u0026lt;character\u0026gt; # Gene1 Gene1 # Gene2 Gene2 # Gene3 Gene3 # Gene4 Gene4 # Gene5 Gene5 # Gene6 Gene6 Determin the number of cells and genes In SplatPop, we can not set nCells directly and should set batchCells instead. For example, if we want to simulate 500 cells, we can type other_prior = list(batchCells = 500). For genes, we can just set nGenes. Here, we simulate a new dataset with 500 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::SplatPop_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = 500, nGenes = 1000), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 Simulate two or more groups In SplatPop, we can not set nGroups directly and should set prob.group instead. For example, if we want to simulate 2 groups, we can type other_prior = list(prob.group = c(0.5, 0.5)). Note that the sum of prob.group numeric vector must equal to 1, so we can also set prob.group = c(0.3, 0.7).\nIn addtion, if we want to simulate three or more groups, we should obey the rules:\nThe length of prob.group vector must always equal to the number of groups. The sum of prob.group numeric vector must equal to 1. For demonstration, we will simulate three groups using the learned parameters.\nsimulate_result \u0026lt;- simmethods::SplatPop_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = 500, nGenes = 1000, prob.group = c(0.1, 0.3, 0.6)), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 3 # de.prob: 0.1 # nBatches: 1 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$group) # # Group1 Group2 Group3 # 50 150 300 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) ## de.prob = 0.1 # yes # 0.094 We can see that the proportion of differential expressed genes is 0.1 (equals to the default). Next, if we want to know the fold change between two groups, we will do division with the groups that we are interested in.\n## fc between group2 and group1 fc_group1_to_group2 \u0026lt;- gene_info$DEFacGroup2/gene_info$DEFacGroup1 ## fc between group3 and group1 fc_group1_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup1 ## fc between group3 and group2 fc_group2_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup2 Simulate two or more batches In SplatPop, we can not set nBatches directly and should set batchCells instead. For example, if we want to simulate 2 batches, we can type other_prior = list(batchCells = c(250, 250)). Note that the sum of batchCells numeric vector represents the total number of cells and the length of the vector equals to the number of batches.\nIn addtion, if we want to simulate three or more batches, we should obey the rules:\nThe length of batchCells vector always equals to the number of batches. The sum of batchCells numeric vector represents the total number of cells. For demonstration, we will simulate three batches using the learned parameters.\nsimulate_result \u0026lt;- simmethods::SplatPop_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = c(200, 300), nGenes = 1000), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 2 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$batch) # # Batch1 Batch2 # 201 299 Simulate more groups and batches simutaniously As mentioned before, we can set prob.group and batchCells to determine the number of groups and batches and we can also set de.prob to specify the proportion of DEGs. Here, we simulate a dataset with following settings:\n1000 cells 2000 genes three groups with 0.2 proportion of DEGs two batches simulate_result \u0026lt;- simmethods::SplatPop_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = c(500, 500), nGenes = 2000, de.prob = 0.2, prob.group = c(0.2, 0.3, 0.5)), seed = 111 ) # nCells: 1000 # nGenes: 2000 # nGroups: 3 # de.prob: 0.2 # nBatches: 2 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 2000 1000 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$batch) # # Batch1 Batch2 # 524 476 table(cell_info$group) # # Group1 Group2 Group3 # 209 299 492 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) # yes # 0.1725 ### fc fc_group2_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup2 "
},
{
	"uri": "/references/methods/5-lun/",
	"title": "Lun",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using Lun Datasets with default parameters Determin the number of cells and genes Simulate two or more groups Here Lun method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data dim(ref_data) # [1] 4000 160 Using simmethods::Lun_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::Lun_estimation(ref_data = ref_data, verbose = T, seed = 10) # Estimating parameters using Lun Simulating datasets using Lun After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Simulate two or more groups Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group of cells.\nsimulate_result \u0026lt;- simmethods::Lun_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 1 # de.prob: 0.25 # fc.up.group: 5 # fc.down.group: 0 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 2 columns # cell_name group # \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; # Cell1 Cell1 Group1 # Cell2 Cell2 Group1 # Cell3 Cell3 Group1 # Cell4 Cell4 Group1 # Cell5 Cell5 Group1 # Cell6 Cell6 Group1 head(rowData(SCE_result)) # DataFrame with 6 rows and 1 column # gene_name # \u0026lt;character\u0026gt; # Gene1 Gene1 # Gene2 Gene2 # Gene3 Gene3 # Gene4 Gene4 # Gene5 Gene5 # Gene6 Gene6 Determin the number of cells and genes In Lun, we can not set nCells directly and should set groupCells instead. For example, if we want to simulate 500 cells, we can type other_prior = list(groupCells = 500). For genes, we can just set nGenes. Here, we simulate a new dataset with 500 cells and 2000 genes:\nsimulate_result \u0026lt;- simmethods::Lun_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(groupCells = 500, nGenes = 2000), seed = 111 ) # nCells: 500 # nGenes: 2000 # nGroups: 1 # de.prob: 0.5 # fc.up.group: 5 # fc.down.group: 0 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 2000 500 Simulate two or more groups In Lun, we can not set nGroups directly and should set prob.group instead. For example, if we want to simulate 2 groups, we can type other_prior = list(prob.group = c(0.5, 0.5)). Note that the sum of prob.group numeric vector must equal to 1, so we can also set prob.group = c(0.3, 0.7).\nIn addtion, if we want to simulate three or more groups, we should obey the rules:\nThe length of prob.group vector must always equal to the number of groups. The sum of prob.group numeric vector must equal to 1. For demonstration, we will simulate three groups using the learned parameters. We can set de.prob = 0.2 to simulate 20% genes as DEGs.\nsimulate_result \u0026lt;- simmethods::Lun_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(groupCells = 1000, nGenes = 3000, prob.group = c(0.1, 0.3, 0.6), de.prob = 0.2), seed = 111 ) # nCells: 1000 # nGenes: 3000 # nGroups: 3 # de.prob: 0.2 # fc.up.group: 5 # fc.down.group: 0 If you encounter the error which is like Warning: NAs producedError in [[\u0026lt;-.data.frame (tmp, paste0(‚ÄúDEFacGroup‚Äù, idx), value = c(5, :**, please set a higher gene number and try again.\nresult \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 3000 1000 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$group) # # Group1 Group2 Group3 # 100 300 600 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) ## de.prob = 0.2 # yes # 0.2 We can see that the proportion of differential expressed genes is 0.2 (default is 1). Next, if we want to know the fold change between two groups, we will do division with the groups that we are interested in.\n## fc between group2 and group1 fc_group1_to_group2 \u0026lt;- gene_info$DEFacGroup2/gene_info$DEFacGroup1 ## fc between group3 and group1 fc_group1_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup1 ## fc between group3 and group2 fc_group2_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup2 In addtion, users can also specify the foldchange of up-regulated or down-regulated DEGs by fc.up.group or fc.down.group.\nsimulate_result \u0026lt;- simmethods::Lun_simulation(parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], other_prior = list(prob.group = c(0.4, 0.6), de.prob = 0.2, fc.up.group = 2, fc.down.group = 0.5), return_format = \u0026quot;list\u0026quot;, verbose = TRUE, seed = 111) # nCells: 160 # nGenes: 4000 # nGroups: 2 # de.prob: 0.2 # fc.up.group: 2 # fc.down.group: 0.5 # Simulating datasets using Lun # Getting parameters... # Simulating means... # Simulating cell means... # Simulating counts... # Creating final dataset... # Sparsifying assays... # Automatically converting to sparse matrices, threshold = 0.95 # Converting \u0026#39;counts\u0026#39; to sparse matrix: estimated sparse size 0.82 * dense matrix # Skipping \u0026#39;CellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Done! row_data \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### fc.up.group max(row_data$DEFacGroup1) # [1] 2 ### fc.down.group min(row_data$DEFacGroup1) # [1] 0.5 "
},
{
	"uri": "/references/methods/6-lun2/",
	"title": "Lun2",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using Lun2 Datasets with default parameters Determin the number of cells and genes Simulate two or more batches Here Lun2 method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nWhen you use Lun2 to estimate parameters from a real dataset, you must input a numeric vector to specify the batches or plates that each cell comes from, like other_prior = list(batch.condition = the numeric vector).\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data plates \u0026lt;- simmethods::group_condition ## plates can must be a numeric vector. other_prior \u0026lt;- list(batch.condition = as.numeric(plates)) Using simmethods::Lun2_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::Lun2_estimation(ref_data = ref_data, other_prior = other_prior, verbose = T, seed = 10) # Estimating parameters using Lun2 # Estimating number of groups... # Warning in regularize.values(x, y, ties, missing(ties), na.rm = na.rm): # collapsing to unique \u0026#39;x\u0026#39; values # Computing normalisation factors... # Warning in (function (x, sizes, min.mean = NULL, positive = FALSE, scaling = # NULL) : encountered non-positive size factor estimates # Estimating dispersions... # Estimating gene means... # Estimating plate effects... # Estimating zero-inflated parameters... # Warning in sqrt(diag(vc)[np]): NaNs produced # Warning in sqrt(diag(vc)[np]): NaNs produced # Warning in value[[3L]](cond): system is computationally singular: reciprocal # condition number = 9.2681e-48FALSE # Warning in sqrt(diag(vc)[np]): NaNs produced # Warning in sqrt(diag(vc)[np]): NaNs produced # Warning in sqrt(diag(vc)[np]): NaNs produced # Warning in sqrt(diag(vc)[np]): NaNs produced # Warning in sqrt(diag(vc)[np]): NaNs produced # Warning in sqrt(diag(vc)[np]): NaNs produced # Warning in value[[3L]](cond): system is computationally singular: reciprocal # condition number = 4.1192e-48FALSE Simulating datasets using Lun2 After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Simulate two or more batches Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one batch of cells.\nsimulate_result \u0026lt;- simmethods::Lun2_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 3973 # nPlates: 2 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 3973 160 head(colData(SCE_result)) # DataFrame with 6 rows and 2 columns # cell_name plate # \u0026lt;character\u0026gt; \u0026lt;factor\u0026gt; # Cell1 Cell1 1 # Cell2 Cell2 1 # Cell3 Cell3 1 # Cell4 Cell4 1 # Cell5 Cell5 1 # Cell6 Cell6 1 head(rowData(SCE_result)) # DataFrame with 6 rows and 1 column # gene_name # \u0026lt;character\u0026gt; # Gene1 Gene1 # Gene2 Gene2 # Gene3 Gene3 # Gene4 Gene4 # Gene5 Gene5 # Gene6 Gene6 Determin the number of cells and genes In Lun2, we can not set nCells directly and should set cell.plates instead. For example, if we want to simulate 500 cells, we can type other_prior = list(cell.plates = rep(1, 500)). For genes, we can just set nGenes. Here, we simulate a new dataset with 500 cells and 2000 genes:\nsimulate_result \u0026lt;- simmethods::Lun2_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(cell.plates = rep(1, 500), nGenes = 2000), seed = 111 ) # nCells: 500 # nGenes: 2000 # nPlates: 1 # Warning in splatter::lun2Simulate(parameters, verbose = verbose, zinb = zinb): # Number of lib.sizes not equal to nCells. lib.sizes will be sampled. # Warning in splatter::lun2Simulate(parameters, verbose = verbose, zinb = zinb): # Number of gene parameters does not equal nGenes. Gene parameters will be # sampled. The cell.plates parameter represents the sampling source of cells in real experiments.\nresult \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 2000 500 Simulate two or more batches In Lun2, we can not set nbatches directly and should set cell.plates instead. For example, if we want to simulate 2 batches, we can type other_prior = list(cell.plates = sample(1:2, 500, replace = TRUE)). Note that the length of cell.plates numeric vector must be equal to the cell number.\nFor demonstration, we will simulate three batches using the learned parameters.\nsimulate_result \u0026lt;- simmethods::Lun2_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(cell.plates = sample(1:2, 500, replace = TRUE), nGenes = 2000), seed = 111 ) # nCells: 500 # nGenes: 2000 # nPlates: 2 # Warning in splatter::lun2Simulate(parameters, verbose = verbose, zinb = zinb): # Number of lib.sizes not equal to nCells. lib.sizes will be sampled. # Warning in splatter::lun2Simulate(parameters, verbose = verbose, zinb = zinb): # Number of gene parameters does not equal nGenes. Gene parameters will be # sampled. result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 2000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$plate) # # 1 2 # 236 264 "
},
{
	"uri": "/references/methods/7-scrip/",
	"title": "SCRIP",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using SCRIP Datasets with default parameters Different modes in SCRIP Determin the number of cells and genes Simulate two or more groups Simulate two or more batches Simulate more groups and batches simutaniously Here SCRIP method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data dim(ref_data) # [1] 4000 160 Using simmethods::SCRIP_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::SCRIP_estimation(ref_data = ref_data, verbose = T, seed = 10) # Estimating parameters using SCRIP Simulating datasets using SCRIP After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Different modes in SCRIP Determin the number of cells and genes Simulate two or more groups Simulate two or more batches Simulate more groups and batches simutaniously Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group and one batch of cells.\nsimulate_result \u0026lt;- simmethods::SCRIP_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], ref_data = ref_data, return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 The reference data must be input when simulating new datasets.\nSCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 3 columns # cell_name batch group # \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; # Cell1 Cell1 Batch1 Group1 # Cell2 Cell2 Batch1 Group1 # Cell3 Cell3 Batch1 Group1 # Cell4 Cell4 Batch1 Group1 # Cell5 Cell5 Batch1 Group1 # Cell6 Cell6 Batch1 Group1 Time consuming:\nsimulate_result$simulate_detection$Elapsed_Time_sec # [1] 19.768 Different modes in SCRIP SCRIP contains five different simulation modes, and you can specify which mode do you use (default is GP-trendedBCV):\nGP-trendedBCV GP-commonBCV BGP-commonBCV BP BGP-trendedBCV simulate_result \u0026lt;- simmethods::SCRIP_simulation(parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], ref_data = ref_data, other_prior = list(mode = \u0026quot;BP\u0026quot;), return_format = \u0026quot;list\u0026quot;, verbose = TRUE, seed = 111) # nCells: 160 # nGenes: 4000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 # Simulating datasets using SCRIP simulate_result \u0026lt;- simmethods::SCRIP_simulation(parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], ref_data = ref_data, other_prior = list(mode = \u0026quot;BGP-commonBCV\u0026quot;), return_format = \u0026quot;list\u0026quot;, verbose = TRUE, seed = 111) # nCells: 160 # nGenes: 4000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 # Simulating datasets using SCRIP Determin the number of cells and genes In SCRIP, we can not set nCells directly and should set batchCells instead. For example, if we want to simulate 500 cells, we can type other_prior = list(batchCells = 500). For genes, we can just set nGenes. Here, we simulate a new dataset with 500 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::SCRIP_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], ref_data = ref_data, return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = 500, nGenes = 1000), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 Simulate two or more groups In SCRIP, we can not set nGroups directly and should set prob.group instead. For example, if we want to simulate 2 groups, we can type other_prior = list(prob.group = c(0.5, 0.5)). Note that the sum of prob.group numeric vector must equal to 1, so we can also set prob.group = c(0.3, 0.7).\nIn addtion, if we want to simulate three or more groups, we should obey the rules:\nThe length of prob.group vector must always equal to the number of groups. The sum of prob.group numeric vector must equal to 1. For demonstration, we will simulate three groups using the learned parameters.\nsimulate_result \u0026lt;- simmethods::SCRIP_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], ref_data = ref_data, return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = 500, nGenes = 1000, prob.group = c(0.1, 0.3, 0.6)), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 3 # de.prob: 0.1 # nBatches: 1 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$group) # # Group1 Group2 Group3 # 46 156 298 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) ## de.prob = 0.1 # yes # 0.1 We can see that the proportion of differential expressed genes is 0.1 (equals to the default). Next, if we want to know the fold change between two groups, we will do division with the groups that we are interested in.\n## fc between group2 and group1 fc_group1_to_group2 \u0026lt;- gene_info$DEFacGroup2/gene_info$DEFacGroup1 ## fc between group3 and group1 fc_group1_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup1 ## fc between group3 and group2 fc_group2_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup2 Simulate two or more batches In SCRIP, we can not set nBatches directly and should set batchCells instead. For example, if we want to simulate 2 batches, we can type other_prior = list(batchCells = c(250, 250)). Note that the sum of batchCells numeric vector represents the total number of cells and the length of the vector equals to the number of batches.\nIn addtion, if we want to simulate three or more batches, we should obey the rules:\nThe length of batchCells vector always equals to the number of batches. The sum of batchCells numeric vector represents the total number of cells. For demonstration, we will simulate three batches using the learned parameters.\nsimulate_result \u0026lt;- simmethods::SCRIP_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], ref_data = ref_data, return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = c(200, 300), nGenes = 1000), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 2 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$batch) # # Batch1 Batch2 # 200 300 Simulate more groups and batches simutaniously As mentioned before, we can set prob.group and batchCells to determine the number of groups and batches and we can also set de.prob to specify the proportion of DEGs. Here, we simulate a dataset with following settings:\n1000 cells 2000 genes three groups with 0.2 proportion of DEGs two batches simulate_result \u0026lt;- simmethods::SCRIP_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], ref_data = ref_data, return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = c(500, 500), nGenes = 2000, de.prob = 0.2, prob.group = c(0.2, 0.3, 0.5)), seed = 111 ) # nCells: 1000 # nGenes: 2000 # nGroups: 3 # de.prob: 0.2 # nBatches: 2 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 2000 1000 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$batch) # # Batch1 Batch2 # 500 500 table(cell_info$group) # # Group1 Group2 Group3 # 186 321 493 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) # yes # 0.1685 "
},
{
	"uri": "/references/methods/8-powsimr/",
	"title": "powsimR",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Estimate parameters without ERCC spike-in Estimate parameters with ERCC spike-in Simulating datasets using powsimR Datasets with default parameters Determin the number of cells and genes Simulate two or more groups Simulate two or more batches Simulate more groups and batches simutaniously Here powsimR method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data powsimR provides some choices for users to select suitable parameters according to different types of data, platforms, normalization methods, distributions and so on.\nRNAseq ‚Äúbulk‚Äù or ‚Äúsinglecell‚Äù (default). Protocol Options are ‚ÄúUMI‚Äù (default) (e.g.¬†10X Genomics, CEL-seq2) or ‚ÄúRead‚Äù (e.g.¬†Smart-seq2). Distribution ‚ÄúNB‚Äù (default) for negative binomial or ‚ÄúZINB‚Äù for zero-inflated negative binomial distribution fitting. Normalisation ‚ÄúTMM‚Äù (default), ‚ÄúMR‚Äù, ‚ÄúPosCounts‚Äù, ‚ÄúUQ‚Äù, ‚Äúscran‚Äù, ‚ÄúLinnorm‚Äù, ‚ÄúSCnorm‚Äù, ‚ÄúCensus‚Äù, ‚Äúdepth‚Äù, ‚Äúnone‚Äù. Estimate parameters without ERCC spike-in estimate_result \u0026lt;- powsimR_estimation( ref_data = ref_data, other_prior = list(RNAseq = \u0026quot;singlecell\u0026quot;, Protocol = \u0026quot;UMI\u0026quot;, Normalisation = \u0026quot;scran\u0026quot;), verbose = TRUE, seed = 111) # Warning: replacing previous import \u0026#39;DECENT::lrTest\u0026#39; by \u0026#39;MAST::lrTest\u0026#39; when # loading \u0026#39;powsimR\u0026#39; # Warning: replacing previous import \u0026#39;penalized::predict\u0026#39; by \u0026#39;stats::predict\u0026#39; when # loading \u0026#39;powsimR\u0026#39; # Warning: replacing previous import \u0026#39;zinbwave::glmWeightedF\u0026#39; by # \u0026#39;zingeR::glmWeightedF\u0026#39; when loading \u0026#39;powsimR\u0026#39; # Estimating parameters using estimateParam function Estimate parameters with ERCC spike-in powsimR also provides an another choice to estimate parameters (not neccessary) via spike-ins. If users want to use this, make sure that the reference data must contain ERCC spike-in counts. In addtion, users must set dilution.factor and volume information by other_prior = list(dilution.factor = xxx, volume = xxx).\nrownames(ref_data)[grep(pattern = \u0026quot;^ERCC\u0026quot;, x = rownames(ref_data))] # [1] \u0026quot;ERCC-00002\u0026quot; \u0026quot;ERCC-00003\u0026quot; \u0026quot;ERCC-00004\u0026quot; \u0026quot;ERCC-00009\u0026quot; \u0026quot;ERCC-00014\u0026quot; # [6] \u0026quot;ERCC-00019\u0026quot; \u0026quot;ERCC-00022\u0026quot; \u0026quot;ERCC-00025\u0026quot; \u0026quot;ERCC-00034\u0026quot; \u0026quot;ERCC-00035\u0026quot; # [11] \u0026quot;ERCC-00042\u0026quot; \u0026quot;ERCC-00043\u0026quot; \u0026quot;ERCC-00044\u0026quot; \u0026quot;ERCC-00046\u0026quot; \u0026quot;ERCC-00051\u0026quot; # [16] \u0026quot;ERCC-00053\u0026quot; \u0026quot;ERCC-00054\u0026quot; \u0026quot;ERCC-00059\u0026quot; \u0026quot;ERCC-00060\u0026quot; \u0026quot;ERCC-00062\u0026quot; # [21] \u0026quot;ERCC-00069\u0026quot; \u0026quot;ERCC-00071\u0026quot; \u0026quot;ERCC-00074\u0026quot; \u0026quot;ERCC-00076\u0026quot; \u0026quot;ERCC-00078\u0026quot; # [26] \u0026quot;ERCC-00079\u0026quot; \u0026quot;ERCC-00084\u0026quot; \u0026quot;ERCC-00092\u0026quot; \u0026quot;ERCC-00095\u0026quot; \u0026quot;ERCC-00096\u0026quot; # [31] \u0026quot;ERCC-00099\u0026quot; \u0026quot;ERCC-00108\u0026quot; \u0026quot;ERCC-00111\u0026quot; \u0026quot;ERCC-00112\u0026quot; \u0026quot;ERCC-00113\u0026quot; # [36] \u0026quot;ERCC-00116\u0026quot; \u0026quot;ERCC-00130\u0026quot; \u0026quot;ERCC-00131\u0026quot; \u0026quot;ERCC-00136\u0026quot; \u0026quot;ERCC-00144\u0026quot; # [41] \u0026quot;ERCC-00145\u0026quot; \u0026quot;ERCC-00148\u0026quot; \u0026quot;ERCC-00154\u0026quot; \u0026quot;ERCC-00157\u0026quot; \u0026quot;ERCC-00160\u0026quot; # [46] \u0026quot;ERCC-00162\u0026quot; \u0026quot;ERCC-00163\u0026quot; \u0026quot;ERCC-00165\u0026quot; \u0026quot;ERCC-00170\u0026quot; \u0026quot;ERCC-00171\u0026quot; Make sure there are ERCC names in reference data and users must input the dilution.factor and volume (microliter) to determine the concentration of ERCC molecules.\nestimate_result \u0026lt;- powsimR_estimation( ref_data = ref_data, other_prior = list(RNAseq = \u0026quot;singlecell\u0026quot;, Protocol = \u0026quot;UMI\u0026quot;, Normalisation = \u0026quot;scran\u0026quot;, dilution.factor = 50000, volume = 1), verbose = TRUE, seed = 111) # Estimating parameters using estimateParam function Simulating datasets using powsimR After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Simulate two or more groups Simulate two or more batches Simulate more groups and batches simutaniously powsimR provides some choices for users to select suitable parameters according to different normalization methods, and methods for differential expressed analysis.\nNormalisation ‚ÄúTMM‚Äù (default), ‚ÄúMR‚Äù, ‚ÄúPosCounts‚Äù, ‚ÄúUQ‚Äù, ‚Äúscran‚Äù, ‚ÄúLinnorm‚Äù, ‚Äúsctransform‚Äù, ‚ÄúSCnorm‚Äù, ‚ÄúCensus‚Äù, ‚Äúdepth‚Äù. DEmethod ‚ÄúT-Test‚Äù, ‚ÄúedgeR-LRT‚Äù, ‚ÄúedgeR-QL‚Äù, ‚ÄúedgeR-zingeR‚Äù, ‚ÄúedgeR-ZINB-WaVE‚Äù, ‚Äúlimma-voom‚Äù, ‚Äúlimma-trend‚Äù (default), ‚ÄúDESeq2‚Äù, ‚ÄúDESeq2-zingeR‚Äù, ‚ÄúDESeq2-ZINB-WaVE‚Äù, ‚ÄúROTS‚Äù, ‚ÄúbaySeq‚Äù, ‚ÄúNOISeq‚Äù, ‚ÄúEBSeq‚Äù, ‚ÄúMAST‚Äù, ‚ÄúBPSC‚Äù, ‚ÄúscDD‚Äù, ‚ÄúDECENT‚Äù. Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group and one batch of cells.\nsimulate_result \u0026lt;- simmethods::powsimR_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, verbose = TRUE, seed = 111) # nCells: 160 # nGenes: 4000 # nGroups: 2 # de.prob: 0.1 # fc.group: 2 # nBatches: 1 # # Setup Seed: 111 # You have chosen to simulate the expression of 4000 genes, which will be randomly drawn with replacement from the observed expression of 4000 genes. # Simulating datasets using powsimR # limma-trend is developed for bulk RNA-seq experiments. # Preparing output arrays. # # SIMULATION NUMBER 1 # Generating gene expression. # Generating spike-in expression. # 80 vs. 80 # Applying TMM normalisation # Applying limma-trend for DE analysis on raw count data. # Saving raw simulated counts. # Estimating moments of raw count data. SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 2 columns # cell_name group # \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; # Cell1 Cell1 Group1 # Cell2 Cell2 Group1 # Cell3 Cell3 Group1 # Cell4 Cell4 Group1 # Cell5 Cell5 Group1 # Cell6 Cell6 Group1 Time consuming:\nsimulate_result$simulate_detection$Elapsed_Time_sec # [1] 0.982 Determin the number of cells and genes Here, we simulate a new dataset with 500 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::powsimR_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], other_prior = list(nCells = 500, nGenes = 1000), return_format = \u0026quot;list\u0026quot;, verbose = TRUE, seed = 111) # nCells: 500 # nGenes: 1000 # nGroups: 2 # de.prob: 0.1 # fc.group: 2 # nBatches: 1 # # Setup Seed: 111 # You have chosen to simulate the expression of 1000 genes, which will be randomly drawn without replacement from the observed expression of 4000 genes. # Simulating datasets using powsimR # limma-trend is developed for bulk RNA-seq experiments. # Preparing output arrays. # # SIMULATION NUMBER 1 # Generating gene expression. # Generating spike-in expression. # 250 vs. 250 # Applying TMM normalisation # Applying limma-trend for DE analysis on raw count data. # Saving raw simulated counts. # Estimating moments of raw count data. result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 Simulate two or more groups In powsimR, we can not set nGroups directly and should set prob.group instead. For example, if we want to simulate 2 groups, we can type other_prior = list(prob.group = c(0.5, 0.5)). Note that the sum of prob.group numeric vector must equal to 1, so we can also set prob.group = c(0.3, 0.7).\nIn addtion, if we want to simulate three or more groups, we should obey the rules:\nThe length of prob.group vector must always be 2 when using powsinR. The sum of prob.group numeric vector must equal to 1. For demonstration, we will simulate two groups using the learned parameters. (20% DEGs and 4 fold change)\nsimulate_result \u0026lt;- simmethods::powsimR_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 500, nGenes = 1000, prob.group = c(0.3, 0.7), de.prob = 0.2, fc.group = 4), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 2 # de.prob: 0.2 # fc.group: 4 # nBatches: 1 # # You have chosen to simulate the expression of 1000 genes, which will be randomly drawn without replacement from the observed expression of 4000 genes. result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$group) # # Group1 Group2 # 150 350 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) ## de.prob = 0.2 # yes # 0.2 Simulate two or more batches In powsimR, we can not set nBatches directly and should set prob.batch instead. For example, if we want to simulate 2 batches, we can type other_prior = list(prob.batch = c(0.5, 0.5)). Note that the sum of prob.batch numeric vector represents the total number of cells and the length of the vector equals to the number of batches.\nIn addtion, if we want to simulate three or more batches, we should obey the rules:\nThe length of prob.batch vector must always equal to the number of batches The sum of prob.batch numeric vector must equal to 1. For demonstration, we will simulate two batches using the learned parameters. (2 fold change)\nsimulate_result \u0026lt;- simmethods::powsimR_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], other_prior = list(prob.batch = c(0.4, 0.6), fc.batch = 2), return_format = \u0026quot;list\u0026quot;, verbose = TRUE, seed = 111) # nCells: 160 # nGenes: 4000 # nGroups: 2 # de.prob: 0.1 # fc.group: 2 # nBatches: 2 # fc.batch: 2 # Setup Seed: 111 # You have chosen to simulate the expression of 4000 genes, which will be randomly drawn with replacement from the observed expression of 4000 genes. # Simulating datasets using powsimR # limma-trend is developed for bulk RNA-seq experiments. # Preparing output arrays. # # SIMULATION NUMBER 1 # Generating gene expression. # Generating spike-in expression. # 32 vs. 32 # Applying TMM normalisation # Applying limma-trend for DE analysis on raw count data. # Saving raw simulated counts. # Estimating moments of raw count data. # 48 vs. 48 # Applying TMM normalisation # Applying limma-trend for DE analysis on raw count data. # Saving raw simulated counts. # Estimating moments of raw count data. result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 4000 160 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$batch) # # Batch1 Batch2 # 64 96 Simulate more groups and batches simutaniously As mentioned before, we can set prob.group and prob.batch to determine the number of groups and batches and we can also set de.prob to specify the proportion of DEGs. Here, we simulate a dataset with following settings:\n1000 cells 2000 genes two groups with 0.2 proportion of DEGs two batches simulate_result \u0026lt;- simmethods::powsimR_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 1000, nGenes = 2000, de.prob = 0.2, prob.group = c(0.4, 0.6), prob.batch = c(0.5, 0.5)), seed = 111 ) # nCells: 1000 # nGenes: 2000 # nGroups: 2 # de.prob: 0.2 # fc.group: 2 # nBatches: 2 # fc.batch: 2 # You have chosen to simulate the expression of 2000 genes, which will be randomly drawn without replacement from the observed expression of 4000 genes. result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 2000 1000 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$batch) # # Batch1 Batch2 # 500 500 table(cell_info$group) # # Group1 Group2 # 400 600 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) # yes # 0.2 "
},
{
	"uri": "/references/methods/9-powsc/",
	"title": "POWSC",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using POWSC Datasets with default parameters Determin the number of cells Simulate two groups Here POWSC method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data generated by scater::mockSCE command.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- counts(scater::mockSCE()) dim(ref_data) # [1] 2000 200 Using simmethods::POWSC_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::POWSC_estimation(ref_data = ref_data, verbose = T, seed = 10) # Estimating parameters using POWSC Simulating datasets using POWSC After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells Simulate two groups Datasets with default parameters The reference data contains 200 cells and 2000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group of cells.\nsimulate_result \u0026lt;- simmethods::POWSC_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 200 # nGenes: 2000 # nGroups: 2 # de.prob: 0.1 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 2000 200 head(colData(SCE_result)) # DataFrame with 6 rows and 2 columns # cell_name group # \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; # Cell1 Cell1 Group1 # Cell2 Cell2 Group1 # Cell3 Cell3 Group1 # Cell4 Cell4 Group1 # Cell5 Cell5 Group1 # Cell6 Cell6 Group1 head(rowData(SCE_result)) # DataFrame with 6 rows and 2 columns # gene_name de_gene # \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; # Gene1 Gene1 no # Gene2 Gene2 no # Gene3 Gene3 yes # Gene4 Gene4 no # Gene5 Gene5 yes # Gene6 Gene6 no Determin the number of cells In POWSC, we can set nCells directly. For example, if we want to simulate 500 cells, we can type other_prior = list(nCells = 500). Here, we simulate a new dataset with 500 cells:\nsimulate_result \u0026lt;- simmethods::POWSC_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 500), seed = 111 ) # nCells: 500 # nGenes: 2000 # nGroups: 2 # de.prob: 0.1 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 2000 500 Simulate two groups POWSC will automatically simulate two cell groups by default. Users can set de.prob to specify the proportion of DEGs between two groups.\nsimulate_result \u0026lt;- simmethods::POWSC_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 500, de.prob = 0.2), seed = 111 ) # nCells: 500 # nGenes: 2000 # nGroups: 2 # de.prob: 0.2 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 2000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$group) # # Group1 Group2 # 250 250 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) ## de.prob = 0.2 # yes # 0.1895 "
},
{
	"uri": "/references/methods/10-scdd/",
	"title": "scDD",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using scDD Datasets with default parameters Determin the number of cells Here scDD method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nWhen you use scDD to estimate parameters from a real dataset, you must input a numeric vector to specify the groups or plates that each cell comes from, like other_prior = list(group.condition = the numeric vector).\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- SingleCellExperiment::counts(scater::mockSCE()) set.seed(111) group_condition \u0026lt;- sample(c(1, 2), 200, replace = TRUE) ## group_condition can must be a numeric vector. other_prior \u0026lt;- list(group.condition = as.numeric(group_condition)) Using simmethods::scDD_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::scDD_estimation(ref_data = ref_data, other_prior = other_prior, verbose = T, seed = 10) # Estimating parameters using scDD # Performing Median Normalization # Setting up parallel back-end using 1 cores # Clustering observed expression data for each gene # Notice: Number of permutations is set to zero; using # Kolmogorov-Smirnov to test for differences in distributions # instead of the Bayes Factor permutation test # Classifying significant genes into patterns Time consuming:\nestimate_result$estimate_detection$Elapsed_Time_sec # [1] 130.466 Simulating datasets using scDD After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells Datasets with default parameters The reference data contains 200 cells and 2000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nThe simulated dataset will always have two group of cells using scDD.\nsimulate_result \u0026lt;- simmethods::scDD_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 2000 200 table(colData(SCE_result)$group) # # Group1 Group2 # 100 100 Determin the number of cells In scDD, users can only set nCells to specify the number of cells because the genes are already fixed after estimation step.\nsimulate_result \u0026lt;- simmethods::scDD_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 1000), seed = 111 ) result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 2000 1000 col_data \u0026lt;- simulate_result$simulate_result$col_meta table(col_data$group) # # Group1 Group2 # 500 500 "
},
{
	"uri": "/references/methods/11-scdesign/",
	"title": "scDesign",
	"tags": [],
	"description": "",
	"content": " Simulating datasets using scDesign Datasets with default parameters Determin the number of cells Simulate two or more groups Here scDesign method will be demonstrated clearly and hope that this document can help you.\nSimulating datasets using scDesign There is no estimation step when using scDesign, so we can directly simulate new datasets through reference data.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data We will simulate a dataset based on refernece data with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Simulate two or more groups Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group of cells.\nsimulate_result \u0026lt;- simmethods::scDesign_simulation( ref_data = ref_data, return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 1 # de.prob: 0.1 # fc.group: up--5 # fc.group: down--1.5 # [1] \u0026quot;estimate expression parameters\u0026quot; SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 1 column # cell_name # \u0026lt;character\u0026gt; # Cell1 Cell1 # Cell2 Cell2 # Cell3 Cell3 # Cell4 Cell4 # Cell5 Cell5 # Cell6 Cell6 Determin the number of cells We can only set the cell number in scDesign.\nHere, we simulate a new dataset with 500 cells:\nsimulate_result \u0026lt;- simmethods::scDesign_simulation( ref_data = ref_data, return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 500), seed = 111 ) # nCells: 500 # nGenes: 4000 # nGroups: 1 # de.prob: 0.1 # fc.group: up--5 # fc.group: down--1.5 # [1] \u0026quot;estimate expression parameters\u0026quot; result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 4000 500 Simulate two or more groups In scDesign, we can et nGroups directly, together with the proportions of different cell groups by prob.group. Moreover, the proportion of DEGs via de.prob and fold change via fc.group can be customed.\nFor demonstration, we will simulate three groups.\nsimulate_result \u0026lt;- simmethods::scDesign_simulation( ref_data = ref_data, return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 500, nGroups = 3, prob.group = c(0.1, 0.3, 0.6), de.prob = 0.2, fc.group = 4), seed = 111 ) # nCells: 500 # nGenes: 4000 # nGroups: 3 # de.prob: 0.2 # fc.group: up--4 # fc.group: down--4 # [1] \u0026quot;estimate expression parameters\u0026quot; result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 4000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$group) # # Group1 Group2 Group3 # 50 150 300 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) ## de.prob = 0.2 # yes # 0.2 "
},
{
	"uri": "/references/methods/12-scdesign2/",
	"title": "scDesign2",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Default estimation Information of cell groups Information of cell types Simulating datasets using scDesign2 Datasets with default parameters Determin the number of cells Simulate two or more groups Here scDesign2 method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data Default estimation estimate_result \u0026lt;- simmethods::scDesign2_estimation( ref_data = ref_data, verbose = TRUE, seed = 111 ) # Estimating parameters using scDesign2 Information of cell groups If the information of cell groups is available, you can use another way to estimate the parameters.\n## cell groups group_condition \u0026lt;- as.numeric(simmethods::group_condition) estimate_result \u0026lt;- simmethods::scDesign2_estimation( ref_data = ref_data, other_prior = list(group.condition = group_condition), verbose = TRUE, seed = 111 ) # Estimating parameters using scDesign2 Information of cell types You can input information of cell types via cell_type_sel parameter described in scDesign2::fit_model_scDesign2 function\nestimate_result \u0026lt;- simmethods::scDesign2_estimation( ref_data = ref_data, other_prior = list(cell_type_sel = paste0(\u0026quot;cell_type\u0026quot;, group_condition)), verbose = TRUE, seed = 111 ) # Estimating parameters using scDesign2 Simulating datasets using scDesign2 After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells Simulate two or more groups Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::scDesign2_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 2 We will get two or groups if information of cell groups or cell type is used in estimation step.\nSCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 table(colData(SCE_result)$group) # # Group1 Group2 # 80 80 Determin the number of cells We can only set the cell number in scDesign2.\nHere, we simulate a new dataset with 500 cells:\nsimulate_result \u0026lt;- simmethods::scDesign2_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 500), seed = 111 ) # nCells: 500 # nGenes: 4000 # nGroups: 2 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 4000 500 Simulate two or more groups In scDesign2, we can not set nGroups directly and should set prob.group instead. For example, if we want to simulate 2 groups, we can type other_prior = list(prob.group = c(0.5, 0.5)). Note that the sum of prob.group numeric vector must equal to 1, so we can also set prob.group = c(0.3, 0.7).\nIn addtion, if we want to simulate three or more groups, we should obey the rules:\nThe length of prob.group vector must always equal to the number of cell groups or cell types used in estimation step. The sum of prob.group numeric vector must equal to 1. For demonstration, we can only simulate two groups using the learned parameters.\nsimulate_result \u0026lt;- simmethods::scDesign2_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 500, prob.group = c(0.4, 0.6)), seed = 111 ) # nCells: 500 # nGenes: 4000 # nGroups: 2 If you did not input information of cell groups or cell types in the estimation step, you can not simulate groups.\nresult \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 4000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$group) # # Group1 Group2 # 200 300 "
},
{
	"uri": "/references/methods/13-scdesign3/",
	"title": "scDesign3",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Default estimation Information of cell groups Simulating datasets using scDesign3 Datasets with default parameters Simulate two or more groups Simulate two or more batches Simulate datasets with cellular differentiation trajectory Simulate spatial transcriptome data Here scDesign3 method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data Default estimation estimate_result \u0026lt;- simmethods::scDesign3_estimation( ref_data = ref_data, verbose = TRUE, seed = 111 ) # Estimating parameters using scDesign3 # Convert Residuals to Multivariate Gaussian # Converting End # Copula group A starts Information of cell groups If the information of cell groups is available, you can use another way to estimate the parameters.\n## cell groups group_condition \u0026lt;- as.numeric(simmethods::group_condition) estimate_result \u0026lt;- simmethods::scDesign3_estimation( ref_data = ref_data, other_prior = list(group.condition = group_condition), verbose = TRUE, seed = 111 ) # Estimating parameters using scDesign3 # Convert Residuals to Multivariate Gaussian # Converting End # Copula group Group1 starts # Copula group Group2 starts Simulating datasets using scDesign3 After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Simulate two or more groups Simulate two or more batches Simulate data with cellular differentiation trajectory Simulate spatial transcriptome data Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::scDesign3_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 2 # nBatches: 1 # Use Copula to sample a multivariate quantile matrix # Sample Copula group Group1 starts # Sample Copula group Group2 starts We will get two or groups if information of cell groups is used in estimation step.\nSCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 table(colData(SCE_result)$group) # # Group1 Group2 # 80 80 We can not set the cell or gene number in scDesign3 unless a data frame which contains covariates of targeted simulated data from construct_data function is provided through new_covariate parameter.\nSimulate two or more groups In scDesign3, we can not set nGroups directly and should specify the group labels of cells in the estimation step in scDesign3_estimation function.\nWe randomly assign four group labels to cells.\nset.seed(666) estimate_result \u0026lt;- simmethods::scDesign3_estimation( ref_data = ref_data, other_prior = list(group.condition = sample(1:4, ncol(ref_data), replace = TRUE)), verbose = TRUE, seed = 111 ) # Estimating parameters using scDesign3 # Convert Residuals to Multivariate Gaussian # Converting End # Copula group Group2 starts # Copula group Group4 starts # Copula group Group3 starts # Copula group Group1 starts simulate_result \u0026lt;- simmethods::scDesign3_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 4 # nBatches: 1 # Use Copula to sample a multivariate quantile matrix # Sample Copula group Group2 starts # Sample Copula group Group4 starts # Sample Copula group Group3 starts # Sample Copula group Group1 starts Check cell groups\nSCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] table(colData(SCE_result)$group) # # Group1 Group2 Group3 Group4 # 29 43 43 45 Simulate two or more batches In scDesign3, we can not set nBatches directly and should the batch labels of cells in the estimation step in scDesign3_estimation function.\nIf you custom the simulated cell number which is not equal to that of the real data, the batch information for simulated cells is not returned.\nSimulate datasets with cellular differentiation trajectory Before modeling from the reference data, we should construct dynwrap::expression data using dynwrap::wrap_expression function and perform trajectory inference using Slingshot using tislingshot::ti_slingshot or other methods.\nif(!requireNamespace(\u0026quot;tislingshot\u0026quot;, quietly = TRUE)){ devtools::install_github(\u0026quot;dynverse/ti_slingshot/package/\u0026quot;) } dyn_data \u0026lt;- dynwrap::wrap_expression( counts = t(ref_data), expression = log2(t(ref_data) + 1) ) dyn_data \u0026lt;- dynwrap::add_grouping(dyn_data, group_condition) dyn_model \u0026lt;- dynwrap::infer_trajectory(dyn_data, tislingshot::ti_slingshot()) # Using full covariance matrix The traj parameter must be TURE and dynwrap_data is needed when you want to estimate parameters from trajectory data.\nestimate_result \u0026lt;- simmethods::scDesign3_estimation( ref_data = ref_data, other_prior = list(traj = TRUE, group.condition = group_condition, dynwrap_data = dyn_model), verbose = TRUE, seed = 111 ) # Constructing lineages for the data... # Estimating parameters using scDesign3 # Convert Residuals to Multivariate Gaussian # Converting End # Copula group Group1 starts # Copula group Group2 starts Next, we can simulate trajectory data using scDesign3.\nsimulate_result \u0026lt;- simmethods::scDesign3_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 2 # nBatches: 1 # Use Copula to sample a multivariate quantile matrix # Sample Copula group Group1 starts # Sample Copula group Group2 starts Before visualization, make sure that you have already installed several R packages:\nif(!requireNamespace(\u0026quot;dyndimred\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dyndimred\u0026quot;)} if(!requireNamespace(\u0026quot;dynplot\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynplot\u0026quot;)} First we should wrap the data into a standard object:\ndyn_object \u0026lt;- dynwrap::wrap_expression(counts = t(simulate_result$simulate_result$count_data), expression = log2(t(simulate_result$simulate_result$count_data) + 1)) Next, we infer the trajectory using SlingShot which has been proved to be the most best method to do this:\nmodel \u0026lt;- dynwrap::infer_trajectory(dataset = dyn_object, method = tislingshot::ti_slingshot(), parameters = NULL, give_priors = NULL, seed = 666, verbose = TRUE) # Executing \u0026#39;slingshot\u0026#39; on \u0026#39;20230911_114342__data_wrapper__3AFJQcaDVH\u0026#39; # With parameters: list(cluster_method = \u0026quot;pam\u0026quot;, ndim = 20L, shrink = 1L, reweight = TRUE, reassign = TRUE, thresh = 0.001, maxit = 10L, stretch = 2L, smoother = \u0026quot;smooth.spline\u0026quot;, shrink.method = \u0026quot;cosine\u0026quot;) # inputs: expression # priors : # Using full covariance matrix Finally, we can plot the trajectory after performing dimensionality reduction:\ndimred \u0026lt;- dyndimred::dimred_umap(dyn_object$expression) dynplot::plot_dimred(model, dimred = dimred) # Coloring by milestone # Using milestone_percentages from trajectory For more details about trajectory inference and visualization, please check dynverse.\nSimulate spatial transcriptome data scDesign3 can also simulate spatial transcriptome data. Besides the gene expression profile, users should also provide the spatial coordinates of each cell (spot). The reference data can be downloaded here.\n# Load data (downloaded from https://zenodo.org/record/8251596/files/data118_spatial_OV.rds?download=1) data \u0026lt;- readRDS(\u0026quot;../../../../preprocessed_data/data118_spatial_OV.rds\u0026quot;) ref_data \u0026lt;- t(as.matrix(data$data$counts)) In addition, we can set the spatial coordinates by spatial.x and spatial.y parameters.\nother_prior \u0026lt;- list(spatial.x = data$data_info$spatial_coordinate$x, spatial.y = data$data_info$spatial_coordinate$y, group.condition = as.numeric(as.factor(data$data_info$cluster_info))) Execute the parameter estimation:\nestimate_result \u0026lt;- simmethods::scDesign3_estimation( ref_data = ref_data, other_prior = other_prior, verbose = T, seed = 10 ) # Estimating parameters using scDesign3 # Convert Residuals to Multivariate Gaussian # Converting End # Copula group Group2 starts # Copula group Group1 starts Simulate spatial transcriptome data:\nsimulate_result \u0026lt;- simmethods::scDesign3_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, seed = 111 ) # nCells: 3492 # nGenes: 1056 # nGroups: 2 # nBatches: 1 # Use Copula to sample a multivariate quantile matrix # Sample Copula group Group2 starts # Sample Copula group Group1 starts Notably, the simulated cells can match the real ones, so that the spatial coordinates are the same as the previously input ones.\nVisualize the spatial spots:\nlibrary(ggplot2) location \u0026lt;- simulate_result$simulate_result$col_meta p \u0026lt;- ggplot(location, aes(x = x, y = y))+ geom_point(aes(color = group))+ theme(panel.grid = element_blank(), axis.title = element_blank(), axis.text = element_blank(), legend.position = \u0026quot;bottom\u0026quot;) p "
},
{
	"uri": "/references/methods/14-zinbwave/",
	"title": "zinbwave",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using zinbwave Here zinbwave method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data Using simmethods::zinbwave_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::zinbwave_estimation(ref_data = ref_data, verbose = T, seed = 10) # Estimating parameters using zinbwave # Removing all zero genes... # Fitting model... # Create model: # ok # Initialize parameters: # ok # Optimize parameters: # Iteration 1 # penalized log-likelihood = -1458528.51195789 # After dispersion optimization = -1842970.76424042 # user system elapsed # 6.818 0.562 7.599 # After right optimization = -1681437.25066416 # After orthogonalization = -1681437.25066416 # user system elapsed # 2.545 0.188 2.802 # After left optimization = -1615279.08884363 # After orthogonalization = -1615279.08884363 # Iteration 2 # penalized log-likelihood = -1615279.08884363 # After dispersion optimization = -1615279.08884363 # user system elapsed # 5.128 0.413 5.608 # After right optimization = -1613680.86211755 # After orthogonalization = -1613680.86211755 # user system elapsed # 2.016 0.158 2.199 # After left optimization = -1613424.05613962 # After orthogonalization = -1613424.05613962 # Iteration 3 # penalized log-likelihood = -1613424.05613962 # After dispersion optimization = -1613424.05613962 # user system elapsed # 4.531 0.374 4.962 # After right optimization = -1613329.33593763 # After orthogonalization = -1613329.33593763 # user system elapsed # 1.262 0.077 1.348 # After left optimization = -1613299.28560498 # After orthogonalization = -1613299.28560498 # Iteration 4 # penalized log-likelihood = -1613299.28560498 # ok Simulating datasets using zinbwave After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters.\nThe reference data contains 160 cells and 4000 genes, we can only simulate datasets with default parameters in zinbwave and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::zinbwave_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 1 column # Cell # \u0026lt;character\u0026gt; # Cell1 Cell1 # Cell2 Cell2 # Cell3 Cell3 # Cell4 Cell4 # Cell5 Cell5 # Cell6 Cell6 head(rowData(SCE_result)) # DataFrame with 6 rows and 1 column # Gene # \u0026lt;character\u0026gt; # Gene1 Gene1 # Gene2 Gene2 # Gene3 Gene3 # Gene4 Gene4 # Gene5 Gene5 # Gene6 Gene6 "
},
{
	"uri": "/references/methods/15-zinger/",
	"title": "zingeR",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using zingeR Datasets with default parameters Determin the number of cells and genes Simulate two groups Here zingeR method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nWhen you use zingeR to estimate parameters from a real dataset, you must input a numeric vector to specify the groups or plates that each cell comes from, like other_prior = list(group.condition = the numeric vector).\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data group_condition \u0026lt;- simmethods::group_condition ## group_condition can must be a numeric vector. other_prior \u0026lt;- list(group.condition = as.numeric(group_condition)) Using simmethods::zingeR_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::zingeR_estimation(ref_data = ref_data, other_prior = other_prior, verbose = T, seed = 10) # Estimating parameters using zingeR Simulating datasets using zingeR After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Simulate two groups Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group of cells.\nsimulate_result \u0026lt;- simmethods::zingeR_simulation( ref_data = ref_data, other_prior = other_prior, parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 2 # prob.group: 0.1 # fc.group: 2 # Loading required package: edgeR # Loading required package: limma # # Attaching package: \u0026#39;limma\u0026#39; # The following object is masked from \u0026#39;package:BiocGenerics\u0026#39;: # # plotMA # # Attaching package: \u0026#39;edgeR\u0026#39; # The following object is masked from \u0026#39;package:SingleCellExperiment\u0026#39;: # # cpm # Preparing dataset. Using existing parameters. # Sampling. # Calculating differential expression. # Simulating data. SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 1 column # cell_name # \u0026lt;character\u0026gt; # Cell1 Cell1 # Cell2 Cell2 # Cell3 Cell3 # Cell4 Cell4 # Cell5 Cell5 # Cell6 Cell6 head(rowData(SCE_result)) # DataFrame with 6 rows and 3 columns # gene_name de_gene de_fc # \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; \u0026lt;numeric\u0026gt; # Gene1 Gene1 no 0 # Gene2 Gene2 no 0 # Gene3 Gene3 no 0 # Gene4 Gene4 no 0 # Gene5 Gene5 no 0 # Gene6 Gene6 no 0 Determin the number of cells and genes In zingeR, users can only set the number of cells and genes which is higher than the reference data. Here, we simulate a new dataset with 1000 cells and 5000 genes:\nsimulate_result \u0026lt;- simmethods::zingeR_simulation( ref_data = ref_data, other_prior = list(group.condition = as.numeric(group_condition), nCells = 1000, nGenes = 5000), parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, seed = 111 ) # nCells: 1000 # nGenes: 5000 # nGroups: 2 # prob.group: 0.1 # fc.group: 2 # Preparing dataset. Using existing parameters. # Sampling. # Calculating differential expression. # Simulating data. result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 5000 1000 Simulate two groups In zingeR, we can only simulate two groups and note that zingeR dose not return cell group information.\nFor demonstration, we will simulate two groups using the learned parameters. We can set de.prob = 0.2 to simulate 20% genes as DEGs.\nsimulate_result \u0026lt;- simmethods::zingeR_simulation( ref_data = ref_data, other_prior = list(group.condition = as.numeric(group_condition), nCells = 1000, nGenes = 5000, de.prob = 0.2, fc.group = 4), parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, seed = 111 ) # nCells: 1000 # nGenes: 5000 # nGroups: 2 # prob.group: 0.2 # fc.group: 4 # Preparing dataset. Using existing parameters. # Sampling. # Calculating differential expression. # Simulating data. zingeR dose not return cell group information.\nresult \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 5000 1000 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) ## de.prob = 0.2 # yes # 0.2 "
},
{
	"uri": "/references/methods/16-zinbwavezinger/",
	"title": "zinbwaveZinger",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using zinbwaveZinger Datasets with default parameters Determin the number of cells and genes Simulate two groups Here zinbwaveZinger method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nWhen you use zinbwaveZinger to estimate parameters from a real dataset, you must input a numeric vector to specify the groups or plates that each cell comes from, like other_prior = list(group.condition = the numeric vector).\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data group_condition \u0026lt;- simmethods::group_condition ## group_condition can must be a numeric vector. other_prior \u0026lt;- list(group.condition = as.numeric(group_condition)) Using simmethods::zinbwaveZinger_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::zinbwaveZinger_estimation(ref_data = ref_data, other_prior = other_prior, verbose = T, seed = 10) # Estimating parameters using zinbwaveZinger # iteration 1 in 10 # iteration 2 in 10 # iteration 3 in 10 # iteration 4 in 10 # iteration 5 in 10 # iteration 6 in 10 # iteration 7 in 10 # iteration 8 in 10 # iteration 9 in 10 # iteration 10 in 10 Simulating datasets using zinbwaveZinger After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Simulate two groups Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group of cells.\nsimulate_result \u0026lt;- simmethods::zinbwaveZinger_simulation( ref_data = ref_data, other_prior = other_prior, parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 2 # prob.group: 0.1 # fc.group: 2 # Preparing dataset. # Sampling. # Calculating differential expression. # Simulating data. # Adding extra zeros w.r.t. NB for 2366 genes SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 1 column # cell_name # \u0026lt;character\u0026gt; # Cell1 Cell1 # Cell2 Cell2 # Cell3 Cell3 # Cell4 Cell4 # Cell5 Cell5 # Cell6 Cell6 head(rowData(SCE_result)) # DataFrame with 6 rows and 3 columns # gene_name de_gene de_fc # \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; \u0026lt;numeric\u0026gt; # Gene1 Gene1 no 0 # Gene2 Gene2 no 0 # Gene3 Gene3 no 0 # Gene4 Gene4 no 0 # Gene5 Gene5 no 0 # Gene6 Gene6 no 0 Determin the number of cells and genes In zinbwaveZinger, users can only set the number of cells and genes which is higher than the reference data. Here, we simulate a new dataset with 1000 cells and 5000 genes:\nsimulate_result \u0026lt;- simmethods::zinbwaveZinger_simulation( ref_data = ref_data, other_prior = list(group.condition = as.numeric(group_condition), nCells = 1000, nGenes = 5000), parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, seed = 111 ) # nCells: 1000 # nGenes: 5000 # nGroups: 2 # prob.group: 0.1 # fc.group: 2 # Preparing dataset. # Sampling. # Calculating differential expression. # Simulating data. # Adding extra zeros w.r.t. NB for 2776 genes result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 5000 1000 Simulate two groups In zinbwaveZinger, we can only simulate two groups and note that zinbwaveZinger dose not return cell group information.\nFor demonstration, we will simulate two groups using the learned parameters. We can set de.prob = 0.2 to simulate 20% genes as DEGs.\nsimulate_result \u0026lt;- simmethods::zinbwaveZinger_simulation( ref_data = ref_data, other_prior = list(group.condition = as.numeric(group_condition), nCells = 1000, nGenes = 5000, de.prob = 0.2, fc.group = 4), parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, seed = 111 ) # nCells: 1000 # nGenes: 5000 # nGroups: 2 # prob.group: 0.2 # fc.group: 4 # Preparing dataset. # Sampling. # Calculating differential expression. # Simulating data. # Adding extra zeros w.r.t. NB for 2640 genes zinbwaveZinger dose not return cell group information.\nresult \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 5000 1000 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) ## de.prob = 0.2 # yes # 0.2 "
},
{
	"uri": "/references/methods/17-basics/",
	"title": "BASiCS",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset prior information of cell batches prior information of ERCC spike-in control RNA Simulating datasets using BASiCS Determin the number of cells and genes Simulate two or more batches Here BASiCS method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. Errors usually occurred when using BASiCS, so that we used a dataset which can successfully pass through the execution for demonstration and it can be downloaded here.\nlibrary(simmethods) # Load data file_path \u0026lt;- \u0026quot;../../../../preprocessed_data/data95_pancreatic-alpha-cell-maturation_zhang.rds\u0026quot; data \u0026lt;- readRDS(file_path) ref_data \u0026lt;- t(data$data$counts) prior information of cell batches BASiCS allows users to input the prior information of cell batches, which is a numeric vector that specifies the batch label for each cell. Data95 does not contain the batch information, so we can randomly sample some labels for cells.\nset.seed(666) batch_label \u0026lt;- sample(c(1,2), size = ncol(ref_data), replace = TRUE) Using simmethods::BASiCS_estimation command to execute the estimation step, but it may take a lot of time.\nestimate_result \u0026lt;- simmethods::BASiCS_estimation( ref_data = ref_data, other_prior = list(batch.condition = batch_label), verbose = TRUE, seed = 8 ) prior information of ERCC spike-in control RNA Otherwise, users can also input the prior information of ERCC spike-in control RNA, which contains three important parameters:\nMake sure that there are spike-in genes in your count matrix whose prefix are ERCC-. If not, the error may occur. dilution.factor: The dilution factor to dilute the ERCC spike-in mix liquid. volume: The volume (microliter) of spike-in mix used in sequencing step. Check out the names of ERCC spike-in RNA:\nrownames(ref_data)[grep(\u0026quot;^ERCC-\u0026quot;, rownames(ref_data))] # [1] \u0026quot;ERCC-00116\u0026quot; \u0026quot;ERCC-00025\u0026quot; \u0026quot;ERCC-00165\u0026quot; \u0026quot;ERCC-00053\u0026quot; \u0026quot;ERCC-00112\u0026quot; # [6] \u0026quot;ERCC-00078\u0026quot; \u0026quot;ERCC-00084\u0026quot; \u0026quot;ERCC-00019\u0026quot; \u0026quot;ERCC-00163\u0026quot; \u0026quot;ERCC-00099\u0026quot; # [11] \u0026quot;ERCC-00160\u0026quot; \u0026quot;ERCC-00059\u0026quot; \u0026quot;ERCC-00035\u0026quot; \u0026quot;ERCC-00092\u0026quot; \u0026quot;ERCC-00170\u0026quot; # [16] \u0026quot;ERCC-00144\u0026quot; \u0026quot;ERCC-00062\u0026quot; \u0026quot;ERCC-00044\u0026quot; \u0026quot;ERCC-00157\u0026quot; Prepare other two parameters:\nother_prior \u0026lt;- list(dilution.factor = data$data_info$dilution_factor, volume = data$data_info$volume) Execute the parameter estimation (it may take a long time):\nestimate_result \u0026lt;- simmethods::BASiCS_estimation( ref_data = ref_data, other_prior = other_prior, verbose = TRUE, seed = 8 ) Simulating datasets using BASiCS After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Simulate two or more batches simulate_result \u0026lt;- simmethods::BASiCS_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, seed = 1 ) # nCells: 322 # nGenes: 6119 # nBatches: 1 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(result$count_data) # [1] 6138 322 Determin the number of cells and genes In BASiCS, we can set batchCells and nGenes to specify the number of cells and genes.\nHere, we simulate a new dataset with 1000 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::BASiCS_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = 1000, nGenes = 1000), seed = 3 ) # nCells: 1000 # nGenes: 1000 # nBatches: 1 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1019 1000 Simulate two or more batches There is a strict rule for simulating cell batches using BASiCS: 1) Users can simulate cell batches when the information of cell batch labels is used for parameter estimation; 2) The number of the simulated batches must be equal to that of the real cell batches used in parameter estimation.\n.\nAs we did not use the information of cell batches in parameter estimation, so we can not simulate the data with batch effects. But for demonstrations, we will show the approaches for simulating cell batches.\nThe number of cell batches is determined by batchCells parameter, whose length represents the number of batches that need to be simulated. For example, three batches of cells will be simulated by setting batchCells=c(100,200,300).\nsimulate_result \u0026lt;- simmethods::BASiCS_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = c(100,200,300), nGenes = 1000), seed = 3 ) "
},
{
	"uri": "/references/methods/18-bearscc/",
	"title": "BEARscc",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using BEARscc Here BEARscc method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. The reference data can be downloaded here.\nBEARscc needs spike-in ERCC genes as the reference to measure the variation of the real dataset and there are some notes that users must pay attention to.\nMake sure that there are spike-in genes in your count matrix whose prefix are ERCC-. If not, the error may occur.\nBEARscc needs ensembl gene id to execute estimation step, so it is better to transform the gene id previously. But users can also input official gene id and the procedure will convert them into ensembl gene id and note that this step may result in losing some genes when matching gene ids.\nIf users need the transformation of gene ids, users must input the species name parameter: mouse or human. And we will match the according database to accomplish the conversion step.\nAnother important parameters: dilution.factor, volume\ndilution.factor: The dilution factor to dilute the ERCC spike-in mix liquid. volume: The volume (microliter) of spike-in mix used in sequencing step. library(simmethods) library(SingleCellExperiment) # Load data (downloaded from https://zenodo.org/record/8251596/files/data23_GSE62270.rds?download=1) data \u0026lt;- readRDS(\u0026quot;../../../../preprocessed_data/data23_GSE62270.rds\u0026quot;) ref_data \u0026lt;- data$data ## group_condition can must be a numeric vector. other_prior \u0026lt;- list(dilution.factor = 50000, volume = 0.03, species = \u0026quot;mouse\u0026quot;) Using simmethods::BEARscc_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::BEARscc_estimation( ref_data = ref_data, other_prior = other_prior, verbose = TRUE, seed = 8 ) # Estimating parameters using BEARscc # [1] \u0026quot;Fitting parameter alpha to establish spike-in derived noise model.\u0026quot; # [1] \u0026quot;Estimating error for spike-ins with alpha = 0\u0026quot; # [1] \u0026quot;Estimating error for spike-ins with alpha = 0.25\u0026quot; # [1] \u0026quot;Estimating error for spike-ins with alpha = 0.5\u0026quot; # [1] \u0026quot;Estimating error for spike-ins with alpha = 0.75\u0026quot; # [1] \u0026quot;Estimating error for spike-ins with alpha = 1\u0026quot; # [1] \u0026quot;Warning: there are no spike-ins that were detected inevery sample. As a result the actual transcript countthreshold, k, at which drop-outs are not present will beextrapolated rather than interpolated. The extrapolated value for k is, 2205.\u0026quot; # [1] \u0026quot;There are adequate spike-in drop-outs to build the drop-out model. Estimating the drop-out model now.\u0026quot; Simulating datasets using BEARscc Users can not set the number of cells or genes in BEARscc.\nsimulate_result \u0026lt;- simmethods::BEARscc_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, seed = 111 ) # nCells: 672 # nGenes: 21427 # [1] \u0026quot;Creating a simulated replicated counts matrix: 1.\u0026quot; result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(result$count_data) # [1] 21427 672 "
},
{
	"uri": "/references/methods/19-sparsim/",
	"title": "SPARSim",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Estimation without cell group information Estimation with cell group information Estimation with spike-in genes Simulating datasets using SPARSim Datasets with default parameters Simulate groups Simulate batch Here SPARSim method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data Estimation without cell group information In SPARSim, users can estimate parameters from real data only using gene expression matrix.\nUsing simmethods::SPARSim_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::SPARSim_estimation( ref_data = ref_data, other_prior = NULL, verbose = TRUE, seed = 111 ) # Estimating parameters using SPARSim # [1] \u0026quot;Experimental condition 1\u0026quot; # [1] \u0026quot;...estimating gene intensity\u0026quot; # [1] \u0026quot;...estimating gene variability\u0026quot; # [1] \u0026quot;...estimating library size\u0026quot; # [1] \u0026quot;...creating SPARSim simulation parameter\u0026quot; Estimation with cell group information In addition, you can also input a numeric vector to specify the groups or plates that each cell comes from, like other_prior = list(group.condition = the numeric vector).\ngroup \u0026lt;- as.numeric(simmethods::group_condition) estimate_result \u0026lt;- simmethods::SPARSim_estimation( ref_data = ref_data, other_prior = list(group.condition = group), verbose = TRUE, seed = 111 ) # Estimating parameters using SPARSim # [1] \u0026quot;Experimental condition 1\u0026quot; # [1] \u0026quot;...estimating gene intensity\u0026quot; # [1] \u0026quot;...estimating gene variability\u0026quot; # [1] \u0026quot;...estimating library size\u0026quot; # [1] \u0026quot;...creating SPARSim simulation parameter\u0026quot; # [1] \u0026quot;Experimental condition 2\u0026quot; # [1] \u0026quot;...estimating gene intensity\u0026quot; # [1] \u0026quot;...estimating gene variability\u0026quot; # [1] \u0026quot;...estimating library size\u0026quot; # [1] \u0026quot;...creating SPARSim simulation parameter\u0026quot; Estimation with spike-in genes In SPARSim, ERCC spike-in genes can be used to estimate data parameters from the real data. In this case, the gene matrix must contain spike-in gene counts and hold the right ERCC spike-in gene names. Note that users must also input the dilution factor and volume (microliter) which the experiment used.\ngroup \u0026lt;- as.numeric(simmethods::group_condition) other_prior \u0026lt;- list(group.condition = group, dilution.factor = 50000, volume = 0.01) estimate_result \u0026lt;- simmethods::SPARSim_estimation( ref_data = ref_data, other_prior = other_prior, verbose = TRUE, seed = 111 ) # Estimating parameters using SPARSim # [1] \u0026quot;Experimental condition 1\u0026quot; # [1] \u0026quot;...estimating gene intensity\u0026quot; # [1] \u0026quot;...estimating gene variability\u0026quot; # [1] \u0026quot;...estimating library size\u0026quot; # [1] \u0026quot;...creating SPARSim simulation parameter\u0026quot; # [1] \u0026quot;Experimental condition 2\u0026quot; # [1] \u0026quot;...estimating gene intensity\u0026quot; # [1] \u0026quot;...estimating gene variability\u0026quot; # [1] \u0026quot;...estimating library size\u0026quot; # [1] \u0026quot;...creating SPARSim simulation parameter\u0026quot; Check spike-in parameters\nspikein_params \u0026lt;- estimate_result[[\u0026quot;estimate_result\u0026quot;]][[\u0026quot;SPARSim_spikein_parameter\u0026quot;]] str(spikein_params) # List of 4 # $ spikein_set :List of 1 # ..$ spikein:List of 4 # .. ..$ mix_name : chr \u0026quot;spikein\u0026quot; # .. ..$ abundance : Named num [1:50] 3613.2 903.3 225.8 112.9 56.5 ... # .. .. ..- attr(*, \u0026quot;names\u0026quot;)= chr [1:50] \u0026quot;spikein_1\u0026quot; \u0026quot;spikein_2\u0026quot; \u0026quot;spikein_3\u0026quot; \u0026quot;spikein_4\u0026quot; ... # .. ..$ variability: Named num [1:50] 0 0 0 0 0 0 0 0 0 0 ... # .. .. ..- attr(*, \u0026quot;names\u0026quot;)= chr [1:50] \u0026quot;spikein_1\u0026quot; \u0026quot;spikein_2\u0026quot; \u0026quot;spikein_3\u0026quot; \u0026quot;spikein_4\u0026quot; ... # .. ..$ ids : chr [1:50] \u0026quot;spikein_1\u0026quot; \u0026quot;spikein_2\u0026quot; \u0026quot;spikein_3\u0026quot; \u0026quot;spikein_4\u0026quot; ... # $ spikein_sample : chr [1:160] \u0026quot;spikein\u0026quot; \u0026quot;spikein\u0026quot; \u0026quot;spikein\u0026quot; \u0026quot;spikein\u0026quot; ... # $ spikein_proportion: num 0.05 # $ spikein_ids : chr [1:50] \u0026quot;spikein_1\u0026quot; \u0026quot;spikein_2\u0026quot; \u0026quot;spikein_3\u0026quot; \u0026quot;spikein_4\u0026quot; ... Simulating datasets using SPARSim After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Simulate groups Simulate batches Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nThe simulated dataset will have one group of cells as no group information is used in estimation step.\nestimate_result \u0026lt;- simmethods::SPARSim_estimation( ref_data = ref_data, other_prior = NULL, verbose = TRUE, seed = 111 ) # Estimating parameters using SPARSim # [1] \u0026quot;Experimental condition 1\u0026quot; # [1] \u0026quot;...estimating gene intensity\u0026quot; # [1] \u0026quot;...estimating gene variability\u0026quot; # [1] \u0026quot;...estimating library size\u0026quot; # [1] \u0026quot;...creating SPARSim simulation parameter\u0026quot; simulate_result \u0026lt;- simmethods::SPARSim_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 1 # fc.group: 0 # de.prob: 0 # nBatches: 0 # Number of experimental conditions: 1 # Number of genes: 4000 # Number of cells: 160 # Setting gene expression intensity... # Setting gene expression variability ... # Simulating biological variability ... # Simulating technical variability ... SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 2 columns # cell_name group # \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; # Cell1 Cell1 Group1 # Cell2 Cell2 Group1 # Cell3 Cell3 Group1 # Cell4 Cell4 Group1 # Cell5 Cell5 Group1 # Cell6 Cell6 Group1 head(rowData(SCE_result)) # DataFrame with 6 rows and 1 column # gene_name # \u0026lt;character\u0026gt; # Gene1 Gene1 # Gene2 Gene2 # Gene3 Gene3 # Gene4 Gene4 # Gene5 Gene5 # Gene6 Gene6 Simulate groups The number of groups simulated by SPARSim is determined by the group information used in estimation step. If the group information of two cell states is provided, then the simulated dataset will contain two groups. SPARSim also provides other parameters related to DEGs such as the proportion of DEGs (de.prob) and the fold change of DGEs (fc.group).\nEstimating parameters using group information\ngroup \u0026lt;- as.numeric(simmethods::group_condition) estimate_result \u0026lt;- simmethods::SPARSim_estimation( ref_data = ref_data, other_prior = list(group.condition = group), verbose = TRUE, seed = 111 ) # Estimating parameters using SPARSim # [1] \u0026quot;Experimental condition 1\u0026quot; # [1] \u0026quot;...estimating gene intensity\u0026quot; # [1] \u0026quot;...estimating gene variability\u0026quot; # [1] \u0026quot;...estimating library size\u0026quot; # [1] \u0026quot;...creating SPARSim simulation parameter\u0026quot; # [1] \u0026quot;Experimental condition 2\u0026quot; # [1] \u0026quot;...estimating gene intensity\u0026quot; # [1] \u0026quot;...estimating gene variability\u0026quot; # [1] \u0026quot;...estimating library size\u0026quot; # [1] \u0026quot;...creating SPARSim simulation parameter\u0026quot; For demonstration, we will simulate two groups using the learned parameters. We can set de.prob = 0.2 to simulate 20% genes as DEGs.\nsimulate_result \u0026lt;- simmethods::SPARSim_simulation( other_prior = list(de.prob = 0.2, fc.group = 4), parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 2 # fc.group: 4 # de.prob: 0.2 # nBatches: 0 # Number of experimental conditions: 2 # Number of genes: 4000 # Number of cells: 160 # Setting gene expression intensity... # Setting gene expression variability ... # Simulating biological variability ... # Simulating technical variability ... result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 4000 160 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) ## de.prob = 0.2 # yes # 0.2 Simulate batch Users can simulate batches when batch.condition parameter is activated and just input the numeric vectors that specify the batch labels of cells.\nFor demonstration, we will simulate three batches using the learned parameters.\nsimulate_result \u0026lt;- simmethods::SPARSim_simulation( other_prior = list(de.prob = 0.2, fc.group = 4, batch.condition = sample(1:3, 160, replace = TRUE)), parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 2 # fc.group: 4 # de.prob: 0.2 # nBatches: 3 # Number of experimental conditions: 2 # Number of genes: 4000 # Number of cells: 160 # Setting gene expression intensity... # Setting gene expression variability ... # Simulating batch effects ... # Simulating biological variability ... # Simulating technical variability ... ## cell information col_data \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(col_data$group) # # Group1 Group2 # 80 80 table(col_data$batch) # # Batch1 Batch2 Batch3 # 63 43 54 "
},
{
	"uri": "/references/methods/20-spsimseq/",
	"title": "SPsimSeq",
	"tags": [],
	"description": "",
	"content": " Simulating datasets using SPsimSeq Datasets with default parameters Determin the number of cells and genes Simulate groups Simulate batches There is no individual estimation step using SPsimSeq as the estimation is combined with simulation step.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data Simulating datasets using SPsimSeq Datasets with default parameters Determin the number of cells and genes Simulate groups Simulate batches Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::SPsimSeq_simulation( ref_data = ref_data, other_prior = NULL, return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # # nCells: 160 # nGenes: 4000 # nGroups: 1 # de.prob: 0.1 # fc.group: 2 # nBatches: 1 # Warning in max(abs(logR)): no non-missing arguments to max; returning -Inf SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 3 columns # cell_name group batch # \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; # Cell1 Cell1 Group1 Batch1 # Cell2 Cell2 Group1 Batch1 # Cell3 Cell3 Group1 Batch1 # Cell4 Cell4 Group1 Batch1 # Cell5 Cell5 Group1 Batch1 # Cell6 Cell6 Group1 Batch1 head(rowData(SCE_result)) # DataFrame with 6 rows and 1 column # gene_name # \u0026lt;character\u0026gt; # Gene1 Gene1 # Gene2 Gene2 # Gene3 Gene3 # Gene4 Gene4 # Gene5 Gene5 # Gene6 Gene6 Determin the number of cells and genes simulate_result \u0026lt;- simmethods::SPsimSeq_simulation( ref_data = ref_data, other_prior = list(nCells = 500, nGenes = 1000), return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # fc.group: 2 # nBatches: 1 # Warning in max(abs(logR)): no non-missing arguments to max; returning -Inf SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 1000 500 Simulate groups The number of groups simulated by SPsimSeq is determined by the group information used in simulation step. If the group information of two cell states is provided, then the simulated dataset will contain two groups. SPsimSeq also provides other parameters related to DEGs such as the proportion of DEGs (de.prob) and the fold change of DGEs (fc.group).\nFor demonstration, we will simulate two groups using the learned parameters. We can set de.prob = 0.2 to simulate 20% genes as DEGs.\ngroup_condition \u0026lt;- as.numeric(simmethods::group_condition) simulate_result \u0026lt;- simmethods::SPsimSeq_simulation( ref_data = ref_data, other_prior = list(group.condition = group_condition, de.prob = 0.2, fc.group = 4), return_format = \u0026quot;list\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 2 # de.prob: 0.2 # fc.group: 4 # nBatches: 1 # Warning in max(abs(logR)): no non-missing arguments to max; returning -Inf # Note: The number of DE genes detected in the source data is 5 and the number of DE genes required to be included in the simulated data is 800. Therefore, candidiate DE genes are sampled with replacement. col_data \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(col_data$group) # # Group1 Group2 # 80 80 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(gene_info) ## de.prob = 0.2 # yes # 0.2 Simulate batches Users can simulate batches when batch.condition parameter is activated and just input the numeric vectors that specify the batch labels of cells.\nset.seed(111) ref_data \u0026lt;- scater::mockSCE(ncells = 160, ngenes = 4000) ref_data \u0026lt;- SingleCellExperiment::counts(ref_data) For demonstration, we will simulate two batches.\nsimulate_result \u0026lt;- simmethods::SPsimSeq_simulation( ref_data = ref_data, other_prior = list(batch.condition = sample(1:3, 160, replace = TRUE)), return_format = \u0026quot;list\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 1 # de.prob: 0.1 # fc.group: 2 # nBatches: 3 ## cell information col_data \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(col_data$batch) # # Batch1 Batch2 Batch3 # 50 58 52 "
},
{
	"uri": "/references/methods/21-esco/",
	"title": "ESCO",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using ESCO Datasets with default parameters Determin the number of cells and genes Simulate two or more groups Here ESCO method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data dim(ref_data) # [1] 4000 160 Using simmethods::ESCO_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::ESCO_estimation( ref_data = ref_data, verbose = T, seed = 10 ) # Registered S3 method overwritten by \u0026#39;DescTools\u0026#39;: # method from # reorder.factor gplots # Registered S3 methods overwritten by \u0026#39;registry\u0026#39;: # method from # print.registry_field proxy # print.registry_entry proxy # Estimating parameters using ESCO ESCO is not stable, and some datasets can not be estimated due to the failing estimation.\nSimulating datasets using ESCO After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Simulate two or more groups Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group of cells.\nsimulate_result \u0026lt;- simmethods::ESCO_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 1 # de.group: 0.1 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 2 columns # cell_name group # \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; # Cell1 Cell1 Group1 # Cell2 Cell2 Group1 # Cell3 Cell3 Group1 # Cell4 Cell4 Group1 # Cell5 Cell5 Group1 # Cell6 Cell6 Group1 Determin the number of cells and genes In ESCO, we can set nCells and nGenes to specify the number of cells and genes.\nHere, we simulate a new dataset with 500 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::ESCO_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 500, nGenes = 1000), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 1 # de.group: 0.1 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 Simulate two or more groups In ESCO, we can not set nGroups directly and should set prob.group instead. For example, if we want to simulate 2 groups, we can type other_prior = list(prob.group = c(0.5, 0.5)). Note that the sum of prob.group numeric vector must equal to 1, so we can also set prob.group = c(0.3, 0.7).\nIn addtion, if we want to simulate three or more groups, we should obey the rules:\nThe length of prob.group vector must always equal to the number of groups. The sum of prob.group numeric vector must equal to 1. For demonstration, we will simulate three groups using the learned parameters.\nsimulate_result \u0026lt;- simmethods::ESCO_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 500, nGenes = 1000, prob.group = c(0.1, 0.3, 0.6)), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 3 # de.group: 0.1 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$group) # # Group1 Group2 Group3 # 47 168 285 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) ## de.prob = 0.1 # yes # 0.1 We can see that the proportion of differential expressed genes is 0.1 (equals to the default). Next, if we want to know the fold change between two groups, we will do division with the groups that we are interested in.\n## fc between group2 and group1 fc_group1_to_group2 \u0026lt;- gene_info$DEFacGroup2/gene_info$DEFacGroup1 ## fc between group3 and group1 fc_group1_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup1 ## fc between group3 and group2 fc_group2_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup2 "
},
{
	"uri": "/references/methods/22-sparsedc/",
	"title": "SparseDC",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using SparseDC Datasets with default parameters Determin the number of cells and genes Simulate two or more groups Here SparseDC method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- SingleCellExperiment::counts(scater::mockSCE()) dim(ref_data) # [1] 2000 200 set.seed(111) group_condition \u0026lt;- sample(1:2, ncol(ref_data), replace = TRUE) When you use SparseDC to estimate parameters from a real dataset, you must input a numeric vector to specify the groups or plates that each cell comes from, like other_prior = list(group.condition = the numeric vector).\nNote that SparseDC defines 2 clusters presented in the dataset by default and users can input other number if the estimation step failed through nclusters parameter.\nestimate_result \u0026lt;- simmethods::SparseDC_estimation( ref_data = ref_data, other_prior = list(group.condition = group_condition, nclusters = 2), verbose = T, seed = 10 ) # Estimating parameters using SparseDC SparseDC is not stable, and some datasets can not be estimated due to the failing estimation.\nSimulating datasets using SparseDC After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Simulate two or more groups Datasets with default parameters The reference data contains 200 cells and 2000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group of cells.\nsimulate_result \u0026lt;- simmethods::SparseDC_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 200 # nGenes: 2000 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 2000 200 Determin the number of cells and genes In SparseDC, we can set nCells and nGenes to specify the number of cells and genes.\nHere, we simulate a new dataset with 1000 cells and 1000 genes:\nNote that SparseDC defines 2 clusters in the estimation step by default and the number of cells is defined as nCells * nclusters.\nsimulate_result \u0026lt;- simmethods::SparseDC_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 500, nGenes = 1000), seed = 111 ) # nCells: 1000 # nGenes: 1000 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 1000 Simulate two or more groups In SparseDC, the number of groups is determined by the group information (group.condition parameter) used in estimation step. If the group information contains two cell states, and the simulated dataset will contain two groups of cells.\nThe demonstrations above use two groups of cells in the eatimation step, and the result will hold two groups.\n## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$group) # # Group1 Group2 # 500 500 "
},
{
	"uri": "/references/methods/23-muscat/",
	"title": "muscat",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Default eatimation Estimation with cell groups Simulating datasets using muscat Datasets with default parameters Determin the number of cells and genes Simulate two or more groups Here muscat method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data Default eatimation estimate_result \u0026lt;- simmethods::muscat_estimation( ref_data = ref_data, other_prior = NULL, verbose = T, seed = 10 ) # Estimating parameters using muscat # Filtering... # - 4000/4000 genes and 160/160 cells retained. # Estimating gene and cell parameters... Estimation with cell groups When you use muscat to estimate parameters from a real dataset, you can also input a numeric vector to specify the groups or plates that each cell comes from, like other_prior = list(group.condition = the numeric vector).\ngroup_condition \u0026lt;- as.numeric(simmethods::group_condition) estimate_result \u0026lt;- simmethods::muscat_estimation( ref_data = ref_data, other_prior = list(group.condition = group_condition), verbose = T, seed = 10 ) # Estimating parameters using muscat # Filtering... # - 4000/4000 genes and 160/160 cells retained. # Estimating gene and cell parameters... Simulating datasets using muscat After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Simulate two or more groups Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group of cells.\nsimulate_result \u0026lt;- simmethods::muscat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], other_prior = NULL, return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 1 # de.group: 0.1 # fc.group: 2 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 Determin the number of cells and genes In muscat, we can set nCells and nGenes to specify the number of cells and genes.\nHere, we simulate a new dataset with 1000 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::muscat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 1000, nGenes = 1000), seed = 111 ) # nCells: 1000 # nGenes: 1000 # nGroups: 1 # de.group: 0.1 # fc.group: 2 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 1000 Simulate two or more groups In muscat, we can set nGroups directly to specify the number of simulated groups. muscat also provides other parameters related to DEGs such as the proportion of DEGs (de.prob) and the fold change of DGEs (fc.group).\nFor demonstration, we will simulate two groups using the learned parameters.\nsimulate_result \u0026lt;- simmethods::muscat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 500, nGenes = 1000, nGroups = 2, de.prob = 0.4, fc.group = 4), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 2 # de.group: 0.4 # fc.group: 4 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$group) # # Group1 Group2 # 240 260 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) ## de.prob = 0.4 # yes # 0.384 "
},
{
	"uri": "/references/methods/24-simbpdd/",
	"title": "SimBPDD",
	"tags": [],
	"description": "",
	"content": " Simulating datasets using SimBPDD Datasets with default parameters Determin the number of cells Simulate two groups of cells Here SimBPDD method will be demonstrated clearly and hope that this document can help you.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data # SimBPDD takes a long time to simulate datasets, so we subset the reference data ref_data \u0026lt;- ref_data[1:100, ] Simulating datasets using SimBPDD There is no individual estimation step using SimBPDD as the estimation is combined with simulation step.\nDatasets with default parameters Determin the number of cells Simulate two groups of cells Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::SimBPDD_simulation( ref_data = ref_data, return_format = \u0026quot;list\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 100 # nGroups: 2 Check the dimension of the simulated data:\ncount_data \u0026lt;- simulate_result$simulate_result$count_data dim(count_data) # [1] 95 160 Check the group labels of the simulated cells:\ncol_data \u0026lt;- simulate_result$simulate_result$col_meta table(col_data$group) # # Group1 Group2 # 80 80 Determin the number of cells simulate_result \u0026lt;- simmethods::SimBPDD_simulation( ref_data = ref_data, other_prior = list(nCells = 100), return_format = \u0026quot;list\u0026quot;, seed = 111 ) # nCells: 100 # nGenes: 100 # nGroups: 2 Check the dimension of the simulated data:\ncount_data \u0026lt;- simulate_result$simulate_result$count_data dim(count_data) # [1] 95 100 The number of simulated genes is not equal to the original one, as the genes with zero counts across all cells are removed.\nSimulate two groups of cells In SimBPDD, we can directly set other_prior = list(prob.group = c(0.4, 0.6)) to assign two proportions of cell groups.\nsimulate_result \u0026lt;- simmethods::SimBPDD_simulation( ref_data = ref_data, other_prior = list(nCells = 100, prob.group = c(0.4, 0.6)), return_format = \u0026quot;list\u0026quot;, seed = 111 ) # nCells: 100 # nGenes: 100 # nGroups: 2 Check cell groups:\ntable(simulate_result$simulate_result$col_meta$group) # # Group1 Group2 # 40 60 SimBPDD can only simulate two cell groups.\n"
},
{
	"uri": "/references/methods/25-cancerinsilico/",
	"title": "CancerInSilico",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using CancerInSilico Datasets with default parameters Determin the number of cells Here CancerInSilico method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data dim(ref_data) # [1] 4000 160 Using simmethods::CancerInSilico_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::CancerInSilico_estimation(ref_data = ref_data, verbose = T, seed = 10) # Estimating parameters using CancerInSilico Simulating datasets using CancerInSilico After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::CancerInSilico_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # # time = 0.00 # size = 1 # time = 1.00 # size = 1 # nCells: 160 # nGenes: 4000 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 1 column # cell_name # \u0026lt;character\u0026gt; # Cell1 Cell1 # Cell2 Cell2 # Cell3 Cell3 # Cell4 Cell4 # Cell5 Cell5 # Cell6 Cell6 head(rowData(SCE_result)) # DataFrame with 6 rows and 1 column # gene_name # \u0026lt;character\u0026gt; # Gene1 Gene1 # Gene2 Gene2 # Gene3 Gene3 # Gene4 Gene4 # Gene5 Gene5 # Gene6 Gene6 Determin the number of cells In CancerInSilico, we can set nCells to specify the number of cells. Here, we simulate a new dataset with 2000 cells:\nsimulate_result \u0026lt;- simmethods::CancerInSilico_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 2000), seed = 111 ) # # time = 0.00 # size = 1 # time = 1.00 # size = 1 # nCells: 2000 # nGenes: 4000 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 4000 2000 "
},
{
	"uri": "/references/methods/26-hierarchicell/",
	"title": "hierarchicell",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using hierarchicell Datasets with default parameters Determin the number of cells and genes Here hierarchicell method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real.\nlibrary(simmethods) library(SingleCellExperiment) # Load data set.seed(111) ref_data \u0026lt;- SingleCellExperiment::counts(scater::mockSCE()) estimate_result \u0026lt;- simmethods::hierarchicell_estimation( ref_data = ref_data, other_prior = NULL, verbose = T, seed = 10 ) # Filtering user input # Genes and cells have been filtered, ready for estimating parameters # You do not set the type of the data (Raw or Norm), we will set \u0026#39;Raw\u0026#39; by default # Estimating parameters using hierarchicell # Normalizing ... # Removing highly correlated genes # Computing sample means, dropout rates, and dispersion ... # Computing final data summaries ... Simulating datasets using hierarchicell After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Datasets with default parameters The reference data contains 200 cells and 2000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nhierarchicell can only simulate two groups of cells.\nsimulate_result \u0026lt;- simmethods::hierarchicell_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], other_prior = NULL, return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 200 # nGenes: 2000 # nGroups: 2 # fc.group: 2 # Computing simulation parameters ... # ------------------------------------------------------- # Distribution of grand means is a gamma # with shape: 783 and rate: 0.15 # ------------------------------------------------------- # Distribution for gene-wise dropout is a gamma # with shape: 45767.5 and rate: 48102.92 # ------------------------------------------------------- # Function for dropout SD is: # DropoutStD = 0.07 + 0.78*DropOut + 15.41*(DropOut**2) # ------------------------------------------------------- # Function for inter-individual SD is: # InterStDev = 0 + 0.86*GrandMean) # ------------------------------------------------------- # Function for dispersion is: # exp(-10.58 + 2103.53/IntraMean) # ------------------------------------------------------- # Simulating cells ... # ------------------------------------------------------- # Simulating expression values ... # ------------------------------------------------------- # All done! SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 2000 200 Some cells in the result may contain NA values across all genes due to the failing of GLM fitting.\ncol_data \u0026lt;- as.data.frame(SingleCellExperiment::colData(SCE_result)) table(col_data$group) # # Group1 Group2 # 102 96 The hierarchicell method is not stable and usually causes failed simulation\nDetermin the number of cells and genes In hierarchicell, we can set nCells and nGenes to specify the number of cells and genes.\nHere, we simulate a new dataset with 1000 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::hierarchicell_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 1000, nGenes = 1000), seed = 111 ) # nCells: 1000 # nGenes: 1000 # nGroups: 2 # fc.group: 2 # Computing simulation parameters ... # ------------------------------------------------------- # Distribution of grand means is a gamma # with shape: 783 and rate: 0.15 # ------------------------------------------------------- # Distribution for gene-wise dropout is a gamma # with shape: 45767.5 and rate: 48102.92 # ------------------------------------------------------- # Function for dropout SD is: # DropoutStD = 0.07 + 0.78*DropOut + 15.41*(DropOut**2) # ------------------------------------------------------- # Function for inter-individual SD is: # InterStDev = 0 + 0.86*GrandMean) # ------------------------------------------------------- # Function for dispersion is: # exp(-10.58 + 2103.53/IntraMean) # ------------------------------------------------------- # Simulating cells ... # ------------------------------------------------------- # Simulating expression values ... # ------------------------------------------------------- # All done! result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 1000 "
},
{
	"uri": "/references/methods/27-dropsim/",
	"title": "dropsim",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using dropsim Datasets with default parameters Determin the number of cells and genes Here dropsim method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data estimate_result \u0026lt;- simmethods::dropsim_estimation( ref_data = ref_data, verbose = T, seed = 10 ) # Estimating parameters using dropsim Simulating datasets using dropsim After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group of cells.\nsimulate_result \u0026lt;- simmethods::dropsim_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], other_prior = NULL, return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 Determin the number of cells and genes In dropsim, we can set nCells and nGenes to specify the number of cells and genes.\nHere, we simulate a new dataset with 1000 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::dropsim_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 1000, nGenes = 1000), seed = 111 ) # nCells: 1000 # nGenes: 1000 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 1000 "
},
{
	"uri": "/references/methods/28-srtsim/",
	"title": "SRTsim",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using SRTsim Datasets with default parameters Simulate cell groups SRTsim was specifically developed for simulating spatial transcriptome data. Besides the gene expression profile, users should also provide the spatial coordinates of each cell (spot). The reference data can be downloaded here.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real.\nlibrary(simmethods) # Load data (downloaded from https://zenodo.org/record/8251596/files/data118_spatial_OV.rds?download=1) data \u0026lt;- readRDS(\u0026quot;../../../../preprocessed_data/data118_spatial_OV.rds\u0026quot;) ref_data \u0026lt;- t(as.matrix(data$data$counts)) In addition, we can set the spatial coordinates by spatial.x and spatial.y parameters.\nother_prior \u0026lt;- list(spatial.x = data$data_info$spatial_coordinate$x, spatial.y = data$data_info$spatial_coordinate$y) Execute the parameter estimation:\nestimate_result \u0026lt;- simmethods::SRTsim_estimation( ref_data = ref_data, other_prior = other_prior, verbose = T, seed = 10 ) # Estimating parameters using SRTsim Users can also input the group information of cells:\nother_prior \u0026lt;- list(spatial.x = data$data_info$spatial_coordinate$x, spatial.y = data$data_info$spatial_coordinate$y, group.condition = data$data_info$group_condition) estimate_result \u0026lt;- simmethods::SRTsim_estimation( ref_data = ref_data, other_prior = other_prior, verbose = T, seed = 10 ) # Estimating parameters using SRTsim Simulating datasets using SRTsim Datasets with default parameters Simulate cell groups Datasets with default parameters simulate_result \u0026lt;- simmethods::SRTsim_simulation( parameters = estimate_result$estimate_result, other_prior = NULL, return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nSpots: 3492 # nGenes: 1056 # nGroups: 2 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 1056 3492 head(colData(SCE_result)) # DataFrame with 6 rows and 4 columns # x y group cell_name # \u0026lt;numeric\u0026gt; \u0026lt;numeric\u0026gt; \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; # AAACAAGTATCTCCCA-1 27 38 B AAACAAGTATCTCCCA-1 # AAACACCAATAACTGC-1 110 29 B AAACACCAATAACTGC-1 # AAACAGGGTCTATATT-1 116 41 B AAACAGGGTCTATATT-1 # AAACATTTCCCGGATT-1 32 27 A AAACATTTCCCGGATT-1 # AAACCCGAACGAAATC-1 14 43 B AAACCCGAACGAAATC-1 # AAACCGGAAATGTTAA-1 5 34 B AAACCGGAAATGTTAA-1 Simulate cell groups There is a strict rule for simulating cell groups using SRTsim:\nUsers can simulate cell groups when the information of cell group labels is used for parameter estimation;\nThe number of the simulated cell groups must be equal to that of the real groups used in parameter estimation.\nAs we used the information of cell groups in parameter estimation, so we can simulate the data with cell groups.\nsimulate_result \u0026lt;- simmethods::SRTsim_simulation( parameters = estimate_result$estimate_result, other_prior = NULL, return_format = \u0026quot;list\u0026quot;, seed = 111 ) # nSpots: 3492 # nGenes: 1056 # nGroups: 2 cell_meta \u0026lt;- simulate_result$simulate_result$col_meta head(cell_meta) # x y group cell_name # AAACAAGTATCTCCCA-1 27 38 B AAACAAGTATCTCCCA-1 # AAACACCAATAACTGC-1 110 29 B AAACACCAATAACTGC-1 # AAACAGGGTCTATATT-1 116 41 B AAACAGGGTCTATATT-1 # AAACATTTCCCGGATT-1 32 27 A AAACATTTCCCGGATT-1 # AAACCCGAACGAAATC-1 14 43 B AAACCCGAACGAAATC-1 # AAACCGGAAATGTTAA-1 5 34 B AAACCGGAAATGTTAA-1 The x and y columns represent the spatial positions of cells (spots), and the group column denotes the group labels of cells.\nCheck the group labels of cells:\ntable(cell_meta$group) # # A B # 1051 2441 Visualize the spatial spots:\nlibrary(ggplot2) location \u0026lt;- simulate_result$simulate_result$col_meta p \u0026lt;- ggplot(location, aes(x = x, y = y))+ geom_point(aes(color = group))+ theme(panel.grid = element_blank(), axis.title = element_blank(), axis.text = element_blank(), legend.position = \u0026quot;bottom\u0026quot;) p "
},
{
	"uri": "/references/methods/29-prosstt/",
	"title": "PROSSTT",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets with cell trajectory using PROSSTT Datasets with default parameters Determin the number of cells and genes Visualization Here PROSSTT method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data estimate_result \u0026lt;- simmethods::PROSSTT_estimation( ref_data = ref_data, verbose = T, seed = 10 ) # Estimating parameters using PROSSTT # Loading required package: amap # Computing nearest neighbor graph # Computing SNN # Your data has 3 groups See the result:\nestimate_result[[\u0026quot;estimate_result\u0026quot;]][[\u0026quot;newick_tree\u0026quot;]] # [1] \u0026quot;(group3:372.624762582395,(group1:82.620878305447,group2:82.620878305447):372.624762582395);\u0026quot; You can obtain a tree structure of Newick format where cells can be sampled from to generate the datasets with trajectory. Then the hierarchical clustering is used to obtain the relationship between different groups. If no group information is provided like above codes, the groups or clusters are determined by Seurat pipeline.\nUsers can also input the group information of cells:\ngroup \u0026lt;- as.numeric(simmethods::group_condition) estimate_result \u0026lt;- simmethods::PROSSTT_estimation( ref_data = ref_data, other_prior = list(group.condition = group), verbose = T, seed = 10 ) # Estimating parameters using PROSSTT Simulating datasets with cell trajectory using PROSSTT After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Visualization Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::PROSSTT_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], other_prior = NULL, return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 Determin the number of cells and genes In PROSSTT, we can set nCells and nGenes to specify the number of cells and genes.\nHere, we simulate a new dataset with 1000 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::PROSSTT_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 1000, nGenes = 1000), seed = 111 ) # nCells: 1000 # nGenes: 1000 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 1000 Visualization Make sure that you have already installed several R packages:\nif(!requireNamespace(\u0026quot;dynwrap\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynwrap\u0026quot;)} if(!requireNamespace(\u0026quot;dyndimred\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dyndimred\u0026quot;)} if(!requireNamespace(\u0026quot;dynplot\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynplot\u0026quot;)} if(!requireNamespace(\u0026quot;tislingshot\u0026quot;, quietly = TRUE)){devtools::install_github(\u0026quot;dynverse/ti_slingshot/package/\u0026quot;)} First we should wrap the data into a standard object:\ndyn_object \u0026lt;- dynwrap::wrap_expression(counts = t(result), expression = log2(t(result) + 1)) Next, we infer the trajectory using SlingShot which has been proved to be the most best method to do this:\nmodel \u0026lt;- dynwrap::infer_trajectory(dataset = dyn_object, method = tislingshot::ti_slingshot(), parameters = NULL, give_priors = NULL, seed = 111, verbose = TRUE) # Executing \u0026#39;slingshot\u0026#39; on \u0026#39;20230816_111806__data_wrapper__qIJvL2H1mS\u0026#39; # With parameters: list(cluster_method = \u0026quot;pam\u0026quot;, ndim = 20L, shrink = 1L, reweight = TRUE, reassign = TRUE, thresh = 0.001, maxit = 10L, stretch = 2L, smoother = \u0026quot;smooth.spline\u0026quot;, shrink.method = \u0026quot;cosine\u0026quot;) # inputs: expression # priors : # Using full covariance matrix Finally, we can plot the trajectory after performing dimensionality reduction:\ndimred \u0026lt;- dyndimred::dimred_umap(dyn_object$expression) dynplot::plot_dimred(model, dimred = dimred) # Coloring by milestone # Using milestone_percentages from trajectory For more details about trajectory inference and visualization, please check dynverse.\n"
},
{
	"uri": "/references/methods/30-tedsim/",
	"title": "TedSim",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets with cell trajectory using TedSim Datasets with default parameters Determin the number of cells and genes Visualization Here TedSim method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data estimate_result \u0026lt;- simmethods::TedSim_estimation( ref_data = ref_data, verbose = T, seed = 10 ) # The number of cells is not the power of 2, and we will synthesize some extra cells base on your data... # Performing k-means and determin the best number of clusters... # Add grouping to data... # Synthesize fake cells... # Add the synthesized data to the real data... # Done # Loading required package: amap # Estimating parameters using TedSim TedSim can only simulate the dataset where the cell number is the power of 2, so if the reference data does not meet the requirement, the procedure will synthesize extra fake cells to achive this goal.\nUsers can also input the group information of cells and the k-means will not be used:\ngroup \u0026lt;- as.numeric(simmethods::group_condition) estimate_result \u0026lt;- simmethods::TedSim_estimation( ref_data = ref_data, other_prior = list(group.condition = group), verbose = T, seed = 10 ) # The number of cells is not the power of 2, and we will synthesize some extra cells base on your data... # Add grouping to data... # Synthesize fake cells... # Add the synthesized data to the real data... # Done # Estimating parameters using TedSim Simulating datasets with cell trajectory using TedSim After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of genes Visualization Datasets with default parameters The reference data contains 256 cells (160 real cells and 96 fake cells) and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::TedSim_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], other_prior = NULL, return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 256 # nGenes: 4000 # Warning in cbind(...): number of rows of result is not a multiple of vector # length (arg 3) SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 256 Determin the number of cells and genes In TedSim, we can set nGenes to specify the number of genes.\nHere, we simulate a new dataset with 1000 genes:\nsimulate_result \u0026lt;- simmethods::TedSim_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nGenes = 1000), seed = 111 ) # nCells: 256 # nGenes: 1000 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 256 Visualization Make sure that you have already installed several R packages:\nif(!requireNamespace(\u0026quot;dynwrap\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynwrap\u0026quot;)} if(!requireNamespace(\u0026quot;dyndimred\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dyndimred\u0026quot;)} if(!requireNamespace(\u0026quot;dynplot\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynplot\u0026quot;)} if(!requireNamespace(\u0026quot;tislingshot\u0026quot;, quietly = TRUE)){devtools::install_github(\u0026quot;dynverse/ti_slingshot/package/\u0026quot;)} First we should wrap the data into a standard object:\ndyn_object \u0026lt;- dynwrap::wrap_expression(counts = t(result), expression = log2(t(result) + 1)) Next, we infer the trajectory using SlingShot which has been proved to be the most best method to do this:\nmodel \u0026lt;- dynwrap::infer_trajectory(dataset = dyn_object, method = tislingshot::ti_slingshot(), parameters = NULL, give_priors = NULL, seed = 111, verbose = TRUE) # Executing \u0026#39;slingshot\u0026#39; on \u0026#39;20230816_112206__data_wrapper__RdESls1DEF\u0026#39; # With parameters: list(cluster_method = \u0026quot;pam\u0026quot;, ndim = 20L, shrink = 1L, reweight = TRUE, reassign = TRUE, thresh = 0.001, maxit = 10L, stretch = 2L, smoother = \u0026quot;smooth.spline\u0026quot;, shrink.method = \u0026quot;cosine\u0026quot;) # inputs: expression # priors : # Using full covariance matrix Finally, we can plot the trajectory after performing dimensionality reduction:\ndimred \u0026lt;- dyndimred::dimred_umap(dyn_object$expression) dynplot::plot_dimred(model, dimred = dimred) # Coloring by milestone # Using milestone_percentages from trajectory For more details about trajectory inference and visualization, please check dynverse.\n"
},
{
	"uri": "/references/methods/31-scmultisim/",
	"title": "scMultiSim",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using scMultiSim Datasets with default parameters Determin the number of cells and genes Simulate groups Simulate batches Simulate cellular differential trajectory Here scMultiSim method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data estimate_result \u0026lt;- simmethods::scMultiSim_estimation( ref_data = ref_data, verbose = T, seed = 10 ) # Estimating parameters using scMultiSim # Loading required package: amap # Computing nearest neighbor graph # Computing SNN # Your data has 3 groups Users can also input the group information of cells:\ngroup \u0026lt;- as.numeric(simmethods::group_condition) estimate_result \u0026lt;- simmethods::scMultiSim_estimation( ref_data = ref_data, other_prior = list(group.condition = group), verbose = T, seed = 10 ) # Estimating parameters using scMultiSim The estimation result contains an object with phylo data structure:\nplot(estimate_result[[\u0026quot;estimate_result\u0026quot;]][[\u0026quot;phylo\u0026quot;]]) Simulating datasets using scMultiSim Datasets with default parameters Determin the number of cells and genes Simulate groups Simulate batches Simulate cellular differential trajectory Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::scMultiSim_simulation( parameters = estimate_result$estimate_result, other_prior = NULL, return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 2 # nBatches: 1 # Time spent: 0.17 mins # Adding experimental noise... # 50..100..150..Using atac_counts # Time spent: 0.54 mins SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 2 columns # cell_name group # \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; # cell1 cell1 group1 # cell2 cell2 group1 # cell3 cell3 group1 # cell4 cell4 group2 # cell5 cell5 group2 # cell6 cell6 group2 Determin the number of cells and genes simulate_result \u0026lt;- simmethods::scMultiSim_simulation( parameters = estimate_result$estimate_result, other_prior = list(nCells = 500, nGenes = 1000), return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 2 # nBatches: 1 # Time spent: 0.15 mins # Adding experimental noise... # 50..100..150..200..250..300..350..400..450..500..Using atac_counts # Time spent: 0.45 mins SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 1000 500 Simulate groups In scMultiSim, we can not set nGroups directly and should set prob.group instead. For example, if we want to simulate 2 groups, we can type other_prior = list(prob.group = c(0.5, 0.5)). Note that the sum of prob.group numeric vector must equal to 1, so we can also set prob.group = c(0.3, 0.7).\nThe group number should be equal to that used or detected in the estimation step, otherwise the error may occur.\nIn addtion, if we want to simulate three or more groups, we should obey the rules:\nThe length of prob.group vector must always equal to the number of groups. The sum of prob.group numeric vector must equal to 1. For demonstration, we will simulate two groups using the learned parameters.\nsimulate_result \u0026lt;- simmethods::scMultiSim_simulation( parameters = estimate_result$estimate_result, other_prior = list(prob.group = c(0.4, 0.6)), return_format = \u0026quot;list\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 2 # nBatches: 1 # Time spent: 0.18 mins # Adding experimental noise... # 50..100..150..Using atac_counts # Time spent: 0.56 mins col_data \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(col_data$group) # # group1 group2 # 64 96 Simulate batches In scMultiSim, we can set nBatches directly to simulate cell batches.\nFor demonstration, we will simulate two batches.\nsimulate_result \u0026lt;- simmethods::scMultiSim_simulation( parameters = estimate_result$estimate_result, other_prior = list(nBatches = 2), return_format = \u0026quot;list\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 2 # nBatches: 2 # Time spent: 0.17 mins # Adding experimental noise... # 50..100..150..Using atac_counts # Time spent: 0.55 mins # Adding batch effects... ## cell information col_data \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(col_data$batch) # # Batch1 Batch2 # 82 78 Simulate cellular differential trajectory The parameter estimation step is the same as that demonstrated above. If you want to simulate datasets with trajectory, you should specify the parameter traj in other_prior to TRUE.\nsimulate_result \u0026lt;- simmethods::scMultiSim_simulation( parameters = estimate_result$estimate_result, other_prior = list(traj = TRUE), return_format = \u0026quot;list\u0026quot;, seed = 111 ) # Simulating datasets with trajectory.../n # nCells: 160 # nGenes: 4000 # nGroups: 2 # nBatches: 1 # Time spent: 0.16 mins # Adding experimental noise... # 50..100..150..Using atac_counts # Time spent: 0.99 mins Before visualization, Make sure that you have already installed several R packages:\nif(!requireNamespace(\u0026quot;dynwrap\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynwrap\u0026quot;)} if(!requireNamespace(\u0026quot;dyndimred\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dyndimred\u0026quot;)} if(!requireNamespace(\u0026quot;dynplot\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynplot\u0026quot;)} if(!requireNamespace(\u0026quot;tislingshot\u0026quot;, quietly = TRUE)){devtools::install_github(\u0026quot;dynverse/ti_slingshot/package/\u0026quot;)} First we should wrap the data into a standard object:\ndata \u0026lt;- simulate_result$simulate_result$count_data dyn_object \u0026lt;- dynwrap::wrap_expression(counts = t(data), expression = log2(t(data) + 1)) Next, we infer the trajectory using SlingShot which has been proved to be the most best method to do this:\nmodel \u0026lt;- dynwrap::infer_trajectory(dataset = dyn_object, method = tislingshot::ti_slingshot(), parameters = NULL, give_priors = NULL, seed = 111, verbose = TRUE) # Executing \u0026#39;slingshot\u0026#39; on \u0026#39;20230903_172409__data_wrapper__Wad2hj4sH8\u0026#39; # With parameters: list(cluster_method = \u0026quot;pam\u0026quot;, ndim = 20L, shrink = 1L, reweight = TRUE, reassign = TRUE, thresh = 0.001, maxit = 10L, stretch = 2L, smoother = \u0026quot;smooth.spline\u0026quot;, shrink.method = \u0026quot;cosine\u0026quot;) # inputs: expression # priors : # Using full covariance matrix Finally, we can plot the trajectory after performing dimensionality reduction:\ndimred \u0026lt;- dyndimred::dimred_umap(dyn_object$expression) dynplot::plot_dimred(model, dimred = dimred) # Coloring by milestone # Using milestone_percentages from trajectory For more details about trajectory inference and visualization, please check dynverse.\n"
},
{
	"uri": "/references/methods/32-dyntoy/",
	"title": "dyntoy",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets with cell trajectory using dyntoy Datasets with default parameters Determin the number of cells and genes Visualization Here dyntoy method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data To simulate trajectory datasets using dyntoy, we first performe trajectory inference analysis to the real data. If no group information is provided, the k-means algorithm is used to determine the number of clusters(groups) that the real data contains.\nestimate_result \u0026lt;- simmethods::dyntoy_estimation( ref_data = ref_data, verbose = T, seed = 10 ) # Performing k-means and determin the best number of clusters... # Add grouping to data... # Estimating parameters using dyntoy # Executing \u0026#39;slingshot\u0026#39; on \u0026#39;20230816_112447__data_wrapper__Up1tJGIOUk\u0026#39; # With parameters: list(cluster_method = \u0026quot;pam\u0026quot;, ndim = 20L, shrink = 1L, reweight = TRUE, reassign = TRUE, thresh = 0.001, maxit = 10L, stretch = 2L, smoother = \u0026quot;smooth.spline\u0026quot;, shrink.method = \u0026quot;cosine\u0026quot;) # inputs: expression # priors : # Using full covariance matrix Users can also input the group information of cells and the k-means will not be used:\ngroup \u0026lt;- as.numeric(simmethods::group_condition) estimate_result \u0026lt;- simmethods::dyntoy_estimation( ref_data = ref_data, other_prior = list(group.condition = group), verbose = T, seed = 10 ) # Add grouping to data... # Estimating parameters using dyntoy # Executing \u0026#39;slingshot\u0026#39; on \u0026#39;20230816_112451__data_wrapper__Kr1TdrsxL0\u0026#39; # With parameters: list(cluster_method = \u0026quot;pam\u0026quot;, ndim = 20L, shrink = 1L, reweight = TRUE, reassign = TRUE, thresh = 0.001, maxit = 10L, stretch = 2L, smoother = \u0026quot;smooth.spline\u0026quot;, shrink.method = \u0026quot;cosine\u0026quot;) # inputs: expression # priors : # Using full covariance matrix Simulating datasets with cell trajectory using dyntoy After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Visualization Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::dyntoy_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], other_prior = NULL, return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # de.prob: 0.1 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 Determin the number of cells and genes In dyntoy, we can set nCells and nGenes to specify the number of cells and genes.\nHere, we simulate a new dataset with 1000 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::dyntoy_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 1000, nGenes = 1000), seed = 111 ) # nCells: 1000 # nGenes: 1000 # de.prob: 0.1 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 1000 Visualization Make sure that you have already installed several R packages:\nif(!requireNamespace(\u0026quot;dynwrap\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynwrap\u0026quot;)} if(!requireNamespace(\u0026quot;dyndimred\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dyndimred\u0026quot;)} if(!requireNamespace(\u0026quot;dynplot\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynplot\u0026quot;)} if(!requireNamespace(\u0026quot;tislingshot\u0026quot;, quietly = TRUE)){devtools::install_github(\u0026quot;dynverse/ti_slingshot/package/\u0026quot;)} First we should wrap the data into a standard object:\ndyn_object \u0026lt;- dynwrap::wrap_expression(counts = t(result), expression = log2(t(result) + 1)) Next, we infer the trajectory using SlingShot which has been proved to be the most best method to do this:\nmodel \u0026lt;- dynwrap::infer_trajectory(dataset = dyn_object, method = tislingshot::ti_slingshot(), parameters = NULL, give_priors = NULL, seed = 111, verbose = TRUE) # Executing \u0026#39;slingshot\u0026#39; on \u0026#39;20230816_112514__data_wrapper__EuubW5InDz\u0026#39; # With parameters: list(cluster_method = \u0026quot;pam\u0026quot;, ndim = 20L, shrink = 1L, reweight = TRUE, reassign = TRUE, thresh = 0.001, maxit = 10L, stretch = 2L, smoother = \u0026quot;smooth.spline\u0026quot;, shrink.method = \u0026quot;cosine\u0026quot;) # inputs: expression # priors : # Using full covariance matrix Finally, we can plot the trajectory after performing dimensionality reduction:\ndimred \u0026lt;- dyndimred::dimred_umap(dyn_object$expression) dynplot::plot_dimred(model, dimred = dimred) # Coloring by milestone # Using milestone_percentages from trajectory For more details about trajectory inference and visualization, please check dynverse.\n"
},
{
	"uri": "/references/methods/33-dyngen/",
	"title": "dyngen",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Default estimation Information of cell groups Simulating datasets using dyngen Datasets with default parameters Determin the number of cells and genes Here dyngen method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real.\nlibrary(simmethods) # Load data (downloaded from https://zenodo.org/record/8251596/files/data82_cellbench-SC1_luyitian.rds?download=1) data \u0026lt;- readRDS(\u0026quot;../../../../preprocessed_data/data82_cellbench-SC1_luyitian.rds\u0026quot;) ref_data \u0026lt;- t(as.matrix(data$data$counts)) Default estimation estimate_result \u0026lt;- simmethods::dyngen_estimation( ref_data = ref_data, other_prior = NULL, verbose = TRUE, seed = 111 ) # Performing k-means and determin the best number of clusters... # Add grouping to data... # Estimating parameters using dyngen # Executing \u0026#39;slingshot\u0026#39; on \u0026#39;20230924_105246__data_wrapper__p1tJGIOUko\u0026#39; # With parameters: list(cluster_method = \u0026quot;pam\u0026quot;, ndim = 20L, shrink = 1L, reweight = TRUE, reassign = TRUE, thresh = 0.001, maxit = 10L, stretch = 2L, smoother = \u0026quot;smooth.spline\u0026quot;, shrink.method = \u0026quot;cosine\u0026quot;) # inputs: expression # priors : # Using full covariance matrix Information of cell groups If the information of cell groups is available, you can use another way to estimate the parameters.\n## cell groups group_condition \u0026lt;- as.numeric(data$data_info$group_condition) estimate_result \u0026lt;- simmethods::dyngen_estimation( ref_data = ref_data, other_prior = list(group.condition = group_condition), verbose = TRUE, seed = 111 ) # Add grouping to data... # Estimating parameters using dyngen # Executing \u0026#39;slingshot\u0026#39; on \u0026#39;20230924_105250__data_wrapper__lC7s9gqYTq\u0026#39; # With parameters: list(cluster_method = \u0026quot;pam\u0026quot;, ndim = 20L, shrink = 1L, reweight = TRUE, reassign = TRUE, thresh = 0.001, maxit = 10L, stretch = 2L, smoother = \u0026quot;smooth.spline\u0026quot;, shrink.method = \u0026quot;cosine\u0026quot;) # inputs: expression # priors : # Using full covariance matrix Simulating datasets using dyngen After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Datasets with default parameters The reference data contains 157 cells and 1770 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::dyngen_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 154 # nGenes: 1770 # Generating TF network # Sampling feature network from real network # Generating kinetics for 1770 features # Generating formulae # Generating gold standard mod changes # Precompiling reactions for gold standard # Running gold simulations # | | 0 % elapsed=00s |======== | 14% elapsed=00s, remaining~01s |=============== | 29% elapsed=00s, remaining~01s |====================== | 43% elapsed=00s, remaining~01s |============================= | 57% elapsed=01s, remaining~00s |==================================== | 71% elapsed=01s, remaining~00s |=========================================== | 86% elapsed=01s, remaining~00s |==================================================| 100% elapsed=01s, remaining~00s # Precompiling reactions for simulations # Running 1 simulations # Mapping simulations to gold standard # Performing dimred # Simulating experiment # Wrapping dataset as list # as(\u0026lt;dgeMatrix\u0026gt;, \u0026quot;dgCMatrix\u0026quot;) is deprecated since Matrix 1.5-0; do as(., \u0026quot;CsparseMatrix\u0026quot;) instead SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 1770 154 Determin the number of cells and genes In dyngen, we can set nCells and nGenes parameters to specify the number of cells and genes that need to be simulated. Here, we simulate a new dataset with 100 cells and 100 genes:\nsimulate_result \u0026lt;- simmethods::dyngen_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 100, nGenes = 100), seed = 111 ) # nCells: 100 # nGenes: 100 # Generating TF network # Sampling feature network from real network # Generating kinetics for 100 features # Generating formulae # Generating gold standard mod changes # Precompiling reactions for gold standard # Running gold simulations # | | 0 % elapsed=00s |======== | 14% elapsed=00s, remaining~01s |=============== | 29% elapsed=00s, remaining~01s |====================== | 43% elapsed=00s, remaining~01s |============================= | 57% elapsed=01s, remaining~00s |==================================== | 71% elapsed=01s, remaining~00s |=========================================== | 86% elapsed=01s, remaining~00s |==================================================| 100% elapsed=01s, remaining~00s # Precompiling reactions for simulations # Running 1 simulations # Mapping simulations to gold standard # Performing dimred # Simulating experiment # Wrapping dataset as list result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 100 100 Dyngen may need a large amount of memory when simulating new datasets, so users should always focus on your occupied computational resources.\n"
},
{
	"uri": "/references/methods/34-symsim/",
	"title": "SymSim",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets with cell trajectory using SymSim Datasets with default parameters Determin the number of cells and genes Visualization Here SymSim method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data estimate_result \u0026lt;- simmethods::SymSim_estimation( ref_data = ref_data, verbose = T, seed = 10 ) # Estimating parameters using SymSim # Loading required package: amap # Computing nearest neighbor graph # Computing SNN # Your data has 3 groups Users can also input the group information of cells:\ngroup \u0026lt;- as.numeric(simmethods::group_condition) estimate_result \u0026lt;- simmethods::SymSim_estimation( ref_data = ref_data, other_prior = list(group.condition = group), verbose = T, seed = 10 ) # Estimating parameters using SymSim Simulating datasets with cell trajectory using SymSim After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Visualization Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::SymSim_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], other_prior = NULL, return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 Determin the number of cells and genes In SymSim, we can set nCells and nGenes to specify the number of cells and genes.\nHere, we simulate a new dataset with 2000 cells and 2000 genes:\nsimulate_result \u0026lt;- simmethods::SymSim_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 2000, nGenes = 2000), seed = 111 ) # nCells: 2000 # nGenes: 2000 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 2000 2000 Visualization Make sure that you have already installed several R packages:\nif(!requireNamespace(\u0026quot;dynwrap\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynwrap\u0026quot;)} if(!requireNamespace(\u0026quot;dyndimred\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dyndimred\u0026quot;)} if(!requireNamespace(\u0026quot;dynplot\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynplot\u0026quot;)} if(!requireNamespace(\u0026quot;tislingshot\u0026quot;, quietly = TRUE)){devtools::install_github(\u0026quot;dynverse/ti_slingshot/package/\u0026quot;)} First we should wrap the data into a standard object:\ndyn_object \u0026lt;- dynwrap::wrap_expression(counts = t(result), expression = log2(t(result) + 1)) Next, we infer the trajectory using SlingShot which has been proved to be the most best method to do this:\nmodel \u0026lt;- dynwrap::infer_trajectory(dataset = dyn_object, method = tislingshot::ti_slingshot(), parameters = NULL, give_priors = NULL, seed = 111, verbose = TRUE) # Executing \u0026#39;slingshot\u0026#39; on \u0026#39;20230816_112611__data_wrapper__huyoq738bs\u0026#39; # With parameters: list(cluster_method = \u0026quot;pam\u0026quot;, ndim = 20L, shrink = 1L, reweight = TRUE, reassign = TRUE, thresh = 0.001, maxit = 10L, stretch = 2L, smoother = \u0026quot;smooth.spline\u0026quot;, shrink.method = \u0026quot;cosine\u0026quot;) # inputs: expression # priors : # Using full covariance matrix Finally, we can plot the trajectory after performing dimensionality reduction:\ndimred \u0026lt;- dyndimred::dimred_umap(dyn_object$expression) dynplot::plot_dimred(model, dimred = dimred) # Coloring by milestone # Using milestone_percentages from trajectory For more details about trajectory inference and visualization, please check dynverse.\n"
},
{
	"uri": "/references/methods/35-velosim/",
	"title": "VeloSim",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets with cell trajectory using VeloSim Datasets with default parameters Determin the number of cells and genes Visualization Here VeloSim method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data estimate_result \u0026lt;- simmethods::VeloSim_estimation( ref_data = ref_data, verbose = T, seed = 10 ) # Estimating parameters using VeloSim # Loading required package: amap # Computing nearest neighbor graph # Computing SNN # Your data has 3 groups Users can also input the group information of cells:\ngroup \u0026lt;- as.numeric(simmethods::group_condition) estimate_result \u0026lt;- simmethods::VeloSim_estimation( ref_data = ref_data, other_prior = list(group.condition = group), verbose = T, seed = 10 ) # Estimating parameters using VeloSim Simulating datasets with cell trajectory using VeloSim After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Visualization Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::VeloSim_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], other_prior = NULL, return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 Determin the number of cells and genes In VeloSim, we can set nCells and nGenes to specify the number of cells and genes.\nHere, we simulate a new dataset with 200 cells and 2000 genes:\nsimulate_result \u0026lt;- simmethods::VeloSim_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 200, nGenes = 2000), seed = 111 ) # nCells: 200 # nGenes: 2000 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 2000 200 Visualization Make sure that you have already installed several R packages:\nif(!requireNamespace(\u0026quot;dynwrap\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynwrap\u0026quot;)} if(!requireNamespace(\u0026quot;dyndimred\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dyndimred\u0026quot;)} if(!requireNamespace(\u0026quot;dynplot\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynplot\u0026quot;)} if(!requireNamespace(\u0026quot;tislingshot\u0026quot;, quietly = TRUE)){devtools::install_github(\u0026quot;dynverse/ti_slingshot/package/\u0026quot;)} First we should wrap the data into a standard object:\ndyn_object \u0026lt;- dynwrap::wrap_expression(counts = t(result), expression = log2(t(result) + 1)) Next, we infer the trajectory using SlingShot which has been proved to be the most best method to do this:\nmodel \u0026lt;- dynwrap::infer_trajectory(dataset = dyn_object, method = tislingshot::ti_slingshot(), parameters = NULL, give_priors = NULL, seed = 111, verbose = TRUE) # Executing \u0026#39;slingshot\u0026#39; on \u0026#39;20230816_112827__data_wrapper__zj4D9ACXnS\u0026#39; # With parameters: list(cluster_method = \u0026quot;pam\u0026quot;, ndim = 20L, shrink = 1L, reweight = TRUE, reassign = TRUE, thresh = 0.001, maxit = 10L, stretch = 2L, smoother = \u0026quot;smooth.spline\u0026quot;, shrink.method = \u0026quot;cosine\u0026quot;) # inputs: expression # priors : # Using full covariance matrix Finally, we can plot the trajectory after performing dimensionality reduction:\ndimred \u0026lt;- dyndimred::dimred_umap(dyn_object$expression) dynplot::plot_dimred(model, dimred = dimred) # Coloring by milestone # Using milestone_percentages from trajectory For more details about trajectory inference and visualization, please check dynverse.\n"
},
{
	"uri": "/references/methods/36-mfa/",
	"title": "MFA",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets with cell trajectory using MFA Datasets with default parameters Determin the number of cells and genes Visualization Here MFA method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data MAF can only simulate datasets with bifurcation trajectory, so the estimation step may fail due to the intrinsic characteristics of real data.\nestimate_result \u0026lt;- simmethods::MFA_estimation( ref_data = ref_data, verbose = T, seed = 10 ) # Estimating parameters using MFA Simulating datasets with cell trajectory using MFA After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Visualization Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::MFA_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], other_prior = NULL, return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 Determin the number of cells and genes In MFA, we can set nCells and nGenes to specify the number of cells and genes.\nHere, we simulate a new dataset with 2000 cells and 2000 genes:\nsimulate_result \u0026lt;- simmethods::MFA_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 2000, nGenes = 2000), seed = 111 ) # nCells: 2000 # nGenes: 2000 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 2000 2000 Visualization Make sure that you have already installed several R packages:\nif(!requireNamespace(\u0026quot;dynwrap\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynwrap\u0026quot;)} if(!requireNamespace(\u0026quot;dyndimred\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dyndimred\u0026quot;)} if(!requireNamespace(\u0026quot;dynplot\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynplot\u0026quot;)} if(!requireNamespace(\u0026quot;tislingshot\u0026quot;, quietly = TRUE)){devtools::install_github(\u0026quot;dynverse/ti_slingshot/package/\u0026quot;)} First we should wrap the data into a standard object:\ndyn_object \u0026lt;- dynwrap::wrap_expression(counts = t(result), expression = log2(t(result) + 1)) Next, we infer the trajectory using SlingShot which has been proved to be the most best method to do this:\nmodel \u0026lt;- dynwrap::infer_trajectory(dataset = dyn_object, method = tislingshot::ti_slingshot(), parameters = NULL, give_priors = NULL, seed = 111, verbose = TRUE) # Executing \u0026#39;slingshot\u0026#39; on \u0026#39;20230816_112844__data_wrapper__XqXBjiGrL6\u0026#39; # With parameters: list(cluster_method = \u0026quot;pam\u0026quot;, ndim = 20L, shrink = 1L, reweight = TRUE, reassign = TRUE, thresh = 0.001, maxit = 10L, stretch = 2L, smoother = \u0026quot;smooth.spline\u0026quot;, shrink.method = \u0026quot;cosine\u0026quot;) # inputs: expression # priors : # Using full covariance matrix Finally, we can plot the trajectory after performing dimensionality reduction:\ndimred \u0026lt;- dyndimred::dimred_umap(dyn_object$expression) dynplot::plot_dimred(model, dimred = dimred) # Coloring by milestone # Using milestone_percentages from trajectory For more details about trajectory inference and visualization, please check dynverse.\n"
},
{
	"uri": "/references/methods/37-phenopath/",
	"title": "phenopath",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets with cell trajectory using phenopath Datasets with default parameters Determin the number of cells and genes Visualization Here phenopath method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data MAF can only simulate datasets with bifurcation trajectory, so the estimation step may fail due to the intrinsic characteristics of real data.\nestimate_result \u0026lt;- simmethods::phenopath_estimation( ref_data = ref_data, verbose = T, seed = 10 ) # Estimating parameters using phenopath Simulating datasets with cell trajectory using phenopath After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Visualization Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::phenopath_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], other_prior = NULL, return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 Determin the number of cells and genes In phenopath, we can set nCells and nGenes to specify the number of cells and genes.\nHere, we simulate a new dataset with 2000 cells and 2000 genes:\nsimulate_result \u0026lt;- simmethods::phenopath_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 2000, nGenes = 2000), seed = 11 ) # nCells: 2000 # nGenes: 2000 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 2000 2000 Visualization Make sure that you have already installed several R packages:\nif(!requireNamespace(\u0026quot;dynwrap\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynwrap\u0026quot;)} if(!requireNamespace(\u0026quot;dyndimred\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dyndimred\u0026quot;)} if(!requireNamespace(\u0026quot;dynplot\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynplot\u0026quot;)} if(!requireNamespace(\u0026quot;tislingshot\u0026quot;, quietly = TRUE)){devtools::install_github(\u0026quot;dynverse/ti_slingshot/package/\u0026quot;)} First we should wrap the data into a standard object:\ndyn_object \u0026lt;- dynwrap::wrap_expression(counts = t(result), expression = log2(t(result) + 1)) Next, we infer the trajectory using SlingShot which has been proved to be the most best method to do this:\nmodel \u0026lt;- dynwrap::infer_trajectory(dataset = dyn_object, method = tislingshot::ti_slingshot(), parameters = NULL, give_priors = NULL, seed = 111, verbose = TRUE) However, the trajectory inference failed because of the inference method itself and we can choose MST method to try again.\nOpen your Docker Desktop and check your Docker execution status. If you do not install Docker, please turn to Docker homepage.\ndynwrap::test_docker_installation(detailed = TRUE) # ‚úî Docker is installed # ‚úî Docker daemon is running # ‚úî Docker is at correct version (\u0026gt;1.0): 1.41 # ‚úî Docker is in linux mode # ‚úî Docker can pull images # ‚úî Docker can run image # ‚úî Docker can mount temporary volumes # ‚úî Docker test successful ----------------------------------------------------------------- # [1] TRUE model \u0026lt;- dynwrap::infer_trajectory(dataset = dyn_object, method = \u0026quot;mst\u0026quot;, parameters = NULL, give_priors = NULL, seed = 111, verbose = FALSE) # Loading required namespace: dynmethods Finally, we can plot the trajectory after performing dimensionality reduction:\ndimred \u0026lt;- dyndimred::dimred_umap(dyn_object$expression) dynplot::plot_dimred(model, dimred = dimred) # Coloring by milestone # Using milestone_percentages from trajectory For more details about trajectory inference and visualization, please check dynverse.\n"
},
{
	"uri": "/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Overview simsite is a web-based reference vignettes for illustrating the usage of simulation methods for single-cell RNA sequencing data.\nIt contains three main sections:\nProgramming usage. All demonstrations and programming environment are in R. It shows a comprehensive pipeline from installing three main R packages (simutils, simmethods and simpipe) or just using simpipeDocker, estimating parameters from real data, simulating different kinds of new datasets and evaluating the simulated datasets.\nOnline usage. It contains some methods that show the best performance and users can simulate new datasets fast and conveniently.\nReferences. simmethods is the core package in our project. We collected 42+ methods and bundled them into a single package. For each method, we have already prepared a detailed vignette for users to learn to use the methods they are interested in.\nQuick start Programming start ‚¨Ö\nInstall R packages or download Docker images ‚¨Ö\nOnline usage start ‚¨Ö\nFeatures A comprehensive collection of simulation methods for single-cell RNA sequencing data.\nA Docker image is provided to help users establish the simulation environment easily and users can use it in local R.\nBoth local programming environment and interactive online tool can be used.\nDetailed vignettes for every simulation methods using simmethods package.\nCitation A comparison of simulation methods for single-cell RNA sequencing data.\nHelp and Issues If you need help or have any issue about our tools and vignettes. Send an email to duohongrui (duohongrui@cqnu.edu.cn) or raise an issue on github.\nNew Methods We are glad to add new simulation methods (especially for simulating spatial transcriptomics data) if some methods are innovative and creative that many users commonly used. If you have the requirements, please tell Hongrui Duo by email (duohongrui@cqnu.edu.cn) or raise an issue for that.\n"
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]