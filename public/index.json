[
{
	"uri": "/programming/",
	"title": "Programming Usage",
	"tags": [],
	"description": "",
	"content": "Programming Usage simpipe provides a pipeline from estimating parameters from real data, simulating new datasets from learned parameters and evaluating new datasets with real data. üë®‚Äçüíªüë®üèª‚Äçüíªüë®üèº‚Äçüíª\nInstallation Estimation Simulation Evaluation "
},
{
	"uri": "/online/1-choose_methods/",
	"title": "Choose Methods",
	"tags": [],
	"description": "",
	"content": " Installation Guide Installation Guide A\ndevtools::install_github(\u0026quot;duohongrui/simpipe\u0026quot;) B\nprint(\u0026quot;Hello World!\u0026quot;) [1] \u0026quot;Hello World!\u0026quot; "
},
{
	"uri": "/programming/1-installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": " Installation from Github Download Docker Image Install Docker Desktop Install simpipeDocker Download simpipe Docker Image There are two ways to install dependencies and set programming environment:\ninstall multiple R packages and dependencies from github, it may take 5-30 mins.\ninstall Docker first and download simpipe Docker image from DockerHub. All manipulations in R can be done by simpipeDoker package.\nInstallation from Github You can install the development version of simutils, simmethods and simpipe from GitHub with:\n# install.packages(\u0026quot;devtools\u0026quot;) devtools::install_github(\u0026quot;duohongrui/simutils\u0026quot;) devtools::install_github(\u0026quot;duohongrui/simmethods\u0026quot;) devtools::install_github(\u0026quot;duohongrui/simpipe\u0026quot;) If you want to use simpipe to simulate datasets with trajectory information, please install tislingshot first by:\ndevtools::install_github(\u0026quot;dynverse/ti_slingshot/package/\u0026quot;) Download Docker Image Install Docker Desktop If you have not installed official Docker Desktop, please click here and follow the instructions to install it. The version of Docker Desktop for Apple Chip is available\nAfter installing Docker, start Docker service, open an R session and type dynwrap::test_docker_installation(detailed = TRUE):\ndynwrap::test_docker_installation(detailed = TRUE) ‚úî Docker is installed ‚úî Docker daemon is running ‚úî Docker is at correct version (\u0026gt;1.0): 1.41 ‚úî Docker is in linux mode ‚úî Docker can pull images ‚úî Docker can run image ‚úî Docker can mount temporary volumes ‚úî Docker test successful ----------------------------------------------------------------- [1] TRUE If it is TRUE in the result, that means Docker is successfully installed.\nInstall simpipeDocker Download simpipe Docker Image Use babelwhale::pull_container(\"duohongrui/simpipe\") command to pull simpipe Docker image in R (it will take 3-10 mins):\n# install.packages(\u0026quot;babelwhale\u0026quot;) babelwhale::pull_container(\u0026quot;duohongrui/simpipe\u0026quot;) Once the image has been downloaded, check the image list:\nbabelwhale::list_docker_images(\u0026quot;duohongrui/simutils_scgan\u0026quot;) ID Repository Tag 1 c3b3d01cde78 duohongrui/simutils_scgan latest Digest 1 sha256:b4ea92956c521753b832960e39e9e76a25aa0138fbc6549304a6a0a59edb2190 CreatedSince CreatedAt Size 1 6 days ago 2022-09-07 23:16:34 +0800 CST 2.37GB Until now, you have successfully established the programming environment üëçüëçüëç. Go to the next page.üëàÔ∏è\n"
},
{
	"uri": "/references/1-methods_list/",
	"title": "Methods List",
	"tags": [],
	"description": "",
	"content": " R Markdown Including Plots Methods R Markdown This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com.\nWhen you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:\nsummary(cars) ## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00 Including Plots You can also embed plots, for example:\nNote that the echo = FALSE parameter was added to the code chunk to prevent printing of the R code that generated the plot.\nMethods Splat\n"
},
{
	"uri": "/references/methods/splat/",
	"title": "Splat",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using Splat Datasets with default parameters Determin the number of cells and genes Simulate two or more groups Simulate two or more batches Simulate more groups and batches simutaniously Return results with different format Here Splat method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data dim(ref_data) # [1] 4000 160 Using simmethods::Splat_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::Splat_estimation(ref_data = ref_data, verbose = T, seed = 10) # Estimating parameters using Splat Simulating datasets using Splat After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Simulate two or more groups Simulate two or more batches Simulate more groups and batches simutaniously Return results with different format Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group and one batch of cells.\nsimulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 3 columns # cell_name batch group # \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; # Cell1 Cell1 Batch1 Group1 # Cell2 Cell2 Batch1 Group1 # Cell3 Cell3 Batch1 Group1 # Cell4 Cell4 Batch1 Group1 # Cell5 Cell5 Batch1 Group1 # Cell6 Cell6 Batch1 Group1 head(rowData(SCE_result)) # DataFrame with 6 rows and 1 column # gene_name # \u0026lt;character\u0026gt; # Gene1 Gene1 # Gene2 Gene2 # Gene3 Gene3 # Gene4 Gene4 # Gene5 Gene5 # Gene6 Gene6 Determin the number of cells and genes In Splat, we can not set nCells directly and should set batchCells instead. For example, if we want to simulate 500 cells, we can type other_prior = list(batchCells = 500). For genes, we can just set nGenes. Here, we simulate a new dataset with 500 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = 500, nGenes = 1000), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 Simulate two or more groups In Splat, we can not set nGroups directly and should set prob.group instead. For example, if we want to simulate 2 groups, we can type other_prior = list(prob.group = c(0.5, 0.5)). Note that the sum of prob.group numeric vector must equal to 1, so we can also set prob.group = c(0.3, 0.7).\nIn addtion, if we want to simulate three or more groups, we should obey the rules:\nThe length of prob.group vector must always equal to the number of groups. The sum of prob.group numeric vector must equal to 1. For demonstration, we will simulate three groups using the learned parameters.\nsimulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = 500, nGenes = 1000, prob.group = c(0.1, 0.3, 0.6)), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 3 # de.prob: 0.1 # nBatches: 1 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$group) # # Group1 Group2 Group3 # 46 156 298 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) ## de.prob = 0.1 # yes # 0.1 We can see that the proportion of differential expressed genes is 0.1 (equals to the default). Next, if we want to know the fold change between two groups, we will do division with the groups that we are interested in.\n## fc between group2 and group1 fc_group1_to_group2 \u0026lt;- gene_info$DEFacGroup2/gene_info$DEFacGroup1 ## fc between group3 and group1 fc_group1_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup1 ## fc between group3 and group2 fc_group2_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup2 Simulate two or more batches In Splat, we can not set nBatches directly and should set batchCells instead. For example, if we want to simulate 2 batches, we can type other_prior = list(batchCells = c(250, 250)). Note that the sum of batchCells numeric vector represents the total number of cells and the length of the vector equals to the number of batches.\nIn addtion, if we want to simulate three or more batches, we should obey the rules:\nThe length of batchCells vector always equals to the number of batches. The sum of batchCells numeric vector represents the total number of cells. For demonstration, we will simulate three batches using the learned parameters.\nsimulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = c(200, 300), nGenes = 1000), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 2 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$batch) # # Batch1 Batch2 # 200 300 Simulate more groups and batches simutaniously As mentioned before, we can set prob.group and batchCells to determine the number of groups and batches and we can also set de.prob to specify the proportion of DEGs. Here, we simulate a dataset with following settings:\n1000 cells 5000 genes three groups with 0.2 proportion of DEGs two batches simulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = c(500, 500), nGenes = 5000, de.prob = 0.2, prob.group = c(0.2, 0.3, 0.5)), seed = 111 ) # nCells: 1000 # nGenes: 5000 # nGroups: 3 # de.prob: 0.2 # nBatches: 2 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 5000 1000 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$batch) # # Batch1 Batch2 # 500 500 table(cell_info$group) # # Group1 Group2 Group3 # 186 321 493 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) # yes # 0.1932 ### fc fc_group2_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup2 Return results with different format In simmethods package, we provide four formats of results to users without data format conversion, including list, SingleCellExperiment, Seurat and h5ad. The previous three formats are compatible with R environment and the last h5ad format is suitable for Python environment and can be imported by scanpy.read_h5ad function.\nlist simulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = c(100, 100), nGenes = 1000, de.prob = 0.1, prob.group = c(0.2, 0.3, 0.5)), seed = 111 ) # nCells: 200 # nGenes: 1000 # nGroups: 3 # de.prob: 0.1 # nBatches: 2 str(simulate_result) # List of 2 # $ simulate_result :List of 3 # ..$ count_data: int [1:1000, 1:200] 16 18 14 40 5 23 9 694 27 21 ... # .. ..- attr(*, \u0026quot;dimnames\u0026quot;)=List of 2 # .. .. ..$ : chr [1:1000] \u0026quot;Gene1\u0026quot; \u0026quot;Gene2\u0026quot; \u0026quot;Gene3\u0026quot; \u0026quot;Gene4\u0026quot; ... # .. .. ..$ : chr [1:200] \u0026quot;Cell1\u0026quot; \u0026quot;Cell2\u0026quot; \u0026quot;Cell3\u0026quot; \u0026quot;Cell4\u0026quot; ... # ..$ col_meta :\u0026#39;data.frame\u0026#39;: 200 obs. of 3 variables: # .. ..$ cell_name: chr [1:200] \u0026quot;Cell1\u0026quot; \u0026quot;Cell2\u0026quot; \u0026quot;Cell3\u0026quot; \u0026quot;Cell4\u0026quot; ... # .. ..$ batch : chr [1:200] \u0026quot;Batch1\u0026quot; \u0026quot;Batch1\u0026quot; \u0026quot;Batch1\u0026quot; \u0026quot;Batch1\u0026quot; ... # .. ..$ group : Factor w/ 3 levels \u0026quot;Group1\u0026quot;,\u0026quot;Group2\u0026quot;,..: 2 2 3 2 3 3 3 2 3 3 ... # ..$ row_meta :\u0026#39;data.frame\u0026#39;: 1000 obs. of 7 variables: # .. ..$ gene_name : chr [1:1000] \u0026quot;Gene1\u0026quot; \u0026quot;Gene2\u0026quot; \u0026quot;Gene3\u0026quot; \u0026quot;Gene4\u0026quot; ... # .. ..$ de_gene : chr [1:1000] \u0026quot;no\u0026quot; \u0026quot;no\u0026quot; \u0026quot;no\u0026quot; \u0026quot;no\u0026quot; ... # .. ..$ BatchFacBatch1: num [1:1000] 0.91 0.977 1.054 1.171 1.002 ... # .. ..$ BatchFacBatch2: num [1:1000] 1.105 0.95 0.76 0.776 0.996 ... # .. ..$ DEFacGroup1 : num [1:1000] 1 1 1 1 1 1 1 1 1 1 ... # .. ..$ DEFacGroup2 : num [1:1000] 1 1 1 1 1 1 1 1 1 1 ... # .. ..$ DEFacGroup3 : num [1:1000] 1 1 1 1 1 1 1 1 1 1 ... # $ simulate_detection:\u0026#39;data.frame\u0026#39;: 1 obs. of 4 variables: # ..$ Function_Call : chr \u0026quot;simulate_result\u0026lt;-splatter::splatSimulate(parameters,method=submethod,verbose=verbose)\u0026quot; # ..$ Elapsed_Time_sec : num 0.165 # ..$ Total_RAM_Used_MiB: num 7 # ..$ Peak_RAM_Used_MiB : num 4779828 counts \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] head(cell_info) # cell_name batch group # Cell1 Cell1 Batch1 Group2 # Cell2 Cell2 Batch1 Group2 # Cell3 Cell3 Batch1 Group3 # Cell4 Cell4 Batch1 Group2 # Cell5 Cell5 Batch1 Group3 # Cell6 Cell6 Batch1 Group3 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] head(gene_info) # gene_name de_gene BatchFacBatch1 BatchFacBatch2 DEFacGroup1 DEFacGroup2 # Gene1 Gene1 no 0.9098860 1.1054169 1 1 # Gene2 Gene2 no 0.9774161 0.9501320 1 1 # Gene3 Gene3 no 1.0541276 0.7597880 1 1 # Gene4 Gene4 no 1.1708139 0.7762219 1 1 # Gene5 Gene5 no 1.0017116 0.9963063 1 1 # Gene6 Gene6 no 0.7654326 1.1497335 1 1 # DEFacGroup3 # Gene1 1 # Gene2 1 # Gene3 1 # Gene4 1 # Gene5 1 # Gene6 1 SingleCellExperiment simulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SingleCellExperiment\u0026quot;, other_prior = list(batchCells = c(100, 100), nGenes = 1000, de.prob = 0.1, prob.group = c(0.2, 0.3, 0.5)), seed = 111 ) # nCells: 200 # nGenes: 1000 # nGroups: 3 # de.prob: 0.1 # nBatches: 2 counts \u0026lt;- counts(simulate_result[[\u0026quot;simulate_result\u0026quot;]]) ## cell information cell_info \u0026lt;- as.data.frame(colData(simulate_result[[\u0026quot;simulate_result\u0026quot;]])) head(cell_info) # cell_name batch group # Cell1 Cell1 Batch1 Group2 # Cell2 Cell2 Batch1 Group2 # Cell3 Cell3 Batch1 Group3 # Cell4 Cell4 Batch1 Group2 # Cell5 Cell5 Batch1 Group3 # Cell6 Cell6 Batch1 Group3 ## gene information gene_info \u0026lt;- as.data.frame(rowData(simulate_result[[\u0026quot;simulate_result\u0026quot;]])) head(gene_info) # gene_name de_gene BatchFacBatch1 BatchFacBatch2 DEFacGroup1 DEFacGroup2 # Gene1 Gene1 no 0.9098860 1.1054169 1 1 # Gene2 Gene2 no 0.9774161 0.9501320 1 1 # Gene3 Gene3 no 1.0541276 0.7597880 1 1 # Gene4 Gene4 no 1.1708139 0.7762219 1 1 # Gene5 Gene5 no 1.0017116 0.9963063 1 1 # Gene6 Gene6 no 0.7654326 1.1497335 1 1 # DEFacGroup3 # Gene1 1 # Gene2 1 # Gene3 1 # Gene4 1 # Gene5 1 # Gene6 1 Seurat simulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;Seurat\u0026quot;, other_prior = list(batchCells = c(100, 100), nGenes = 1000, de.prob = 0.1, prob.group = c(0.2, 0.3, 0.5)), seed = 111 ) # nCells: 200 # nGenes: 1000 # nGroups: 3 # de.prob: 0.1 # nBatches: 2 seurat_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] ## Overview seurat_result # An object of class Seurat # 1000 features across 200 samples within 1 assay # Active assay: originalexp (1000 features, 0 variable features) ## count matrix counts \u0026lt;- seurat_result@assays$originalexp@counts counts[1:10, 1:10] # 10 x 10 sparse Matrix of class \u0026quot;dgCMatrix\u0026quot; # [[ suppressing 10 column names \u0026#39;Cell1\u0026#39;, \u0026#39;Cell2\u0026#39;, \u0026#39;Cell3\u0026#39; ... ]] # # Gene1 16 . 7 5 . . . 11 220 1 # Gene2 18 . 12 10 . 1 1 32 222 2 # Gene3 14 . 4 2 1 . . 23 101 5 # Gene4 40 1 13 18 . 1 1 27 464 5 # Gene5 5 . 2 4 . . . 6 93 2 # Gene6 23 . 6 11 . . . 14 334 5 # Gene7 9 . 13 2 . . . 13 189 . # Gene8 694 7 509 229 26 6 12 774 7932 61 # Gene9 27 . 16 6 2 1 . 12 311 . # Gene10 21 . 13 6 . . . 24 199 5 ## cell information cell_info \u0026lt;- seurat_result@meta.data head(cell_info) # orig.ident nCount_originalexp nFeature_originalexp cell_name batch # Cell1 SeuratProject 65963 975 Cell1 Batch1 # Cell2 SeuratProject 1167 301 Cell2 Batch1 # Cell3 SeuratProject 45665 958 Cell3 Batch1 # Cell4 SeuratProject 26395 911 Cell4 Batch1 # Cell5 SeuratProject 3059 488 Cell5 Batch1 # Cell6 SeuratProject 1998 393 Cell6 Batch1 # group # Cell1 Group2 # Cell2 Group2 # Cell3 Group3 # Cell4 Group2 # Cell5 Group3 # Cell6 Group3 ## gene information gene_info \u0026lt;- seurat_result@assays[[\u0026quot;originalexp\u0026quot;]]@meta.features head(gene_info) # gene_name de_gene BatchFacBatch1 BatchFacBatch2 DEFacGroup1 DEFacGroup2 # Gene1 Gene1 no 0.9098860 1.1054169 1 1 # Gene2 Gene2 no 0.9774161 0.9501320 1 1 # Gene3 Gene3 no 1.0541276 0.7597880 1 1 # Gene4 Gene4 no 1.1708139 0.7762219 1 1 # Gene5 Gene5 no 1.0017116 0.9963063 1 1 # Gene6 Gene6 no 0.7654326 1.1497335 1 1 # DEFacGroup3 # Gene1 1 # Gene2 1 # Gene3 1 # Gene4 1 # Gene5 1 # Gene6 1 h5ad If we select h5ad format, it is not possible to return the result in R, so you can get the path where the h5ad files save to and we can go to the path and read it in Python by scanpy.read_h5ad function (if you have already installed Python and scanpy module).\nsimulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;h5ad\u0026quot;, other_prior = list(batchCells = c(100, 100), nGenes = 1000, de.prob = 0.1, prob.group = c(0.2, 0.3, 0.5)), seed = 111 ) # nCells: 200 # nGenes: 1000 # nGroups: 3 # de.prob: 0.1 # nBatches: 2 # Creating h5Seurat file for version 3.1.5.9900 # Adding counts for originalexp # Adding data for originalexp # No variable features found for originalexp # Adding feature-level metadata for originalexp # Validating h5Seurat file # Adding data from originalexp as X # Transfering meta.features to var # Adding counts from originalexp as raw # Transfering meta.features to raw/var # Transfering meta.data to obs # Your data has been save to /var/folders/1l/xmc98tgx0m37wxtbtwnl6h7c0000gn/T//Rtmp5AFBiZ/20230218170540.h5ad save_path \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;save_path\u0026quot;]] save_path # [1] \u0026quot;/var/folders/1l/xmc98tgx0m37wxtbtwnl6h7c0000gn/T//Rtmp5AFBiZ/20230218170540.h5ad\u0026quot; Now, we can go to the path and check the data. Here, we read the h5ad file in R using reticulate R package (note that Python and scanpy module must have been installed).\n## install.packages(\u0026quot;reticulate\u0026quot;) scanpy \u0026lt;- reticulate::import(\u0026quot;scanpy\u0026quot;) data \u0026lt;- scanpy$read_h5ad(save_path) data ## Read h5ad file successfully # AnnData object with n_obs √ó n_vars = 200 √ó 1000 # obs: \u0026#39;orig.ident\u0026#39;, \u0026#39;nCount_originalexp\u0026#39;, \u0026#39;nFeature_originalexp\u0026#39;, \u0026#39;cell_name\u0026#39;, \u0026#39;batch\u0026#39;, \u0026#39;group\u0026#39; # var: \u0026#39;gene_name\u0026#39;, \u0026#39;de_gene\u0026#39;, \u0026#39;BatchFacBatch1\u0026#39;, \u0026#39;BatchFacBatch2\u0026#39;, \u0026#39;DEFacGroup1\u0026#39;, \u0026#39;DEFacGroup2\u0026#39;, \u0026#39;DEFacGroup3\u0026#39; "
},
{
	"uri": "/online/",
	"title": "Online Usage",
	"tags": [],
	"description": "",
	"content": "Online Usage simsite provides a guide tool for choosing suitable methods and another way for simulating single-cell RNA sequencing data online fast and conveniently. üíªüíªüíª\nChoose methods Simulation online "
},
{
	"uri": "/programming/2-estimation/",
	"title": "Estimation Parameters",
	"tags": [],
	"description": "",
	"content": " Estimation Priors For Estimation Estimation This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com.\nWhen you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:\nsummary(cars) ## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00 Priors For Estimation "
},
{
	"uri": "/references/methods/simple/",
	"title": "Simple",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using Simple Datasets with default parameters Determin the number of cells and genes Here Simple method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data dim(ref_data) # [1] 4000 160 Using simmethods::Simple_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::Simple_estimation(ref_data = ref_data, verbose = T, seed = 10) # Estimating parameters using Simple Simulating datasets using Simple After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::Simple_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 1 column # cell_name # \u0026lt;character\u0026gt; # Cell1 Cell1 # Cell2 Cell2 # Cell3 Cell3 # Cell4 Cell4 # Cell5 Cell5 # Cell6 Cell6 head(rowData(SCE_result)) # DataFrame with 6 rows and 1 column # gene_name # \u0026lt;character\u0026gt; # Gene1 Gene1 # Gene2 Gene2 # Gene3 Gene3 # Gene4 Gene4 # Gene5 Gene5 # Gene6 Gene6 Determin the number of cells and genes Here, we simulate a new dataset with 500 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::Simple_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 500, nGenes = 1000), seed = 111 ) # nCells: 500 # nGenes: 1000 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 "
},
{
	"uri": "/online/2-simulation_online/",
	"title": "Simulation Online",
	"tags": [],
	"description": "",
	"content": " R Markdown Including Plots R Markdown This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com.\nWhen you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:\nsummary(cars) ## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00 Including Plots You can also embed plots, for example:\nNote that the echo = FALSE parameter was added to the code chunk to prevent printing of the R code that generated the plot.\n"
},
{
	"uri": "/references/",
	"title": "References",
	"tags": [],
	"description": "",
	"content": "References simmethods is the core package in the project. It contains 42+ simulation methods for single-cell RNA sequencing data. üìöüìöüìö\nMethods List: overview of all simulation methods and available parameters for every method Vignettes: detailed descriptional usage for every method "
},
{
	"uri": "/references/methods/kersplat/",
	"title": "Kersplat",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using Kersplat Datasets with default parameters Determin the number of cells and genes Here Kersplat method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data dim(ref_data) # [1] 4000 160 Using simmethods::Kersplat_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::Kersplat_estimation(ref_data = ref_data, verbose = T, seed = 10) # Estimating parameters using Kersplat # Warning in newKersplatParams(): The Kersplat simulation is still experimental # and may produce unreliable results. Please try it and report any issues to # https://github.com/Oshlack/splatter/issues. The development version may have # improved features. # Raw: 0.180467969462491 A: 5.24644589782513 B: 1.56749149061734 C: -3.99991188833989 Y: 0.796802242740237 # Warning in kersplatEstBCV(counts, params, verbose): Exponential corrected BCV is # negative.Using linear correction. # Warning in kersplatEstBCV(counts, params, verbose): Linear corrected BCV is # negative.Using existing bcv.common. Simulating datasets using Kersplat After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::Kersplat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 1 column # cell_name # \u0026lt;character\u0026gt; # Cell1 Cell1 # Cell2 Cell2 # Cell3 Cell3 # Cell4 Cell4 # Cell5 Cell5 # Cell6 Cell6 Determin the number of cells and genes Here, we simulate a new dataset with 500 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::Kersplat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 500, nGenes = 1000), seed = 111 ) # nCells: 500 # nGenes: 1000 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 "
},
{
	"uri": "/programming/3-simulation/",
	"title": "Simulation Datasets",
	"tags": [],
	"description": "",
	"content": " R Markdown Including Plots R Markdown This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com.\nWhen you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:\nsummary(cars) ## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00 Including Plots You can also embed plots, for example:\nNote that the echo = FALSE parameter was added to the code chunk to prevent printing of the R code that generated the plot.\n"
},
{
	"uri": "/programming/4-evaluate_datasets/",
	"title": "Evaluation Datasets",
	"tags": [],
	"description": "",
	"content": " R Markdown Including Plots R Markdown This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com.\nWhen you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:\nsummary(cars) ## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00 Including Plots You can also embed plots, for example:\nNote that the echo = FALSE parameter was added to the code chunk to prevent printing of the R code that generated the plot.\n"
},
{
	"uri": "/references/methods/splatpop/",
	"title": "SplatPop",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using SplatPop Datasets with default parameters Determin the number of cells and genes Simulate two or more groups Simulate two or more batches Simulate more groups and batches simutaniously Here SplatPop method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data dim(ref_data) # [1] 4000 160 Using simmethods::SplatPop_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::SplatPop_estimation(ref_data = ref_data, verbose = T, seed = 10) # Estimating parameters using SplatPop # Warning: no function found corresponding to methods exports from \u0026#39;BSgenome\u0026#39; for: # \u0026#39;releaseName\u0026#39; Simulating datasets using SplatPop After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Simulate two or more groups Simulate two or more batches Simulate more groups and batches simutaniously Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group and one batch of cells.\nsimulate_result \u0026lt;- simmethods::SplatPop_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 3 columns # cell_name batch group # \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; # Cell1 Cell1 Batch1 Group1 # Cell2 Cell2 Batch1 Group1 # Cell3 Cell3 Batch1 Group1 # Cell4 Cell4 Batch1 Group1 # Cell5 Cell5 Batch1 Group1 # Cell6 Cell6 Batch1 Group1 head(rowData(SCE_result)) # DataFrame with 6 rows and 1 column # gene_name # \u0026lt;character\u0026gt; # Gene1 Gene1 # Gene2 Gene2 # Gene3 Gene3 # Gene4 Gene4 # Gene5 Gene5 # Gene6 Gene6 Determin the number of cells and genes In SplatPop, we can not set nCells directly and should set batchCells instead. For example, if we want to simulate 500 cells, we can type other_prior = list(batchCells = 500). For genes, we can just set nGenes. Here, we simulate a new dataset with 500 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::SplatPop_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = 500, nGenes = 1000), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 Simulate two or more groups In SplatPop, we can not set nGroups directly and should set prob.group instead. For example, if we want to simulate 2 groups, we can type other_prior = list(prob.group = c(0.5, 0.5)). Note that the sum of prob.group numeric vector must equal to 1, so we can also set prob.group = c(0.3, 0.7).\nIn addtion, if we want to simulate three or more groups, we should obey the rules:\nThe length of prob.group vector must always equal to the number of groups. The sum of prob.group numeric vector must equal to 1. For demonstration, we will simulate three groups using the learned parameters.\nsimulate_result \u0026lt;- simmethods::SplatPop_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = 500, nGenes = 1000, prob.group = c(0.1, 0.3, 0.6)), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 3 # de.prob: 0.1 # nBatches: 1 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$group) # # Group1 Group2 Group3 # 50 150 300 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) ## de.prob = 0.1 # yes # 0.094 We can see that the proportion of differential expressed genes is 0.1 (equals to the default). Next, if we want to know the fold change between two groups, we will do division with the groups that we are interested in.\n## fc between group2 and group1 fc_group1_to_group2 \u0026lt;- gene_info$DEFacGroup2/gene_info$DEFacGroup1 ## fc between group3 and group1 fc_group1_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup1 ## fc between group3 and group2 fc_group2_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup2 Simulate two or more batches In SplatPop, we can not set nBatches directly and should set batchCells instead. For example, if we want to simulate 2 batches, we can type other_prior = list(batchCells = c(250, 250)). Note that the sum of batchCells numeric vector represents the total number of cells and the length of the vector equals to the number of batches.\nIn addtion, if we want to simulate three or more batches, we should obey the rules:\nThe length of batchCells vector always equals to the number of batches. The sum of batchCells numeric vector represents the total number of cells. For demonstration, we will simulate three batches using the learned parameters.\nsimulate_result \u0026lt;- simmethods::SplatPop_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = c(200, 300), nGenes = 1000), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 2 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$batch) # # Batch1 Batch2 # 210 290 Simulate more groups and batches simutaniously As mentioned before, we can set prob.group and batchCells to determine the number of groups and batches and we can also set de.prob to specify the proportion of DEGs. Here, we simulate a dataset with following settings:\n1000 cells 5000 genes three groups with 0.2 proportion of DEGs two batches simulate_result \u0026lt;- simmethods::SplatPop_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = c(500, 500), nGenes = 5000, de.prob = 0.2, prob.group = c(0.2, 0.3, 0.5)), seed = 111 ) # nCells: 1000 # nGenes: 5000 # nGroups: 3 # de.prob: 0.2 # nBatches: 2 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 5000 1000 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$batch) # # Batch1 Batch2 # 502 498 table(cell_info$group) # # Group1 Group2 Group3 # 220 302 478 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) # yes # 0.195 ### fc fc_group2_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup2 "
},
{
	"uri": "/references/methods/5-lun/",
	"title": "Lun",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using Lun Datasets with default parameters Determin the number of cells and genes Simulate two or more groups Here Lun method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data dim(ref_data) # [1] 4000 160 Using simmethods::Lun_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::Lun_estimation(ref_data = ref_data, verbose = T, seed = 10) # Estimating parameters using Lun Simulating datasets using Lun After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Simulate two or more groups Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group of cells.\nsimulate_result \u0026lt;- simmethods::Lun_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 1 # de.prob: 0.25 # fc.up.group: 5 # fc.down.group: 0 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 2 columns # cell_name group # \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; # Cell1 Cell1 Group1 # Cell2 Cell2 Group1 # Cell3 Cell3 Group1 # Cell4 Cell4 Group1 # Cell5 Cell5 Group1 # Cell6 Cell6 Group1 head(rowData(SCE_result)) # DataFrame with 6 rows and 1 column # gene_name # \u0026lt;character\u0026gt; # Gene1 Gene1 # Gene2 Gene2 # Gene3 Gene3 # Gene4 Gene4 # Gene5 Gene5 # Gene6 Gene6 Determin the number of cells and genes In Lun, we can not set nCells directly and should set groupCells instead. For example, if we want to simulate 500 cells, we can type other_prior = list(groupCells = 500). For genes, we can just set nGenes. Here, we simulate a new dataset with 500 cells and 2000 genes:\nsimulate_result \u0026lt;- simmethods::Lun_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(groupCells = 500, nGenes = 2000), seed = 111 ) # nCells: 500 # nGenes: 2000 # nGroups: 1 # de.prob: 0.5 # fc.up.group: 5 # fc.down.group: 0 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 2000 500 Simulate two or more groups In Lun, we can not set nGroups directly and should set prob.group instead. For example, if we want to simulate 2 groups, we can type other_prior = list(prob.group = c(0.5, 0.5)). Note that the sum of prob.group numeric vector must equal to 1, so we can also set prob.group = c(0.3, 0.7).\nIn addtion, if we want to simulate three or more groups, we should obey the rules:\nThe length of prob.group vector must always equal to the number of groups. The sum of prob.group numeric vector must equal to 1. For demonstration, we will simulate three groups using the learned parameters. We can set de.prob = 0.2 to simulate 20% genes as DEGs.\nsimulate_result \u0026lt;- simmethods::Lun_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(groupCells = 1000, nGenes = 3000, prob.group = c(0.1, 0.3, 0.6), de.prob = 0.2), seed = 111 ) # nCells: 1000 # nGenes: 3000 # nGroups: 3 # de.prob: 0.2 # fc.up.group: 5 # fc.down.group: 0 If you encounter the error which is like Warning: NAs producedError in [[\u0026lt;-.data.frame (tmp, paste0(‚ÄúDEFacGroup‚Äù, idx), value = c(5, :**, please set a higher gene number and try again.\nresult \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 3000 1000 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$group) # # Group1 Group2 Group3 # 100 300 600 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) ## de.prob = 0.2 # yes # 0.2 We can see that the proportion of differential expressed genes is 0.2 (default is 1). Next, if we want to know the fold change between two groups, we will do division with the groups that we are interested in.\n## fc between group2 and group1 fc_group1_to_group2 \u0026lt;- gene_info$DEFacGroup2/gene_info$DEFacGroup1 ## fc between group3 and group1 fc_group1_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup1 ## fc between group3 and group2 fc_group2_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup2 In addtion, users can also specify the foldchange of up-regulated or down-regulated DEGs by fc.up.group or fc.down.group.\nsimulate_result \u0026lt;- simmethods::Lun_simulation(parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], other_prior = list(prob.group = c(0.4, 0.6), de.prob = 0.2, fc.up.group = 2, fc.down.group = 0.5), return_format = \u0026quot;list\u0026quot;, verbose = TRUE, seed = 111) # nCells: 160 # nGenes: 4000 # nGroups: 2 # de.prob: 0.2 # fc.up.group: 2 # fc.down.group: 0.5 # Simulating datasets using Lun # Getting parameters... # Simulating means... # Simulating cell means... # Simulating counts... # Creating final dataset... # Sparsifying assays... # Automatically converting to sparse matrices, threshold = 0.95 # Converting \u0026#39;counts\u0026#39; to sparse matrix: estimated sparse size 0.82 * dense matrix # Skipping \u0026#39;CellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Done! row_data \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### fc.up.group max(row_data$DEFacGroup1) # [1] 2 ### fc.down.group min(row_data$DEFacGroup1) # [1] 0.5 "
},
{
	"uri": "/references/methods/6-lun2/",
	"title": "Lun2",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using Lun2 Datasets with default parameters Determin the number of cells and genes Simulate two or more groups Here Lun2 method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nWhen you use Lun2 to estimate parameters from a real dataset, you must input a numeric vector to specify the groups or plates that each cell comes from, like other_prior = list(group.condition = the numeric vector).\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data group_condition \u0026lt;- simmethods::group_condition ## group_condition can must be a numeric vector. other_prior \u0026lt;- list(group.condition = as.numeric(group_condition)) Using simmethods::Lun2_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::Lun2_estimation(ref_data = ref_data, other_prior = other_prior, verbose = T, seed = 10) # Estimating parameters using Lun2 # Estimating number of groups... # Warning in regularize.values(x, y, ties, missing(ties), na.rm = na.rm): # collapsing to unique \u0026#39;x\u0026#39; values # Computing normalisation factors... # Warning in (function (x, sizes, min.mean = NULL, positive = FALSE, scaling = # NULL) : encountered non-positive size factor estimates # Estimating dispersions... # Estimating gene means... # Estimating plate effects... # Estimating zero-inflated parameters... # Warning in sqrt(diag(vc)[np]): NaNs produced # Warning in sqrt(diag(vc)[np]): NaNs produced # Warning in value[[3L]](cond): system is computationally singular: reciprocal # condition number = 9.2681e-48FALSE # Warning in sqrt(diag(vc)[np]): NaNs produced # Warning in sqrt(diag(vc)[np]): NaNs produced # Warning in sqrt(diag(vc)[np]): NaNs produced # Warning in sqrt(diag(vc)[np]): NaNs produced # Warning in sqrt(diag(vc)[np]): NaNs produced # Warning in sqrt(diag(vc)[np]): NaNs produced # Warning in value[[3L]](cond): system is computationally singular: reciprocal # condition number = 4.1192e-48FALSE Simulating datasets using Lun2 After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Simulate two or more groups Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group of cells.\nsimulate_result \u0026lt;- simmethods::Lun2_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 3973 # nPlates: 2 # de.prob: 0 # fc.group: 3 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 3973 160 head(colData(SCE_result)) # DataFrame with 6 rows and 2 columns # cell_name plate # \u0026lt;character\u0026gt; \u0026lt;factor\u0026gt; # Cell1 Cell1 1 # Cell2 Cell2 1 # Cell3 Cell3 1 # Cell4 Cell4 1 # Cell5 Cell5 1 # Cell6 Cell6 1 head(rowData(SCE_result)) # DataFrame with 6 rows and 1 column # gene_name # \u0026lt;character\u0026gt; # Gene1 Gene1 # Gene2 Gene2 # Gene3 Gene3 # Gene4 Gene4 # Gene5 Gene5 # Gene6 Gene6 Determin the number of cells and genes In Lun2, we can not set nCells directly and should set cell.plates instead. For example, if we want to simulate 500 cells, we can type other_prior = list(cell.plates = rep(1, 500)). For genes, we can just set nGenes. Here, we simulate a new dataset with 500 cells and 2000 genes:\nsimulate_result \u0026lt;- simmethods::Lun2_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(cell.plates = rep(1, 500), nGenes = 2000), seed = 111 ) # nCells: 500 # nGenes: 2000 # nPlates: 1 # de.prob: 0 # fc.group: 3 # Warning in splatter::lun2Simulate(parameters, verbose = verbose, zinb = zinb): # Number of lib.sizes not equal to nCells. lib.sizes will be sampled. # Warning in splatter::lun2Simulate(parameters, verbose = verbose, zinb = zinb): # Number of gene parameters does not equal nGenes. Gene parameters will be # sampled. The cell.plates parameter represents the sampling source of cells in real experiments.\nresult \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 2000 500 Simulate two or more groups In Lun2, we can not set nGroups directly and should set cell.plates instead. For example, if we want to simulate 2 groups, we can type other_prior = list(cell.plates = sample(1:2, 500, replace = TRUE)). Note that the length of cell.plates numeric vector must be equal to the cell number.\nFor demonstration, we will simulate three groups using the learned parameters. We can set de.prob = 0.2 to simulate 20% genes as DEGs.\nsimulate_result \u0026lt;- simmethods::Lun2_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(cell.plates = sample(1:2, 500, replace = TRUE), nGenes = 2000, de.prob = 0.2, fc.group = 2), seed = 111 ) # nCells: 500 # nGenes: 2000 # nPlates: 2 # de.prob: 0.2 # fc.group: 2 # Warning in splatter::lun2Simulate(parameters, verbose = verbose, zinb = zinb): # Number of lib.sizes not equal to nCells. lib.sizes will be sampled. # Warning in splatter::lun2Simulate(parameters, verbose = verbose, zinb = zinb): # Number of gene parameters does not equal nGenes. Gene parameters will be # sampled. result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 2000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$plate) # # 1 2 # 236 264 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) ## de.prob = 0.2 # yes # 0.2 "
},
{
	"uri": "/references/methods/7-scrip/",
	"title": "SCRIP",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using SCRIP Datasets with default parameters Different modes in SCRIP Determin the number of cells and genes Simulate two or more groups Simulate two or more batches Simulate more groups and batches simutaniously Here SCRIP method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data dim(ref_data) # [1] 4000 160 Using simmethods::SCRIP_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::SCRIP_estimation(ref_data = ref_data, verbose = T, seed = 10) # Estimating parameters using SCRIP Simulating datasets using SCRIP After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Different modes in SCRIP Determin the number of cells and genes Simulate two or more groups Simulate two or more batches Simulate more groups and batches simutaniously Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group and one batch of cells.\nsimulate_result \u0026lt;- simmethods::SCRIP_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], ref_data = ref_data, return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 The reference data must be input when simulating new datasets.\nSCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 3 columns # cell_name batch group # \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; # Cell1 Cell1 Batch1 Group1 # Cell2 Cell2 Batch1 Group1 # Cell3 Cell3 Batch1 Group1 # Cell4 Cell4 Batch1 Group1 # Cell5 Cell5 Batch1 Group1 # Cell6 Cell6 Batch1 Group1 Time consuming:\nsimulate_result$simulate_detection$Elapsed_Time_sec # [1] 20.288 Different modes in SCRIP SCRIP contains five different simulation modes, and you can specify which mode do you use (default is GP-trendedBCV):\nGP-trendedBCV GP-commonBCV BGP-commonBCV BP BGP-trendedBCV simulate_result \u0026lt;- simmethods::SCRIP_simulation(parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], ref_data = ref_data, other_prior = list(mode = \u0026quot;BP\u0026quot;), return_format = \u0026quot;list\u0026quot;, verbose = TRUE, seed = 111) # nCells: 160 # nGenes: 4000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 # Simulating datasets using SCRIP simulate_result \u0026lt;- simmethods::SCRIP_simulation(parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], ref_data = ref_data, other_prior = list(mode = \u0026quot;BGP-commonBCV\u0026quot;), return_format = \u0026quot;list\u0026quot;, verbose = TRUE, seed = 111) # nCells: 160 # nGenes: 4000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 # Simulating datasets using SCRIP Determin the number of cells and genes In SCRIP, we can not set nCells directly and should set batchCells instead. For example, if we want to simulate 500 cells, we can type other_prior = list(batchCells = 500). For genes, we can just set nGenes. Here, we simulate a new dataset with 500 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::SCRIP_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], ref_data = ref_data, return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = 500, nGenes = 1000), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 Simulate two or more groups In SCRIP, we can not set nGroups directly and should set prob.group instead. For example, if we want to simulate 2 groups, we can type other_prior = list(prob.group = c(0.5, 0.5)). Note that the sum of prob.group numeric vector must equal to 1, so we can also set prob.group = c(0.3, 0.7).\nIn addtion, if we want to simulate three or more groups, we should obey the rules:\nThe length of prob.group vector must always equal to the number of groups. The sum of prob.group numeric vector must equal to 1. For demonstration, we will simulate three groups using the learned parameters.\nsimulate_result \u0026lt;- simmethods::SCRIP_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], ref_data = ref_data, return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = 500, nGenes = 1000, prob.group = c(0.1, 0.3, 0.6)), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 3 # de.prob: 0.1 # nBatches: 1 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$group) # # Group1 Group2 Group3 # 46 156 298 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) ## de.prob = 0.1 # yes # 0.1 We can see that the proportion of differential expressed genes is 0.1 (equals to the default). Next, if we want to know the fold change between two groups, we will do division with the groups that we are interested in.\n## fc between group2 and group1 fc_group1_to_group2 \u0026lt;- gene_info$DEFacGroup2/gene_info$DEFacGroup1 ## fc between group3 and group1 fc_group1_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup1 ## fc between group3 and group2 fc_group2_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup2 Simulate two or more batches In SCRIP, we can not set nBatches directly and should set batchCells instead. For example, if we want to simulate 2 batches, we can type other_prior = list(batchCells = c(250, 250)). Note that the sum of batchCells numeric vector represents the total number of cells and the length of the vector equals to the number of batches.\nIn addtion, if we want to simulate three or more batches, we should obey the rules:\nThe length of batchCells vector always equals to the number of batches. The sum of batchCells numeric vector represents the total number of cells. For demonstration, we will simulate three batches using the learned parameters.\nsimulate_result \u0026lt;- simmethods::SCRIP_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], ref_data = ref_data, return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = c(200, 300), nGenes = 1000), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 2 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$batch) # # Batch1 Batch2 # 200 300 Simulate more groups and batches simutaniously As mentioned before, we can set prob.group and batchCells to determine the number of groups and batches and we can also set de.prob to specify the proportion of DEGs. Here, we simulate a dataset with following settings:\n1000 cells 2000 genes three groups with 0.2 proportion of DEGs two batches simulate_result \u0026lt;- simmethods::SCRIP_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], ref_data = ref_data, return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = c(500, 500), nGenes = 2000, de.prob = 0.2, prob.group = c(0.2, 0.3, 0.5)), seed = 111 ) # nCells: 1000 # nGenes: 2000 # nGroups: 3 # de.prob: 0.2 # nBatches: 2 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 2000 1000 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$batch) # # Batch1 Batch2 # 500 500 table(cell_info$group) # # Group1 Group2 Group3 # 186 321 493 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) # yes # 0.1685 "
},
{
	"uri": "/references/methods/8-powsimr/",
	"title": "powsimR",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Estimate parameters without ERCC spike-in Estimate parameters with ERCC spike-in Simulating datasets using powsimR Datasets with default parameters Determin the number of cells and genes Simulate two or more groups Simulate two or more batches Simulate more groups and batches simutaniously Here powsimR method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data powsimR provides some choices for users to select suitable parameters according to different types of data, platforms, normalization methods, distributions and so on.\nRNAseq ‚Äúbulk‚Äù or ‚Äúsinglecell‚Äù (default). Protocol Options are ‚ÄúUMI‚Äù (default) (e.g.¬†10X Genomics, CEL-seq2) or ‚ÄúRead‚Äù (e.g.¬†Smart-seq2). Distribution ‚ÄúNB‚Äù (default) for negative binomial or ‚ÄúZINB‚Äù for zero-inflated negative binomial distribution fitting. Normalisation ‚ÄúTMM‚Äù (default), ‚ÄúMR‚Äù, ‚ÄúPosCounts‚Äù, ‚ÄúUQ‚Äù, ‚Äúscran‚Äù, ‚ÄúLinnorm‚Äù, ‚ÄúSCnorm‚Äù, ‚ÄúCensus‚Äù, ‚Äúdepth‚Äù, ‚Äúnone‚Äù. Estimate parameters without ERCC spike-in estimate_result \u0026lt;- powsimR_estimation( ref_data = ref_data, other_prior = list(RNAseq = \u0026quot;singlecell\u0026quot;, Protocol = \u0026quot;UMI\u0026quot;, Normalisation = \u0026quot;scran\u0026quot;), verbose = TRUE, seed = 111) # Warning: replacing previous import \u0026#39;DECENT::lrTest\u0026#39; by \u0026#39;MAST::lrTest\u0026#39; when # loading \u0026#39;powsimR\u0026#39; # Warning: replacing previous import \u0026#39;penalized::predict\u0026#39; by \u0026#39;stats::predict\u0026#39; when # loading \u0026#39;powsimR\u0026#39; # Warning: replacing previous import \u0026#39;zinbwave::glmWeightedF\u0026#39; by # \u0026#39;zingeR::glmWeightedF\u0026#39; when loading \u0026#39;powsimR\u0026#39; # Estimating parameters using estimateParam function Estimate parameters with ERCC spike-in powsimR also provides an another choice to estimate parameters (not neccessary) via spike-ins. If users want to use this, make sure that the reference data must contain ERCC spike-in counts. In addtion, users must set dilution.factor and volume information by other_prior = list(dilution.factor = xxx, volume = xxx).\nrownames(ref_data)[grep(pattern = \u0026quot;^ERCC\u0026quot;, x = rownames(ref_data))] # [1] \u0026quot;ERCC-00002\u0026quot; \u0026quot;ERCC-00003\u0026quot; \u0026quot;ERCC-00004\u0026quot; \u0026quot;ERCC-00009\u0026quot; \u0026quot;ERCC-00014\u0026quot; # [6] \u0026quot;ERCC-00019\u0026quot; \u0026quot;ERCC-00022\u0026quot; \u0026quot;ERCC-00025\u0026quot; \u0026quot;ERCC-00034\u0026quot; \u0026quot;ERCC-00035\u0026quot; # [11] \u0026quot;ERCC-00042\u0026quot; \u0026quot;ERCC-00043\u0026quot; \u0026quot;ERCC-00044\u0026quot; \u0026quot;ERCC-00046\u0026quot; \u0026quot;ERCC-00051\u0026quot; # [16] \u0026quot;ERCC-00053\u0026quot; \u0026quot;ERCC-00054\u0026quot; \u0026quot;ERCC-00059\u0026quot; \u0026quot;ERCC-00060\u0026quot; \u0026quot;ERCC-00062\u0026quot; # [21] \u0026quot;ERCC-00069\u0026quot; \u0026quot;ERCC-00071\u0026quot; \u0026quot;ERCC-00074\u0026quot; \u0026quot;ERCC-00076\u0026quot; \u0026quot;ERCC-00078\u0026quot; # [26] \u0026quot;ERCC-00079\u0026quot; \u0026quot;ERCC-00084\u0026quot; \u0026quot;ERCC-00092\u0026quot; \u0026quot;ERCC-00095\u0026quot; \u0026quot;ERCC-00096\u0026quot; # [31] \u0026quot;ERCC-00099\u0026quot; \u0026quot;ERCC-00108\u0026quot; \u0026quot;ERCC-00111\u0026quot; \u0026quot;ERCC-00112\u0026quot; \u0026quot;ERCC-00113\u0026quot; # [36] \u0026quot;ERCC-00116\u0026quot; \u0026quot;ERCC-00130\u0026quot; \u0026quot;ERCC-00131\u0026quot; \u0026quot;ERCC-00136\u0026quot; \u0026quot;ERCC-00144\u0026quot; # [41] \u0026quot;ERCC-00145\u0026quot; \u0026quot;ERCC-00148\u0026quot; \u0026quot;ERCC-00154\u0026quot; \u0026quot;ERCC-00157\u0026quot; \u0026quot;ERCC-00160\u0026quot; # [46] \u0026quot;ERCC-00162\u0026quot; \u0026quot;ERCC-00163\u0026quot; \u0026quot;ERCC-00165\u0026quot; \u0026quot;ERCC-00170\u0026quot; \u0026quot;ERCC-00171\u0026quot; Make sure there are ERCC names in reference data and users must input the dilution.factor and volume (microliter) to determine the concentration of ERCC molecules.\nestimate_result \u0026lt;- powsimR_estimation( ref_data = ref_data, other_prior = list(RNAseq = \u0026quot;singlecell\u0026quot;, Protocol = \u0026quot;UMI\u0026quot;, Normalisation = \u0026quot;scran\u0026quot;, dilution.factor = 50000, volume = 1), verbose = TRUE, seed = 111) # Estimating parameters using estimateParam function Simulating datasets using powsimR After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Simulate two or more groups Simulate two or more batches Simulate more groups and batches simutaniously powsimR provides some choices for users to select suitable parameters according to different normalization methods, and methods for differential expressed analysis.\nNormalisation ‚ÄúTMM‚Äù (default), ‚ÄúMR‚Äù, ‚ÄúPosCounts‚Äù, ‚ÄúUQ‚Äù, ‚Äúscran‚Äù, ‚ÄúLinnorm‚Äù, ‚Äúsctransform‚Äù, ‚ÄúSCnorm‚Äù, ‚ÄúCensus‚Äù, ‚Äúdepth‚Äù. DEmethod ‚ÄúT-Test‚Äù, ‚ÄúedgeR-LRT‚Äù, ‚ÄúedgeR-QL‚Äù, ‚ÄúedgeR-zingeR‚Äù, ‚ÄúedgeR-ZINB-WaVE‚Äù, ‚Äúlimma-voom‚Äù, ‚Äúlimma-trend‚Äù (default), ‚ÄúDESeq2‚Äù, ‚ÄúDESeq2-zingeR‚Äù, ‚ÄúDESeq2-ZINB-WaVE‚Äù, ‚ÄúROTS‚Äù, ‚ÄúbaySeq‚Äù, ‚ÄúNOISeq‚Äù, ‚ÄúEBSeq‚Äù, ‚ÄúMAST‚Äù, ‚ÄúBPSC‚Äù, ‚ÄúscDD‚Äù, ‚ÄúDECENT‚Äù. Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group and one batch of cells.\nsimulate_result \u0026lt;- simmethods::powsimR_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, verbose = TRUE, seed = 111) # nCells: 160 # nGenes: 4000 # nGroups: 2 # de.prob: 0.1 # fc.group: 2 # nBatches: 1 # # Setup Seed: 111 # You have chosen to simulate the expression of 4000 genes, which will be randomly drawn with replacement from the observed expression of 4000 genes. # Simulating datasets using powsimR # limma-trend is developed for bulk RNA-seq experiments. # Preparing output arrays. # # SIMULATION NUMBER 1 # Generating gene expression. # Generating spike-in expression. # 80 vs. 80 # Applying TMM normalisation # Applying limma-trend for DE analysis on raw count data. # Saving raw simulated counts. # Estimating moments of raw count data. SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 2 columns # cell_name group # \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; # Cell1 Cell1 Group1 # Cell2 Cell2 Group1 # Cell3 Cell3 Group1 # Cell4 Cell4 Group1 # Cell5 Cell5 Group1 # Cell6 Cell6 Group1 Time consuming:\nsimulate_result$simulate_detection$Elapsed_Time_sec # [1] 0.982 Determin the number of cells and genes Here, we simulate a new dataset with 500 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::powsimR_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], other_prior = list(nCells = 500, nGenes = 1000), return_format = \u0026quot;list\u0026quot;, verbose = TRUE, seed = 111) # nCells: 500 # nGenes: 1000 # nGroups: 2 # de.prob: 0.1 # fc.group: 2 # nBatches: 1 # # Setup Seed: 111 # You have chosen to simulate the expression of 1000 genes, which will be randomly drawn without replacement from the observed expression of 4000 genes. # Simulating datasets using powsimR # limma-trend is developed for bulk RNA-seq experiments. # Preparing output arrays. # # SIMULATION NUMBER 1 # Generating gene expression. # Generating spike-in expression. # 250 vs. 250 # Applying TMM normalisation # Applying limma-trend for DE analysis on raw count data. # Saving raw simulated counts. # Estimating moments of raw count data. result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 Simulate two or more groups In powsimR, we can not set nGroups directly and should set prob.group instead. For example, if we want to simulate 2 groups, we can type other_prior = list(prob.group = c(0.5, 0.5)). Note that the sum of prob.group numeric vector must equal to 1, so we can also set prob.group = c(0.3, 0.7).\nIn addtion, if we want to simulate three or more groups, we should obey the rules:\nThe length of prob.group vector must always be 2 when using powsinR. The sum of prob.group numeric vector must equal to 1. For demonstration, we will simulate two groups using the learned parameters. (20% DEGs and 4 fold change)\nsimulate_result \u0026lt;- simmethods::powsimR_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 500, nGenes = 1000, prob.group = c(0.3, 0.7), de.prob = 0.2, fc.group = 4), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 2 # de.prob: 0.2 # fc.group: 4 # nBatches: 1 # # You have chosen to simulate the expression of 1000 genes, which will be randomly drawn without replacement from the observed expression of 4000 genes. result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$group) # # Group1 Group2 # 150 350 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) ## de.prob = 0.2 # yes # 0.2 Simulate two or more batches In powsimR, we can not set nBatches directly and should set prob.batch instead. For example, if we want to simulate 2 batches, we can type other_prior = list(prob.batch = c(0.5, 0.5)). Note that the sum of prob.batch numeric vector represents the total number of cells and the length of the vector equals to the number of batches.\nIn addtion, if we want to simulate three or more batches, we should obey the rules:\nThe length of prob.batch vector must always equal to the number of batches The sum of prob.batch numeric vector must equal to 1. For demonstration, we will simulate two batches using the learned parameters. (2 fold change)\nsimulate_result \u0026lt;- simmethods::powsimR_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], other_prior = list(prob.batch = c(0.4, 0.6), fc.batch = 2), return_format = \u0026quot;list\u0026quot;, verbose = TRUE, seed = 111) # nCells: 160 # nGenes: 4000 # nGroups: 2 # de.prob: 0.1 # fc.group: 2 # nBatches: 2 # fc.batch: 2 # Setup Seed: 111 # You have chosen to simulate the expression of 4000 genes, which will be randomly drawn with replacement from the observed expression of 4000 genes. # Simulating datasets using powsimR # limma-trend is developed for bulk RNA-seq experiments. # Preparing output arrays. # # SIMULATION NUMBER 1 # Generating gene expression. # Generating spike-in expression. # 32 vs. 32 # Applying TMM normalisation # Applying limma-trend for DE analysis on raw count data. # Saving raw simulated counts. # Estimating moments of raw count data. # 48 vs. 48 # Applying TMM normalisation # Applying limma-trend for DE analysis on raw count data. # Saving raw simulated counts. # Estimating moments of raw count data. result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 4000 160 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$batch) # # Batch1 Batch2 # 64 96 Simulate more groups and batches simutaniously As mentioned before, we can set prob.group and prob.batch to determine the number of groups and batches and we can also set de.prob to specify the proportion of DEGs. Here, we simulate a dataset with following settings:\n1000 cells 2000 genes two groups with 0.2 proportion of DEGs two batches simulate_result \u0026lt;- simmethods::powsimR_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 1000, nGenes = 2000, de.prob = 0.2, prob.group = c(0.4, 0.6), prob.batch = c(0.5, 0.5)), seed = 111 ) # nCells: 1000 # nGenes: 2000 # nGroups: 2 # de.prob: 0.2 # fc.group: 2 # nBatches: 2 # fc.batch: 2 # You have chosen to simulate the expression of 2000 genes, which will be randomly drawn without replacement from the observed expression of 4000 genes. result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 2000 1000 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$batch) # # Batch1 Batch2 # 500 500 table(cell_info$group) # # Group1 Group2 # 400 600 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) # yes # 0.2 "
},
{
	"uri": "/references/methods/10-scdd/",
	"title": "scDD",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using scDD Datasets with default parameters Determin the number of cells Here scDD method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nWhen you use scDD to estimate parameters from a real dataset, you must input a numeric vector to specify the groups or plates that each cell comes from, like other_prior = list(group.condition = the numeric vector).\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- SingleCellExperiment::counts(scater::mockSCE()) set.seed(111) group_condition \u0026lt;- sample(c(1, 2), 200, replace = TRUE) ## group_condition can must be a numeric vector. other_prior \u0026lt;- list(group.condition = as.numeric(group_condition)) Using simmethods::scDD_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::scDD_estimation(ref_data = ref_data, other_prior = other_prior, verbose = T, seed = 10) # Estimating parameters using scDD # Performing Median Normalization # Setting up parallel back-end using 1 cores # Clustering observed expression data for each gene # Notice: Number of permutations is set to zero; using # Kolmogorov-Smirnov to test for differences in distributions # instead of the Bayes Factor permutation test # Classifying significant genes into patterns Time consuming:\nestimate_result$estimate_detection$Elapsed_Time_sec # [1] 130.466 Simulating datasets using scDD After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells Datasets with default parameters The reference data contains 200 cells and 2000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nThe simulated dataset will always have two group of cells using scDD.\nsimulate_result \u0026lt;- simmethods::scDD_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 2000 200 table(colData(SCE_result)$group) # # Group1 Group2 # 100 100 Determin the number of cells In scDD, users can only set nCells to specify the number of cells because the genes are already fixed after estimation step.\nsimulate_result \u0026lt;- simmethods::scDD_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 1000), seed = 111 ) result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 2000 1000 col_data \u0026lt;- simulate_result$simulate_result$col_meta table(col_data$group) # # Group1 Group2 # 500 500 "
},
{
	"uri": "/references/methods/11-scdesign/",
	"title": "scDesign",
	"tags": [],
	"description": "",
	"content": " Simulating datasets using scDesign Datasets with default parameters Determin the number of cells Simulate two or more groups Here scDesign method will be demonstrated clearly and hope that this document can help you.\nSimulating datasets using scDesign There is no estimation step when using scDesign, so we can directly simulate new datasets through reference data.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data We will simulate a dataset based on refernece data with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Simulate two or more groups Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group of cells.\nsimulate_result \u0026lt;- simmethods::scDesign_simulation( ref_data = ref_data, return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 1 # de.prob: 0.1 # fc.group: up--5 # fc.group: down--1.5 # [1] \u0026quot;estimate expression parameters\u0026quot; SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 1 column # cell_name # \u0026lt;character\u0026gt; # Cell1 Cell1 # Cell2 Cell2 # Cell3 Cell3 # Cell4 Cell4 # Cell5 Cell5 # Cell6 Cell6 Determin the number of cells We can only set the cell number in scDesign.\nHere, we simulate a new dataset with 500 cells:\nsimulate_result \u0026lt;- simmethods::scDesign_simulation( ref_data = ref_data, return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 500), seed = 111 ) # nCells: 500 # nGenes: 4000 # nGroups: 1 # de.prob: 0.1 # fc.group: up--5 # fc.group: down--1.5 # [1] \u0026quot;estimate expression parameters\u0026quot; result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 4000 500 Simulate two or more groups In scDesign, we can et nGroups directly, together with the proportions of different cell groups by prob.group. Moreover, the proportion of DEGs via de.prob and fold change via fc.group can be customed.\nFor demonstration, we will simulate three groups.\nsimulate_result \u0026lt;- simmethods::scDesign_simulation( ref_data = ref_data, return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 500, nGroups = 3, prob.group = c(0.1, 0.3, 0.6), de.prob = 0.2, fc.group = 4), seed = 111 ) # nCells: 500 # nGenes: 4000 # nGroups: 3 # de.prob: 0.2 # fc.group: up--4 # fc.group: down--4 # [1] \u0026quot;estimate expression parameters\u0026quot; result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 4000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$group) # # Group1 Group2 Group3 # 50 150 300 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) ## de.prob = 0.2 # yes # 0.2 "
},
{
	"uri": "/references/methods/12-scdesign2/",
	"title": "scDesign2",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Default estimation Information of cell groups Information of cell types Simulating datasets using scDesign2 Datasets with default parameters Determin the number of cells Simulate two or more groups Here scDesign2 method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data Default estimation estimate_result \u0026lt;- simmethods::scDesign2_estimation( ref_data = ref_data, verbose = TRUE, seed = 111 ) # Estimating parameters using scDesign2 Information of cell groups If the information of cell groups is available, you can use another way to estimate the parameters.\n## cell groups group_condition \u0026lt;- as.numeric(simmethods::group_condition) estimate_result \u0026lt;- simmethods::scDesign2_estimation( ref_data = ref_data, other_prior = list(group.condition = group_condition), verbose = TRUE, seed = 111 ) # Estimating parameters using scDesign2 Information of cell types You can input information of cell types via cell_type_sel parameter described in scDesign2::fit_model_scDesign2 function\nestimate_result \u0026lt;- simmethods::scDesign2_estimation( ref_data = ref_data, other_prior = list(cell_type_sel = paste0(\u0026quot;cell_type\u0026quot;, group_condition)), verbose = TRUE, seed = 111 ) # Estimating parameters using scDesign2 Simulating datasets using scDesign2 After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells Simulate two or more groups Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::scDesign2_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 2 We will get two or groups if information of cell groups or cell type is used in estimation step.\nSCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 table(colData(SCE_result)$group) # # Group1 Group2 # 80 80 Determin the number of cells We can only set the cell number in scDesign2.\nHere, we simulate a new dataset with 500 cells:\nsimulate_result \u0026lt;- simmethods::scDesign2_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 500), seed = 111 ) # nCells: 500 # nGenes: 4000 # nGroups: 2 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 4000 500 Simulate two or more groups In scDesign2, we can not set nGroups directly and should set prob.group instead. For example, if we want to simulate 2 groups, we can type other_prior = list(prob.group = c(0.5, 0.5)). Note that the sum of prob.group numeric vector must equal to 1, so we can also set prob.group = c(0.3, 0.7).\nIn addtion, if we want to simulate three or more groups, we should obey the rules:\nThe length of prob.group vector must always equal to the number of cell groups or cell types used in estimation step. The sum of prob.group numeric vector must equal to 1. For demonstration, we can only simulate two groups using the learned parameters.\nsimulate_result \u0026lt;- simmethods::scDesign2_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 500, prob.group = c(0.4, 0.6)), seed = 111 ) # nCells: 500 # nGenes: 4000 # nGroups: 2 If you did not input information of cell groups or cell types in the estimation step, you can not simulate groups.\nresult \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 4000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$group) # # Group1 Group2 # 200 300 "
},
{
	"uri": "/references/methods/13-zinbwave/",
	"title": "zinbwave",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using zinbwave Here zinbwave method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data Using simmethods::zinbwave_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::zinbwave_estimation(ref_data = ref_data, verbose = T, seed = 10) # Estimating parameters using zinbwave # Removing all zero genes... # Fitting model... # Create model: # ok # Initialize parameters: # ok # Optimize parameters: # Iteration 1 # penalized log-likelihood = -1458528.51195789 # After dispersion optimization = -1842970.76424042 # user system elapsed # 6.120 0.526 6.648 # After right optimization = -1681437.25066416 # After orthogonalization = -1681437.25066416 # user system elapsed # 2.415 0.220 2.636 # After left optimization = -1615279.08884363 # After orthogonalization = -1615279.08884363 # Iteration 2 # penalized log-likelihood = -1615279.08884363 # After dispersion optimization = -1615279.08884363 # user system elapsed # 4.964 0.373 5.341 # After right optimization = -1613680.86211755 # After orthogonalization = -1613680.86211755 # user system elapsed # 2.306 0.090 2.398 # After left optimization = -1613424.05613962 # After orthogonalization = -1613424.05613962 # Iteration 3 # penalized log-likelihood = -1613424.05613962 # After dispersion optimization = -1613424.05613962 # user system elapsed # 4.404 0.319 4.728 # After right optimization = -1613329.33593763 # After orthogonalization = -1613329.33593763 # user system elapsed # 1.230 0.066 1.298 # After left optimization = -1613299.28560498 # After orthogonalization = -1613299.28560498 # Iteration 4 # penalized log-likelihood = -1613299.28560498 # ok Simulating datasets using zinbwave After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters.\nThe reference data contains 160 cells and 4000 genes, we can only simulate datasets with default parameters in zinbwave and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::zinbwave_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 1 column # Cell # \u0026lt;character\u0026gt; # Cell1 Cell1 # Cell2 Cell2 # Cell3 Cell3 # Cell4 Cell4 # Cell5 Cell5 # Cell6 Cell6 head(rowData(SCE_result)) # DataFrame with 6 rows and 1 column # Gene # \u0026lt;character\u0026gt; # Gene1 Gene1 # Gene2 Gene2 # Gene3 Gene3 # Gene4 Gene4 # Gene5 Gene5 # Gene6 Gene6 "
},
{
	"uri": "/references/methods/14-zinger/",
	"title": "zingeR",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using zingeR Datasets with default parameters Determin the number of cells and genes Simulate two groups Here zingeR method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nWhen you use zingeR to estimate parameters from a real dataset, you must input a numeric vector to specify the groups or plates that each cell comes from, like other_prior = list(group.condition = the numeric vector).\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data group_condition \u0026lt;- simmethods::group_condition ## group_condition can must be a numeric vector. other_prior \u0026lt;- list(group.condition = as.numeric(group_condition)) Using simmethods::zingeR_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::zingeR_estimation(ref_data = ref_data, other_prior = other_prior, verbose = T, seed = 10) # Estimating parameters using zingeR Simulating datasets using zingeR After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Simulate two groups Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group of cells.\nsimulate_result \u0026lt;- simmethods::zingeR_simulation( ref_data = ref_data, other_prior = other_prior, parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 2 # prob.group: 0.1 # fc.group: 2 # Loading required package: edgeR # Loading required package: limma # # Attaching package: \u0026#39;limma\u0026#39; # The following object is masked from \u0026#39;package:BiocGenerics\u0026#39;: # # plotMA # # Attaching package: \u0026#39;edgeR\u0026#39; # The following object is masked from \u0026#39;package:SingleCellExperiment\u0026#39;: # # cpm # Preparing dataset. Using existing parameters. # Sampling. # Calculating differential expression. # Simulating data. SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 1 column # cell_name # \u0026lt;character\u0026gt; # Cell1 Cell1 # Cell2 Cell2 # Cell3 Cell3 # Cell4 Cell4 # Cell5 Cell5 # Cell6 Cell6 head(rowData(SCE_result)) # DataFrame with 6 rows and 3 columns # gene_name de_gene de_fc # \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; \u0026lt;numeric\u0026gt; # Gene1 Gene1 no 0 # Gene2 Gene2 no 0 # Gene3 Gene3 no 0 # Gene4 Gene4 no 0 # Gene5 Gene5 no 0 # Gene6 Gene6 no 0 Determin the number of cells and genes In zingeR, users can only set the number of cells and genes which is higher than the reference data. Here, we simulate a new dataset with 1000 cells and 5000 genes:\nsimulate_result \u0026lt;- simmethods::zingeR_simulation( ref_data = ref_data, other_prior = list(group.condition = as.numeric(group_condition), nCells = 1000, nGenes = 5000), parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, seed = 111 ) # nCells: 1000 # nGenes: 5000 # nGroups: 2 # prob.group: 0.1 # fc.group: 2 # Preparing dataset. Using existing parameters. # Sampling. # Calculating differential expression. # Simulating data. result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 5000 1000 Simulate two groups In zingeR, we can only simulate two groups and note that zingeR dose not return cell group information.\nFor demonstration, we will simulate two groups using the learned parameters. We can set de.prob = 0.2 to simulate 20% genes as DEGs.\nsimulate_result \u0026lt;- simmethods::zingeR_simulation( ref_data = ref_data, other_prior = list(group.condition = as.numeric(group_condition), nCells = 1000, nGenes = 5000, de.prob = 0.2, fc.group = 4), parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, seed = 111 ) # nCells: 1000 # nGenes: 5000 # nGroups: 2 # prob.group: 0.2 # fc.group: 4 # Preparing dataset. Using existing parameters. # Sampling. # Calculating differential expression. # Simulating data. zingeR dose not return cell group information.\nresult \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 5000 1000 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) ## de.prob = 0.2 # yes # 0.2 "
},
{
	"uri": "/references/methods/15-zinbwavezinger/",
	"title": "zinbwaveZinger",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using zinbwaveZinger Datasets with default parameters Determin the number of cells and genes Simulate two groups Here zinbwaveZinger method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nWhen you use zinbwaveZinger to estimate parameters from a real dataset, you must input a numeric vector to specify the groups or plates that each cell comes from, like other_prior = list(group.condition = the numeric vector).\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data group_condition \u0026lt;- simmethods::group_condition ## group_condition can must be a numeric vector. other_prior \u0026lt;- list(group.condition = as.numeric(group_condition)) Using simmethods::zinbwaveZinger_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::zinbwaveZinger_estimation(ref_data = ref_data, other_prior = other_prior, verbose = T, seed = 10) # Estimating parameters using zinbwaveZinger # iteration 1 in 10 # iteration 2 in 10 # iteration 3 in 10 # iteration 4 in 10 # iteration 5 in 10 # iteration 6 in 10 # iteration 7 in 10 # iteration 8 in 10 # iteration 9 in 10 # iteration 10 in 10 Simulating datasets using zinbwaveZinger After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Simulate two groups Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group of cells.\nsimulate_result \u0026lt;- simmethods::zinbwaveZinger_simulation( ref_data = ref_data, other_prior = other_prior, parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 2 # prob.group: 0.1 # fc.group: 2 # Preparing dataset. # Sampling. # Calculating differential expression. # Simulating data. # Adding extra zeros w.r.t. NB for 2366 genes SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 1 column # cell_name # \u0026lt;character\u0026gt; # Cell1 Cell1 # Cell2 Cell2 # Cell3 Cell3 # Cell4 Cell4 # Cell5 Cell5 # Cell6 Cell6 head(rowData(SCE_result)) # DataFrame with 6 rows and 3 columns # gene_name de_gene de_fc # \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; \u0026lt;numeric\u0026gt; # Gene1 Gene1 no 0 # Gene2 Gene2 no 0 # Gene3 Gene3 no 0 # Gene4 Gene4 no 0 # Gene5 Gene5 no 0 # Gene6 Gene6 no 0 Determin the number of cells and genes In zinbwaveZinger, users can only set the number of cells and genes which is higher than the reference data. Here, we simulate a new dataset with 1000 cells and 5000 genes:\nsimulate_result \u0026lt;- simmethods::zinbwaveZinger_simulation( ref_data = ref_data, other_prior = list(group.condition = as.numeric(group_condition), nCells = 1000, nGenes = 5000), parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, seed = 111 ) # nCells: 1000 # nGenes: 5000 # nGroups: 2 # prob.group: 0.1 # fc.group: 2 # Preparing dataset. # Sampling. # Calculating differential expression. # Simulating data. # Adding extra zeros w.r.t. NB for 2776 genes result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 5000 1000 Simulate two groups In zinbwaveZinger, we can only simulate two groups and note that zinbwaveZinger dose not return cell group information.\nFor demonstration, we will simulate two groups using the learned parameters. We can set de.prob = 0.2 to simulate 20% genes as DEGs.\nsimulate_result \u0026lt;- simmethods::zinbwaveZinger_simulation( ref_data = ref_data, other_prior = list(group.condition = as.numeric(group_condition), nCells = 1000, nGenes = 5000, de.prob = 0.2, fc.group = 4), parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, seed = 111 ) # nCells: 1000 # nGenes: 5000 # nGroups: 2 # prob.group: 0.2 # fc.group: 4 # Preparing dataset. # Sampling. # Calculating differential expression. # Simulating data. # Adding extra zeros w.r.t. NB for 2640 genes zinbwaveZinger dose not return cell group information.\nresult \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 5000 1000 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) ## de.prob = 0.2 # yes # 0.2 "
},
{
	"uri": "/references/methods/18-sparsim/",
	"title": "SPARSim",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Estimation without cell group information Estimation with cell group information Estimation with spike-in genes Simulating datasets using SPARSim Datasets with default parameters Simulate groups Simulate batch Here SPARSim method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data Estimation without cell group information In SPARSim, users can estimate parameters from real data only using gene expression matrix.\nUsing simmethods::SPARSim_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::SPARSim_estimation( ref_data = ref_data, other_prior = NULL, verbose = TRUE, seed = 111 ) # Estimating parameters using SPARSim # [1] \u0026quot;Experimental condition 1\u0026quot; # [1] \u0026quot;...estimating gene intensity\u0026quot; # [1] \u0026quot;...estimating gene variability\u0026quot; # [1] \u0026quot;...estimating library size\u0026quot; # [1] \u0026quot;...creating SPARSim simulation parameter\u0026quot; Estimation with cell group information In addition, you can also input a numeric vector to specify the groups or plates that each cell comes from, like other_prior = list(group.condition = the numeric vector).\ngroup \u0026lt;- as.numeric(simmethods::group_condition) estimate_result \u0026lt;- simmethods::SPARSim_estimation( ref_data = ref_data, other_prior = list(group.condition = group), verbose = TRUE, seed = 111 ) # Estimating parameters using SPARSim # [1] \u0026quot;Experimental condition 1\u0026quot; # [1] \u0026quot;...estimating gene intensity\u0026quot; # [1] \u0026quot;...estimating gene variability\u0026quot; # [1] \u0026quot;...estimating library size\u0026quot; # [1] \u0026quot;...creating SPARSim simulation parameter\u0026quot; # [1] \u0026quot;Experimental condition 2\u0026quot; # [1] \u0026quot;...estimating gene intensity\u0026quot; # [1] \u0026quot;...estimating gene variability\u0026quot; # [1] \u0026quot;...estimating library size\u0026quot; # [1] \u0026quot;...creating SPARSim simulation parameter\u0026quot; Estimation with spike-in genes In SPARSim, ERCC spike-in genes can be used to estimate data parameters from the real data. In this case, the gene matrix must contain spike-in gene counts and hold the right ERCC spike-in gene names. Note that users must also input the dilution factor and volume (microliter) which the experiment used.\ngroup \u0026lt;- as.numeric(simmethods::group_condition) other_prior \u0026lt;- list(group.condition = group, dilution.factor = 50000, volume = 0.01) estimate_result \u0026lt;- simmethods::SPARSim_estimation( ref_data = ref_data, other_prior = other_prior, verbose = TRUE, seed = 111 ) # Estimating parameters using SPARSim # [1] \u0026quot;Experimental condition 1\u0026quot; # [1] \u0026quot;...estimating gene intensity\u0026quot; # [1] \u0026quot;...estimating gene variability\u0026quot; # [1] \u0026quot;...estimating library size\u0026quot; # [1] \u0026quot;...creating SPARSim simulation parameter\u0026quot; # [1] \u0026quot;Experimental condition 2\u0026quot; # [1] \u0026quot;...estimating gene intensity\u0026quot; # [1] \u0026quot;...estimating gene variability\u0026quot; # [1] \u0026quot;...estimating library size\u0026quot; # [1] \u0026quot;...creating SPARSim simulation parameter\u0026quot; Check spike-in parameters\nspikein_params \u0026lt;- estimate_result[[\u0026quot;estimate_result\u0026quot;]][[\u0026quot;SPARSim_spikein_parameter\u0026quot;]] str(spikein_params) # List of 4 # $ spikein_set :List of 1 # ..$ spikein:List of 4 # .. ..$ mix_name : chr \u0026quot;spikein\u0026quot; # .. ..$ abundance : Named num [1:50] 3613.2 903.3 225.8 112.9 56.5 ... # .. .. ..- attr(*, \u0026quot;names\u0026quot;)= chr [1:50] \u0026quot;spikein_1\u0026quot; \u0026quot;spikein_2\u0026quot; \u0026quot;spikein_3\u0026quot; \u0026quot;spikein_4\u0026quot; ... # .. ..$ variability: Named num [1:50] 0 0 0 0 0 0 0 0 0 0 ... # .. .. ..- attr(*, \u0026quot;names\u0026quot;)= chr [1:50] \u0026quot;spikein_1\u0026quot; \u0026quot;spikein_2\u0026quot; \u0026quot;spikein_3\u0026quot; \u0026quot;spikein_4\u0026quot; ... # .. ..$ ids : chr [1:50] \u0026quot;spikein_1\u0026quot; \u0026quot;spikein_2\u0026quot; \u0026quot;spikein_3\u0026quot; \u0026quot;spikein_4\u0026quot; ... # $ spikein_sample : chr [1:160] \u0026quot;spikein\u0026quot; \u0026quot;spikein\u0026quot; \u0026quot;spikein\u0026quot; \u0026quot;spikein\u0026quot; ... # $ spikein_proportion: num 0.05 # $ spikein_ids : chr [1:50] \u0026quot;spikein_1\u0026quot; \u0026quot;spikein_2\u0026quot; \u0026quot;spikein_3\u0026quot; \u0026quot;spikein_4\u0026quot; ... Simulating datasets using SPARSim After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Simulate groups Simulate batches Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nThe simulated dataset will have one group of cells as no group information is used in estimation step.\nestimate_result \u0026lt;- simmethods::SPARSim_estimation( ref_data = ref_data, other_prior = NULL, verbose = TRUE, seed = 111 ) # Estimating parameters using SPARSim # [1] \u0026quot;Experimental condition 1\u0026quot; # [1] \u0026quot;...estimating gene intensity\u0026quot; # [1] \u0026quot;...estimating gene variability\u0026quot; # [1] \u0026quot;...estimating library size\u0026quot; # [1] \u0026quot;...creating SPARSim simulation parameter\u0026quot; simulate_result \u0026lt;- simmethods::SPARSim_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 1 # fc.group: 0 # de.prob: 0 # nBatches: 0 # Number of experimental conditions: 1 # Number of genes: 4000 # Number of cells: 160 # Setting gene expression intensity... # Setting gene expression variability ... # Simulating biological variability ... # Simulating technical variability ... SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 2 columns # cell_name group # \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; # Cell1 Cell1 Group1 # Cell2 Cell2 Group1 # Cell3 Cell3 Group1 # Cell4 Cell4 Group1 # Cell5 Cell5 Group1 # Cell6 Cell6 Group1 head(rowData(SCE_result)) # DataFrame with 6 rows and 1 column # gene_name # \u0026lt;character\u0026gt; # Gene1 Gene1 # Gene2 Gene2 # Gene3 Gene3 # Gene4 Gene4 # Gene5 Gene5 # Gene6 Gene6 Simulate groups The number of groups simulated by SPARSim is determined by the group information used in estimation step. If the group information of two cell states is provided, then the simulated dataset will contain two groups. SPARSim also provides other parameters related to DEGs such as the proportion of DEGs (de.prob) and the fold change of DGEs (fc.group).\nEstimating parameters using group information\ngroup \u0026lt;- as.numeric(simmethods::group_condition) estimate_result \u0026lt;- simmethods::SPARSim_estimation( ref_data = ref_data, other_prior = list(group.condition = group), verbose = TRUE, seed = 111 ) # Estimating parameters using SPARSim # [1] \u0026quot;Experimental condition 1\u0026quot; # [1] \u0026quot;...estimating gene intensity\u0026quot; # [1] \u0026quot;...estimating gene variability\u0026quot; # [1] \u0026quot;...estimating library size\u0026quot; # [1] \u0026quot;...creating SPARSim simulation parameter\u0026quot; # [1] \u0026quot;Experimental condition 2\u0026quot; # [1] \u0026quot;...estimating gene intensity\u0026quot; # [1] \u0026quot;...estimating gene variability\u0026quot; # [1] \u0026quot;...estimating library size\u0026quot; # [1] \u0026quot;...creating SPARSim simulation parameter\u0026quot; For demonstration, we will simulate two groups using the learned parameters. We can set de.prob = 0.2 to simulate 20% genes as DEGs.\nsimulate_result \u0026lt;- simmethods::SPARSim_simulation( other_prior = list(de.prob = 0.2, fc.group = 4), parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 2 # fc.group: 4 # de.prob: 0.2 # nBatches: 0 # Number of experimental conditions: 2 # Number of genes: 4000 # Number of cells: 160 # Setting gene expression intensity... # Setting gene expression variability ... # Simulating biological variability ... # Simulating technical variability ... result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 4000 160 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) ## de.prob = 0.2 # yes # 0.2 Simulate batch Users can simulate batches when batch.condition parameter is activated and just input the numeric vectors that specify the batch labels of cells.\nFor demonstration, we will simulate three batches using the learned parameters.\nsimulate_result \u0026lt;- simmethods::SPARSim_simulation( other_prior = list(de.prob = 0.2, fc.group = 4, batch.condition = sample(1:3, 160, replace = TRUE)), parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 2 # fc.group: 4 # de.prob: 0.2 # nBatches: 3 # Number of experimental conditions: 2 # Number of genes: 4000 # Number of cells: 160 # Setting gene expression intensity... # Setting gene expression variability ... # Simulating batch effects ... # Simulating biological variability ... # Simulating technical variability ... ## cell information col_data \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(col_data$group) # # Group1 Group2 # 80 80 table(col_data$batch) # # Batch1 Batch2 Batch3 # 63 43 54 "
},
{
	"uri": "/references/methods/19-spsimseq/",
	"title": "SPsimSeq",
	"tags": [],
	"description": "",
	"content": " Simulating datasets using SPsimSeq Datasets with default parameters Determin the number of cells and genes Simulate groups Simulate batches There is no individual estimation step using SPsimSeq as the estimation is combined with simulation step.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data Simulating datasets using SPsimSeq Datasets with default parameters Determin the number of cells and genes Simulate groups Simulate batches Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::SPsimSeq_simulation( ref_data = ref_data, other_prior = NULL, return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 1 # de.prob: 0.1 # fc.group: 2 # nBatches: 1 # Warning in max(abs(logR)): no non-missing arguments to max; returning -Inf SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 3 columns # cell_name group batch # \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; # Cell1 Cell1 Group1 Batch1 # Cell2 Cell2 Group1 Batch1 # Cell3 Cell3 Group1 Batch1 # Cell4 Cell4 Group1 Batch1 # Cell5 Cell5 Group1 Batch1 # Cell6 Cell6 Group1 Batch1 head(rowData(SCE_result)) # DataFrame with 6 rows and 1 column # gene_name # \u0026lt;character\u0026gt; # Gene1 Gene1 # Gene2 Gene2 # Gene3 Gene3 # Gene4 Gene4 # Gene5 Gene5 # Gene6 Gene6 Determin the number of cells and genes simulate_result \u0026lt;- simmethods::SPsimSeq_simulation( ref_data = ref_data, other_prior = list(nCells = 500, nGenes = 1000), return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # fc.group: 2 # nBatches: 1 # Warning in max(abs(logR)): no non-missing arguments to max; returning -Inf SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 1000 500 Simulate groups The number of groups simulated by SPsimSeq is determined by the group information used in simulation step. If the group information of two cell states is provided, then the simulated dataset will contain two groups. SPsimSeq also provides other parameters related to DEGs such as the proportion of DEGs (de.prob) and the fold change of DGEs (fc.group).\nFor demonstration, we will simulate two groups using the learned parameters. We can set de.prob = 0.2 to simulate 20% genes as DEGs.\ngroup_condition \u0026lt;- as.numeric(simmethods::group_condition) simulate_result \u0026lt;- simmethods::SPsimSeq_simulation( ref_data = ref_data, other_prior = list(group.condition = group_condition, de.prob = 0.2, fc.group = 4), return_format = \u0026quot;list\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 2 # de.prob: 0.2 # fc.group: 4 # nBatches: 1 # Warning in max(abs(logR)): no non-missing arguments to max; returning -Inf # Note: The number of DE genes detected in the source data is 5 and the number of DE genes required to be included in the simulated data is 800. Therefore, candidiate DE genes are sampled with replacement. col_data \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(col_data$group) # # Group1 Group2 # 80 80 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(gene_info) ## de.prob = 0.2 # yes # 0.2 Simulate batches Users can simulate batches when batch.condition parameter is activated and just input the numeric vectors that specify the batch labels of cells.\nset.seed(111) ref_data \u0026lt;- scater::mockSCE(ncells = 160, ngenes = 4000) ref_data \u0026lt;- SingleCellExperiment::counts(ref_data) For demonstration, we will simulate two batches.\nsimulate_result \u0026lt;- simmethods::SPsimSeq_simulation( ref_data = ref_data, other_prior = list(batch.condition = sample(1:3, 160, replace = TRUE)), return_format = \u0026quot;list\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 1 # de.prob: 0.1 # fc.group: 2 # nBatches: 3 ## cell information col_data \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(col_data$batch) # # Batch1 Batch2 Batch3 # 50 58 52 "
},
{
	"uri": "/references/methods/20-esco/",
	"title": "ESCO",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using ESCO Datasets with default parameters Determin the number of cells and genes Simulate two or more groups Here ESCO method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data dim(ref_data) # [1] 4000 160 Using simmethods::ESCO_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::ESCO_estimation( ref_data = ref_data, verbose = T, seed = 10 ) # Registered S3 methods overwritten by \u0026#39;registry\u0026#39;: # method from # print.registry_field proxy # print.registry_entry proxy # Estimating parameters using ESCO ESCO is not stable, and some datasets can not be estimated due to the failing estimation.\nSimulating datasets using ESCO After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Simulate two or more groups Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group of cells.\nsimulate_result \u0026lt;- simmethods::ESCO_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 1 # de.group: 0.1 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 2 columns # cell_name group # \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; # Cell1 Cell1 Group1 # Cell2 Cell2 Group1 # Cell3 Cell3 Group1 # Cell4 Cell4 Group1 # Cell5 Cell5 Group1 # Cell6 Cell6 Group1 Determin the number of cells and genes In ESCO, we can set nCells and nGenes to specify the number of cells and genes.\nHere, we simulate a new dataset with 500 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::ESCO_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 500, nGenes = 1000), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 1 # de.group: 0.1 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 Simulate two or more groups In ESCO, we can not set nGroups directly and should set prob.group instead. For example, if we want to simulate 2 groups, we can type other_prior = list(prob.group = c(0.5, 0.5)). Note that the sum of prob.group numeric vector must equal to 1, so we can also set prob.group = c(0.3, 0.7).\nIn addtion, if we want to simulate three or more groups, we should obey the rules:\nThe length of prob.group vector must always equal to the number of groups. The sum of prob.group numeric vector must equal to 1. For demonstration, we will simulate three groups using the learned parameters.\nsimulate_result \u0026lt;- simmethods::ESCO_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 500, nGenes = 1000, prob.group = c(0.1, 0.3, 0.6)), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 3 # de.group: 0.1 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$group) # # Group1 Group2 Group3 # 47 168 285 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) ## de.prob = 0.1 # yes # 0.1 We can see that the proportion of differential expressed genes is 0.1 (equals to the default). Next, if we want to know the fold change between two groups, we will do division with the groups that we are interested in.\n## fc between group2 and group1 fc_group1_to_group2 \u0026lt;- gene_info$DEFacGroup2/gene_info$DEFacGroup1 ## fc between group3 and group1 fc_group1_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup1 ## fc between group3 and group2 fc_group2_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup2 "
},
{
	"uri": "/references/methods/21-sparsedc/",
	"title": "SparseDC",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using SparseDC Datasets with default parameters Determin the number of cells and genes Simulate two or more groups Here SparseDC method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- SingleCellExperiment::counts(scater::mockSCE()) dim(ref_data) # [1] 2000 200 set.seed(111) group_condition \u0026lt;- sample(1:2, ncol(ref_data), replace = TRUE) When you use SparseDC to estimate parameters from a real dataset, you must input a numeric vector to specify the groups or plates that each cell comes from, like other_prior = list(group.condition = the numeric vector).\nNote that SparseDC defines 2 clusters presented in the dataset by default and users can input other number if the estimation step failed through nclusters parameter.\nestimate_result \u0026lt;- simmethods::SparseDC_estimation( ref_data = ref_data, other_prior = list(group.condition = group_condition, nclusters = 2), verbose = T, seed = 10 ) # Estimating parameters using SparseDC SparseDC is not stable, and some datasets can not be estimated due to the failing estimation.\nSimulating datasets using SparseDC After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Simulate two or more groups Datasets with default parameters The reference data contains 200 cells and 2000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group of cells.\nsimulate_result \u0026lt;- simmethods::SparseDC_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 200 # nGenes: 2000 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 2000 200 Determin the number of cells and genes In SparseDC, we can set nCells and nGenes to specify the number of cells and genes.\nHere, we simulate a new dataset with 1000 cells and 1000 genes:\nNote that SparseDC defines 2 clusters in the estimation step by default and the number of cells is defined as nCells * nclusters.\nsimulate_result \u0026lt;- simmethods::SparseDC_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 500, nGenes = 1000), seed = 111 ) # nCells: 1000 # nGenes: 1000 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 1000 Simulate two or more groups In SparseDC, the number of groups is determined by the group information (group.condition parameter) used in estimation step. If the group information contains two cell states, and the simulated dataset will contain two groups of cells.\nThe demonstrations above use two groups of cells in the eatimation step, and the result will hold two groups.\n## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$group) # # Group1 Group2 # 500 500 "
},
{
	"uri": "/references/methods/22-muscat/",
	"title": "muscat",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Default eatimation Estimation with cell groups Simulating datasets using muscat Datasets with default parameters Determin the number of cells and genes Simulate two or more groups Here muscat method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data Default eatimation estimate_result \u0026lt;- simmethods::muscat_estimation( ref_data = ref_data, other_prior = NULL, verbose = T, seed = 10 ) # Estimating parameters using muscat # Filtering... # - 4000/4000 genes and 160/160 cells retained. # Estimating gene and cell parameters... Estimation with cell groups When you use muscat to estimate parameters from a real dataset, you can also input a numeric vector to specify the groups or plates that each cell comes from, like other_prior = list(group.condition = the numeric vector).\ngroup_condition \u0026lt;- as.numeric(simmethods::group_condition) estimate_result \u0026lt;- simmethods::muscat_estimation( ref_data = ref_data, other_prior = list(group.condition = group_condition), verbose = T, seed = 10 ) # Estimating parameters using muscat # Filtering... # - 4000/4000 genes and 160/160 cells retained. # Estimating gene and cell parameters... Simulating datasets using muscat After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Simulate two or more groups Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group of cells.\nsimulate_result \u0026lt;- simmethods::muscat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], other_prior = NULL, return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 1 # de.group: 0.1 # fc.group: 2 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 Determin the number of cells and genes In muscat, we can set nCells and nGenes to specify the number of cells and genes.\nHere, we simulate a new dataset with 1000 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::muscat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 1000, nGenes = 1000), seed = 111 ) # nCells: 1000 # nGenes: 1000 # nGroups: 1 # de.group: 0.1 # fc.group: 2 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 1000 Simulate two or more groups In muscat, we can set nGroups directly to specify the number of simulated groups. muscat also provides other parameters related to DEGs such as the proportion of DEGs (de.prob) and the fold change of DGEs (fc.group).\nFor demonstration, we will simulate two groups using the learned parameters.\nsimulate_result \u0026lt;- simmethods::muscat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 500, nGenes = 1000, nGroups = 2, de.prob = 0.4, fc.group = 4), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 2 # de.group: 0.4 # fc.group: 4 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$group) # # Group1 Group2 # 240 260 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) ## de.prob = 0.4 # yes # 0.384 "
},
{
	"uri": "/references/methods/23-hierarchicell/",
	"title": "hierarchicell",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using hierarchicell Datasets with default parameters Determin the number of cells and genes Here hierarchicell method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real.\nlibrary(simmethods) library(SingleCellExperiment) # Load data set.seed(111) ref_data \u0026lt;- SingleCellExperiment::counts(scater::mockSCE()) estimate_result \u0026lt;- simmethods::hierarchicell_estimation( ref_data = ref_data, other_prior = NULL, verbose = T, seed = 10 ) # Filtering user input # Genes and cells have been filtered, ready for estimating parameters # You do not set the type of the data (Raw or Norm), we will set \u0026#39;Raw\u0026#39; by default # Estimating parameters using hierarchicell # Normalizing ... # Removing highly correlated genes # Computing sample means, dropout rates, and dispersion ... # Computing final data summaries ... Simulating datasets using hierarchicell After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Datasets with default parameters The reference data contains 200 cells and 2000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nhierarchicell can only simulate two groups of cells.\nsimulate_result \u0026lt;- simmethods::hierarchicell_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], other_prior = NULL, return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 200 # nGenes: 2000 # nGroups: 2 # fc.group: 2 # Computing simulation parameters ... # ------------------------------------------------------- # Distribution of grand means is a gamma # with shape: 783 and rate: 0.15 # ------------------------------------------------------- # Distribution for gene-wise dropout is a gamma # with shape: 45767.5 and rate: 48102.92 # ------------------------------------------------------- # Function for dropout SD is: # DropoutStD = 0.07 + 0.78*DropOut + 15.41*(DropOut**2) # ------------------------------------------------------- # Function for inter-individual SD is: # InterStDev = 0 + 0.86*GrandMean) # ------------------------------------------------------- # Function for dispersion is: # exp(-10.58 + 2103.53/IntraMean) # ------------------------------------------------------- # Simulating cells ... # ------------------------------------------------------- # Simulating expression values ... # ------------------------------------------------------- # All done! SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 2000 200 Some cells in the result may contain NA values across all genes due to the failing of GLM fitting.\ncol_data \u0026lt;- as.data.frame(SingleCellExperiment::colData(SCE_result)) table(col_data$group) # # Group1 Group2 # 102 96 The hierarchicell method is not stable and usually causes failed simulation\nDetermin the number of cells and genes In hierarchicell, we can set nCells and nGenes to specify the number of cells and genes.\nHere, we simulate a new dataset with 1000 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::hierarchicell_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 1000, nGenes = 1000), seed = 111 ) # nCells: 1000 # nGenes: 1000 # nGroups: 2 # fc.group: 2 # Computing simulation parameters ... # ------------------------------------------------------- # Distribution of grand means is a gamma # with shape: 783 and rate: 0.15 # ------------------------------------------------------- # Distribution for gene-wise dropout is a gamma # with shape: 45767.5 and rate: 48102.92 # ------------------------------------------------------- # Function for dropout SD is: # DropoutStD = 0.07 + 0.78*DropOut + 15.41*(DropOut**2) # ------------------------------------------------------- # Function for inter-individual SD is: # InterStDev = 0 + 0.86*GrandMean) # ------------------------------------------------------- # Function for dispersion is: # exp(-10.58 + 2103.53/IntraMean) # ------------------------------------------------------- # Simulating cells ... # ------------------------------------------------------- # Simulating expression values ... # ------------------------------------------------------- # All done! result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 1000 "
},
{
	"uri": "/references/methods/24-dropsim/",
	"title": "dropsim",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using dropsim Datasets with default parameters Determin the number of cells and genes Here dropsim method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data estimate_result \u0026lt;- simmethods::dropsim_estimation( ref_data = ref_data, verbose = T, seed = 10 ) # Estimating parameters using dropsim Simulating datasets using dropsim After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group of cells.\nsimulate_result \u0026lt;- simmethods::dropsim_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], other_prior = NULL, return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 Determin the number of cells and genes In dropsim, we can set nCells and nGenes to specify the number of cells and genes.\nHere, we simulate a new dataset with 1000 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::dropsim_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 1000, nGenes = 1000), seed = 111 ) # nCells: 1000 # nGenes: 1000 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 1000 "
},
{
	"uri": "/references/methods/26-prosstt/",
	"title": "PROSSTT",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets with cell trajectory using PROSSTT Datasets with default parameters Determin the number of cells and genes Visualization Here PROSSTT method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data estimate_result \u0026lt;- simmethods::PROSSTT_estimation( ref_data = ref_data, verbose = T, seed = 10 ) # Estimating parameters using PROSSTT # Computing nearest neighbor graph # Computing SNN # Your data has 3 groups See the result:\nestimate_result[[\u0026quot;estimate_result\u0026quot;]][[\u0026quot;newick_tree\u0026quot;]] # [1] \u0026quot;(group3:372.624762582395,(group1:82.620878305447,group2:82.620878305447):372.624762582395);\u0026quot; You can obtain a tree structure of Newick format where cells can be sampled from to generate the datasets with trajectory. Then the hierarchical clustering is used to obtain the relationship between different groups. If no group information is provided like above codes, the groups or clusters are determined by Seurat pipeline.\nUsers can also input the group information of cells:\ngroup \u0026lt;- as.numeric(simmethods::group_condition) estimate_result \u0026lt;- simmethods::PROSSTT_estimation( ref_data = ref_data, other_prior = list(group.condition = group), verbose = T, seed = 10 ) # Estimating parameters using PROSSTT Simulating datasets with cell trajectory using PROSSTT After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Visualization Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::PROSSTT_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], other_prior = NULL, return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 160 4000 Determin the number of cells and genes In PROSSTT, we can set nCells and nGenes to specify the number of cells and genes.\nHere, we simulate a new dataset with 1000 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::PROSSTT_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 1000, nGenes = 1000), seed = 111 ) # nCells: 1000 # nGenes: 1000 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 1000 Visualization Make sure that you have already installed several R packages:\nif(!requireNamespace(\u0026quot;dynwrap\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynwrap\u0026quot;)} if(!requireNamespace(\u0026quot;dyndimred\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dyndimred\u0026quot;)} if(!requireNamespace(\u0026quot;dynplot\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynplot\u0026quot;)} if(!requireNamespace(\u0026quot;tislingshot\u0026quot;, quietly = TRUE)){devtools::install_github(\u0026quot;dynverse/ti_slingshot/package/\u0026quot;)} First we should wrap the data into a standard object:\ndyn_object \u0026lt;- dynwrap::wrap_expression(counts = t(result), expression = log2(t(result) + 1)) Next, we infer the trajectory using SlingShot which has been proved to be the most best method to do this:\nmodel \u0026lt;- dynwrap::infer_trajectory(dataset = dyn_object, method = tislingshot::ti_slingshot(), parameters = NULL, give_priors = NULL, seed = 111, verbose = TRUE) # Executing \u0026#39;slingshot\u0026#39; on \u0026#39;20230410_220055__data_wrapper__qIJvL2H1mS\u0026#39; # With parameters: list(cluster_method = \u0026quot;pam\u0026quot;, ndim = 20L, shrink = 1L, reweight = TRUE, reassign = TRUE, thresh = 0.001, maxit = 10L, stretch = 2L, smoother = \u0026quot;smooth.spline\u0026quot;, shrink.method = \u0026quot;cosine\u0026quot;) # inputs: expression # priors : # Using full covariance matrix Finally, we can plot the trajectory after performing dimensionality reduction:\ndimred \u0026lt;- dyndimred::dimred_umap(dyn_object$expression) dynplot::plot_dimred(model, dimred = dimred) # Coloring by milestone # Using milestone_percentages from trajectory For more details about trajectory inference and visualization, please check dynverse.\n"
},
{
	"uri": "/references/methods/27-tedsim/",
	"title": "TedSim",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets with cell trajectory using TedSim Datasets with default parameters Determin the number of cells and genes Visualization Here TedSim method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data estimate_result \u0026lt;- simmethods::TedSim_estimation( ref_data = ref_data, verbose = T, seed = 10 ) # The number of cells is not the power of 2, and we will synthesize some extra cells base on your data... # Performing k-means and determin the best number of clusters... # Add grouping to data... # Synthesize fake cells... # Add the synthesized data to the real data... # Done # Estimating parameters using TedSim TedSim can only simulate the dataset where the cell number is the power of 2, so if the reference data does not meet the requirement, the procedure will synthesize extra fake cells to achive this goal.\nUsers can also input the group information of cells and the k-means will not be used:\ngroup \u0026lt;- as.numeric(simmethods::group_condition) estimate_result \u0026lt;- simmethods::TedSim_estimation( ref_data = ref_data, other_prior = list(group.condition = group), verbose = T, seed = 10 ) # The number of cells is not the power of 2, and we will synthesize some extra cells base on your data... # Add grouping to data... # Synthesize fake cells... # Add the synthesized data to the real data... # Done # Estimating parameters using TedSim Simulating datasets with cell trajectory using TedSim After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of genes Visualization Datasets with default parameters The reference data contains 256 cells (160 real cells and 96 fake cells) and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::TedSim_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], other_prior = NULL, return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 256 # nGenes: 4000 # Warning in cbind(...): number of rows of result is not a multiple of vector # length (arg 3) SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 256 Determin the number of cells and genes In TedSim, we can set nGenes to specify the number of genes.\nHere, we simulate a new dataset with 1000 genes:\nsimulate_result \u0026lt;- simmethods::TedSim_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nGenes = 1000), seed = 111 ) # nCells: 256 # nGenes: 1000 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 256 Visualization Make sure that you have already installed several R packages:\nif(!requireNamespace(\u0026quot;dynwrap\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynwrap\u0026quot;)} if(!requireNamespace(\u0026quot;dyndimred\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dyndimred\u0026quot;)} if(!requireNamespace(\u0026quot;dynplot\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynplot\u0026quot;)} if(!requireNamespace(\u0026quot;tislingshot\u0026quot;, quietly = TRUE)){devtools::install_github(\u0026quot;dynverse/ti_slingshot/package/\u0026quot;)} First we should wrap the data into a standard object:\ndyn_object \u0026lt;- dynwrap::wrap_expression(counts = t(result), expression = log2(t(result) + 1)) Next, we infer the trajectory using SlingShot which has been proved to be the most best method to do this:\nmodel \u0026lt;- dynwrap::infer_trajectory(dataset = dyn_object, method = tislingshot::ti_slingshot(), parameters = NULL, give_priors = NULL, seed = 111, verbose = TRUE) # Executing \u0026#39;slingshot\u0026#39; on \u0026#39;20230411_105951__data_wrapper__N0pU35qVcY\u0026#39; # With parameters: list(cluster_method = \u0026quot;pam\u0026quot;, ndim = 20L, shrink = 1L, reweight = TRUE, reassign = TRUE, thresh = 0.001, maxit = 10L, stretch = 2L, smoother = \u0026quot;smooth.spline\u0026quot;, shrink.method = \u0026quot;cosine\u0026quot;) # inputs: expression # priors : # Using full covariance matrix Finally, we can plot the trajectory after performing dimensionality reduction:\ndimred \u0026lt;- dyndimred::dimred_umap(dyn_object$expression) dynplot::plot_dimred(model, dimred = dimred) # Coloring by milestone # Using milestone_percentages from trajectory For more details about trajectory inference and visualization, please check dynverse.\n"
},
{
	"uri": "/references/methods/28-dyntoy/",
	"title": "dyntoy",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets with cell trajectory using dyntoy Datasets with default parameters Determin the number of cells and genes Visualization Here dyntoy method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data To simulate trajectory datasets using dyntoy, we first performe trajectory inference analysis to the real data. If no group information is provided, the k-means algorithm is used to determine the number of clusters(groups) that the real data contains.\nestimate_result \u0026lt;- simmethods::dyntoy_estimation( ref_data = ref_data, verbose = T, seed = 10 ) # Performing k-means and determin the best number of clusters... # Add grouping to data... # Estimating parameters using dyntoy # Executing \u0026#39;slingshot\u0026#39; on \u0026#39;20230411_110500__data_wrapper__Up1tJGIOUk\u0026#39; # With parameters: list(cluster_method = \u0026quot;pam\u0026quot;, ndim = 20L, shrink = 1L, reweight = TRUE, reassign = TRUE, thresh = 0.001, maxit = 10L, stretch = 2L, smoother = \u0026quot;smooth.spline\u0026quot;, shrink.method = \u0026quot;cosine\u0026quot;) # inputs: expression # priors : # Using full covariance matrix Users can also input the group information of cells and the k-means will not be used:\ngroup \u0026lt;- as.numeric(simmethods::group_condition) estimate_result \u0026lt;- simmethods::dyntoy_estimation( ref_data = ref_data, other_prior = list(group.condition = group), verbose = T, seed = 10 ) # Add grouping to data... # Estimating parameters using dyntoy # Executing \u0026#39;slingshot\u0026#39; on \u0026#39;20230411_110504__data_wrapper__Kr1TdrsxL0\u0026#39; # With parameters: list(cluster_method = \u0026quot;pam\u0026quot;, ndim = 20L, shrink = 1L, reweight = TRUE, reassign = TRUE, thresh = 0.001, maxit = 10L, stretch = 2L, smoother = \u0026quot;smooth.spline\u0026quot;, shrink.method = \u0026quot;cosine\u0026quot;) # inputs: expression # priors : # Using full covariance matrix Simulating datasets with cell trajectory using dyntoy After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Visualization Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::dyntoy_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], other_prior = NULL, return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # de.prob: 0.1 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 Determin the number of cells and genes In dyntoy, we can set nCells and nGenes to specify the number of cells and genes.\nHere, we simulate a new dataset with 1000 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::dyntoy_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 1000, nGenes = 1000), seed = 111 ) # nCells: 1000 # nGenes: 1000 # de.prob: 0.1 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 1000 Visualization Make sure that you have already installed several R packages:\nif(!requireNamespace(\u0026quot;dynwrap\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynwrap\u0026quot;)} if(!requireNamespace(\u0026quot;dyndimred\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dyndimred\u0026quot;)} if(!requireNamespace(\u0026quot;dynplot\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynplot\u0026quot;)} if(!requireNamespace(\u0026quot;tislingshot\u0026quot;, quietly = TRUE)){devtools::install_github(\u0026quot;dynverse/ti_slingshot/package/\u0026quot;)} First we should wrap the data into a standard object:\ndyn_object \u0026lt;- dynwrap::wrap_expression(counts = t(result), expression = log2(t(result) + 1)) Next, we infer the trajectory using SlingShot which has been proved to be the most best method to do this:\nmodel \u0026lt;- dynwrap::infer_trajectory(dataset = dyn_object, method = tislingshot::ti_slingshot(), parameters = NULL, give_priors = NULL, seed = 111, verbose = TRUE) # Executing \u0026#39;slingshot\u0026#39; on \u0026#39;20230411_110527__data_wrapper__EuubW5InDz\u0026#39; # With parameters: list(cluster_method = \u0026quot;pam\u0026quot;, ndim = 20L, shrink = 1L, reweight = TRUE, reassign = TRUE, thresh = 0.001, maxit = 10L, stretch = 2L, smoother = \u0026quot;smooth.spline\u0026quot;, shrink.method = \u0026quot;cosine\u0026quot;) # inputs: expression # priors : # Using full covariance matrix Finally, we can plot the trajectory after performing dimensionality reduction:\ndimred \u0026lt;- dyndimred::dimred_umap(dyn_object$expression) dynplot::plot_dimred(model, dimred = dimred) # Coloring by milestone # Using milestone_percentages from trajectory For more details about trajectory inference and visualization, please check dynverse.\n"
},
{
	"uri": "/references/methods/30-symsim/",
	"title": "SymSim",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets with cell trajectory using SymSim Datasets with default parameters Determin the number of cells and genes Visualization Here SymSim method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data estimate_result \u0026lt;- simmethods::SymSim_estimation( ref_data = ref_data, verbose = T, seed = 10 ) # Estimating parameters using SymSim # Computing nearest neighbor graph # Computing SNN # Your data has 3 groups Users can also input the group information of cells:\ngroup \u0026lt;- as.numeric(simmethods::group_condition) estimate_result \u0026lt;- simmethods::SymSim_estimation( ref_data = ref_data, other_prior = list(group.condition = group), verbose = T, seed = 10 ) # Estimating parameters using SymSim Simulating datasets with cell trajectory using SymSim After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Visualization Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::SymSim_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], other_prior = NULL, return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 Determin the number of cells and genes In SymSim, we can set nCells and nGenes to specify the number of cells and genes.\nHere, we simulate a new dataset with 2000 cells and 2000 genes:\nsimulate_result \u0026lt;- simmethods::SymSim_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 2000, nGenes = 2000), seed = 111 ) # nCells: 2000 # nGenes: 2000 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 2000 2000 Visualization Make sure that you have already installed several R packages:\nif(!requireNamespace(\u0026quot;dynwrap\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynwrap\u0026quot;)} if(!requireNamespace(\u0026quot;dyndimred\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dyndimred\u0026quot;)} if(!requireNamespace(\u0026quot;dynplot\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynplot\u0026quot;)} if(!requireNamespace(\u0026quot;tislingshot\u0026quot;, quietly = TRUE)){devtools::install_github(\u0026quot;dynverse/ti_slingshot/package/\u0026quot;)} First we should wrap the data into a standard object:\ndyn_object \u0026lt;- dynwrap::wrap_expression(counts = t(result), expression = log2(t(result) + 1)) Next, we infer the trajectory using SlingShot which has been proved to be the most best method to do this:\nmodel \u0026lt;- dynwrap::infer_trajectory(dataset = dyn_object, method = tislingshot::ti_slingshot(), parameters = NULL, give_priors = NULL, seed = 111, verbose = TRUE) # Executing \u0026#39;slingshot\u0026#39; on \u0026#39;20230411_111516__data_wrapper__huyoq738bs\u0026#39; # With parameters: list(cluster_method = \u0026quot;pam\u0026quot;, ndim = 20L, shrink = 1L, reweight = TRUE, reassign = TRUE, thresh = 0.001, maxit = 10L, stretch = 2L, smoother = \u0026quot;smooth.spline\u0026quot;, shrink.method = \u0026quot;cosine\u0026quot;) # inputs: expression # priors : # Using full covariance matrix Finally, we can plot the trajectory after performing dimensionality reduction:\ndimred \u0026lt;- dyndimred::dimred_umap(dyn_object$expression) dynplot::plot_dimred(model, dimred = dimred) # Coloring by milestone # Using milestone_percentages from trajectory For more details about trajectory inference and visualization, please check dynverse.\n"
},
{
	"uri": "/references/methods/31-velosim/",
	"title": "VeloSim",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets with cell trajectory using VeloSim Datasets with default parameters Determin the number of cells and genes Visualization Here VeloSim method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data estimate_result \u0026lt;- simmethods::VeloSim_estimation( ref_data = ref_data, verbose = T, seed = 10 ) # Estimating parameters using VeloSim # Computing nearest neighbor graph # Computing SNN # Your data has 3 groups Users can also input the group information of cells:\ngroup \u0026lt;- as.numeric(simmethods::group_condition) estimate_result \u0026lt;- simmethods::VeloSim_estimation( ref_data = ref_data, other_prior = list(group.condition = group), verbose = T, seed = 10 ) # Estimating parameters using VeloSim Simulating datasets with cell trajectory using VeloSim After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Visualization Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::VeloSim_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], other_prior = NULL, return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 Determin the number of cells and genes In VeloSim, we can set nCells and nGenes to specify the number of cells and genes.\nHere, we simulate a new dataset with 200 cells and 2000 genes:\nsimulate_result \u0026lt;- simmethods::VeloSim_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 200, nGenes = 2000), seed = 111 ) # nCells: 200 # nGenes: 2000 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 2000 200 Visualization Make sure that you have already installed several R packages:\nif(!requireNamespace(\u0026quot;dynwrap\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynwrap\u0026quot;)} if(!requireNamespace(\u0026quot;dyndimred\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dyndimred\u0026quot;)} if(!requireNamespace(\u0026quot;dynplot\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynplot\u0026quot;)} if(!requireNamespace(\u0026quot;tislingshot\u0026quot;, quietly = TRUE)){devtools::install_github(\u0026quot;dynverse/ti_slingshot/package/\u0026quot;)} First we should wrap the data into a standard object:\ndyn_object \u0026lt;- dynwrap::wrap_expression(counts = t(result), expression = log2(t(result) + 1)) Next, we infer the trajectory using SlingShot which has been proved to be the most best method to do this:\nmodel \u0026lt;- dynwrap::infer_trajectory(dataset = dyn_object, method = tislingshot::ti_slingshot(), parameters = NULL, give_priors = NULL, seed = 111, verbose = TRUE) # Executing \u0026#39;slingshot\u0026#39; on \u0026#39;20230411_112131__data_wrapper__zj4D9ACXnS\u0026#39; # With parameters: list(cluster_method = \u0026quot;pam\u0026quot;, ndim = 20L, shrink = 1L, reweight = TRUE, reassign = TRUE, thresh = 0.001, maxit = 10L, stretch = 2L, smoother = \u0026quot;smooth.spline\u0026quot;, shrink.method = \u0026quot;cosine\u0026quot;) # inputs: expression # priors : # Using full covariance matrix Finally, we can plot the trajectory after performing dimensionality reduction:\ndimred \u0026lt;- dyndimred::dimred_umap(dyn_object$expression) dynplot::plot_dimred(model, dimred = dimred) # Coloring by milestone # Using milestone_percentages from trajectory For more details about trajectory inference and visualization, please check dynverse.\n"
},
{
	"uri": "/references/methods/32-mfa/",
	"title": "MFA",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets with cell trajectory using MFA Datasets with default parameters Determin the number of cells and genes Visualization Here MFA method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data MAF can only simulate datasets with bifurcation trajectory, so the estimation step may fail due to the intrinsic characteristics of real data.\nestimate_result \u0026lt;- simmethods::MFA_estimation( ref_data = ref_data, verbose = T, seed = 10 ) # Estimating parameters using MFA Simulating datasets with cell trajectory using MFA After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Visualization Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::MFA_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], other_prior = NULL, return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 Determin the number of cells and genes In MFA, we can set nCells and nGenes to specify the number of cells and genes.\nHere, we simulate a new dataset with 2000 cells and 2000 genes:\nsimulate_result \u0026lt;- simmethods::MFA_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 2000, nGenes = 2000), seed = 111 ) # nCells: 2000 # nGenes: 2000 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 2000 2000 Visualization Make sure that you have already installed several R packages:\nif(!requireNamespace(\u0026quot;dynwrap\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynwrap\u0026quot;)} if(!requireNamespace(\u0026quot;dyndimred\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dyndimred\u0026quot;)} if(!requireNamespace(\u0026quot;dynplot\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynplot\u0026quot;)} if(!requireNamespace(\u0026quot;tislingshot\u0026quot;, quietly = TRUE)){devtools::install_github(\u0026quot;dynverse/ti_slingshot/package/\u0026quot;)} First we should wrap the data into a standard object:\ndyn_object \u0026lt;- dynwrap::wrap_expression(counts = t(result), expression = log2(t(result) + 1)) Next, we infer the trajectory using SlingShot which has been proved to be the most best method to do this:\nmodel \u0026lt;- dynwrap::infer_trajectory(dataset = dyn_object, method = tislingshot::ti_slingshot(), parameters = NULL, give_priors = NULL, seed = 111, verbose = TRUE) # Executing \u0026#39;slingshot\u0026#39; on \u0026#39;20230411_113102__data_wrapper__XqXBjiGrL6\u0026#39; # With parameters: list(cluster_method = \u0026quot;pam\u0026quot;, ndim = 20L, shrink = 1L, reweight = TRUE, reassign = TRUE, thresh = 0.001, maxit = 10L, stretch = 2L, smoother = \u0026quot;smooth.spline\u0026quot;, shrink.method = \u0026quot;cosine\u0026quot;) # inputs: expression # priors : # Using full covariance matrix Finally, we can plot the trajectory after performing dimensionality reduction:\ndimred \u0026lt;- dyndimred::dimred_umap(dyn_object$expression) dynplot::plot_dimred(model, dimred = dimred) # Coloring by milestone # Using milestone_percentages from trajectory For more details about trajectory inference and visualization, please check dynverse.\n"
},
{
	"uri": "/references/methods/33-phenopath/",
	"title": "phenopath",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets with cell trajectory using phenopath Datasets with default parameters Determin the number of cells and genes Visualization Here phenopath method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data MAF can only simulate datasets with bifurcation trajectory, so the estimation step may fail due to the intrinsic characteristics of real data.\nestimate_result \u0026lt;- simmethods::phenopath_estimation( ref_data = ref_data, verbose = T, seed = 10 ) # Estimating parameters using phenopath Simulating datasets with cell trajectory using phenopath After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Visualization Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::phenopath_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], other_prior = NULL, return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 Determin the number of cells and genes In phenopath, we can set nCells and nGenes to specify the number of cells and genes.\nHere, we simulate a new dataset with 2000 cells and 2000 genes:\nsimulate_result \u0026lt;- simmethods::phenopath_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 2000, nGenes = 2000), seed = 11 ) # nCells: 2000 # nGenes: 2000 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 2000 2000 Visualization Make sure that you have already installed several R packages:\nif(!requireNamespace(\u0026quot;dynwrap\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynwrap\u0026quot;)} if(!requireNamespace(\u0026quot;dyndimred\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dyndimred\u0026quot;)} if(!requireNamespace(\u0026quot;dynplot\u0026quot;, quietly = TRUE)){install.packages(\u0026quot;dynplot\u0026quot;)} if(!requireNamespace(\u0026quot;tislingshot\u0026quot;, quietly = TRUE)){devtools::install_github(\u0026quot;dynverse/ti_slingshot/package/\u0026quot;)} First we should wrap the data into a standard object:\ndyn_object \u0026lt;- dynwrap::wrap_expression(counts = t(result), expression = log2(t(result) + 1)) Next, we infer the trajectory using SlingShot which has been proved to be the most best method to do this:\nmodel \u0026lt;- dynwrap::infer_trajectory(dataset = dyn_object, method = tislingshot::ti_slingshot(), parameters = NULL, give_priors = NULL, seed = 111, verbose = TRUE) However, the trajectory inference failed because of the inference method itself and we can choose MST method to try again.\nOpen your Docker Desktop and check your Docker execution status. If you do not install Docker, please turn to Docker homepage.\ndynwrap::test_docker_installation(detailed = TRUE) # ‚úî Docker is installed # ‚úî Docker daemon is running # ‚úî Docker is at correct version (\u0026gt;1.0): 1.41 # ‚úî Docker is in linux mode # ‚úî Docker can pull images # ‚úî Docker can run image # ‚úî Docker can mount temporary volumes # ‚úî Docker test successful ----------------------------------------------------------------- # [1] TRUE model \u0026lt;- dynwrap::infer_trajectory(dataset = dyn_object, method = \u0026quot;mst\u0026quot;, parameters = NULL, give_priors = NULL, seed = 111, verbose = FALSE) Finally, we can plot the trajectory after performing dimensionality reduction:\ndimred \u0026lt;- dyndimred::dimred_umap(dyn_object$expression) dynplot::plot_dimred(model, dimred = dimred) # Coloring by milestone # Using milestone_percentages from trajectory For more details about trajectory inference and visualization, please check dynverse.\n"
},
{
	"uri": "/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Overview simsite is a web-based reference vignettes for illustrating the usage of simulation methods for single-cell RNA sequencing data.\nIt contains three main sections:\nProgramming usage. All demonstrations and programming environment are in R. It shows a comprehensive pipeline from installing three main R packages (simutils, simmethods and simpipe) or just using simpipeDocker, estimating parameters from real data, simulating different kinds of new datasets and evaluating the simulated datasets.\nOnline usage. It contains some methods that show the best performance and users can simulate new datasets fast and conveniently.\nReferences. simmethods is the core package in our project. We collected 42+ methods and bundled them into a single package. For each method, we have already prepared a detailed vignette for users to learn to use the methods they are interested in.\nQuick start Programming start ‚¨Ö\nInstall R packages or download Docker images ‚¨Ö\nOnline usage start ‚¨Ö\nFeatures A comprehensive collection of simulation methods for single-cell RNA sequencing data.\nA Docker image is provided to help users establish the simulation environment easily and users can use it in local R.\nBoth local programming environment and interactive online tool can be used.\nDetailed vignettes for every simulation methods using simmethods package.\nCitation A comparison of simulation methods for single-cell RNA sequencing data.\nHelp and Issues If you need help or have any issue about our tools and vignettes. Send an email to duohongrui (duohongrui@cqnu.edu.cn) or raise an issue on github.\nNew Methods We are glad to add new simulation methods (especially for simulating spatial transcriptomics data) if some methods are innovative and creative that many users commonly used. If you have the requirements, please tell Hongrui Duo by email (duohongrui@cqnu.edu.cn) or raise an issue for that.\n"
},
{
	"uri": "/references/methods/",
	"title": "Vignettes",
	"tags": [],
	"description": "",
	"content": "Chapter X Some Chapter title Lorem Ipsum.\n"
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]