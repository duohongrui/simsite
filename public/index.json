[
{
	"uri": "/programming/",
	"title": "Programming Usage",
	"tags": [],
	"description": "",
	"content": "Programming Usage simpipe provides a pipeline from estimating parameters from real data, simulating new datasets from learned parameters and evaluating new datasets with real data. üë®‚Äçüíªüë®üèª‚Äçüíªüë®üèº‚Äçüíª\nInstallation Estimation Simulation Evaluation "
},
{
	"uri": "/online/1-choose_methods/",
	"title": "Choose Methods",
	"tags": [],
	"description": "",
	"content": " Installation Guide Installation Guide A\ndevtools::install_github(\u0026quot;duohongrui/simpipe\u0026quot;) B\nprint(\u0026quot;Hello World!\u0026quot;) [1] \u0026quot;Hello World!\u0026quot; "
},
{
	"uri": "/programming/1-installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": " Installation from Github Download Docker Image Install Docker Desktop Install simpipeDocker Download simpipe Docker Image There are two ways to install dependencies and set programming environment:\ninstall multiple R packages and dependencies from github, it may take 5-30 mins.\ninstall Docker first and download simpipe Docker image from DockerHub. All manipulations in R can be done by simpipeDoker package.\nInstallation from Github You can install the development version of simutils, simmethods and simpipe from GitHub with:\n# install.packages(\u0026quot;devtools\u0026quot;) devtools::install_github(\u0026quot;duohongrui/simutils\u0026quot;) devtools::install_github(\u0026quot;duohongrui/simmethods\u0026quot;) devtools::install_github(\u0026quot;duohongrui/simpipe\u0026quot;) If you want to use simpipe to simulate datasets with trajectory information, please install tislingshot first by:\ndevtools::install_github(\u0026quot;dynverse/ti_slingshot/package/\u0026quot;) Download Docker Image Install Docker Desktop If you have not installed official Docker Desktop, please click here and follow the instructions to install it. The version of Docker Desktop for Apple Chip is available\nAfter installing Docker, start Docker service, open an R session and type dynwrap::test_docker_installation(detailed = TRUE):\ndynwrap::test_docker_installation(detailed = TRUE) ‚úî Docker is installed ‚úî Docker daemon is running ‚úî Docker is at correct version (\u0026gt;1.0): 1.41 ‚úî Docker is in linux mode ‚úî Docker can pull images ‚úî Docker can run image ‚úî Docker can mount temporary volumes ‚úî Docker test successful ----------------------------------------------------------------- [1] TRUE If it is TRUE in the result, that means Docker is successfully installed.\nInstall simpipeDocker Download simpipe Docker Image Use babelwhale::pull_container(\"duohongrui/simpipe\") command to pull simpipe Docker image in R (it will take 3-10 mins):\n# install.packages(\u0026quot;babelwhale\u0026quot;) babelwhale::pull_container(\u0026quot;duohongrui/simpipe\u0026quot;) Once the image has been downloaded, check the image list:\nbabelwhale::list_docker_images(\u0026quot;duohongrui/simutils_scgan\u0026quot;) ID Repository Tag 1 c3b3d01cde78 duohongrui/simutils_scgan latest Digest 1 sha256:b4ea92956c521753b832960e39e9e76a25aa0138fbc6549304a6a0a59edb2190 CreatedSince CreatedAt Size 1 6 days ago 2022-09-07 23:16:34 +0800 CST 2.37GB Until now, you have successfully established the programming environment üëçüëçüëç. Go to the next page.üëàÔ∏è\n"
},
{
	"uri": "/references/1-methods_list/",
	"title": "Methods List",
	"tags": [],
	"description": "",
	"content": " R Markdown Including Plots Methods R Markdown This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com.\nWhen you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:\nsummary(cars) ## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00 Including Plots You can also embed plots, for example:\nNote that the echo = FALSE parameter was added to the code chunk to prevent printing of the R code that generated the plot.\nMethods Splat\n"
},
{
	"uri": "/references/methods/splat/",
	"title": "Splat",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using Splat Datasets with default parameters Determin the number of cells and genes Simulate two or more groups Simulate two or more batches Simulate more groups and batches simutaniously Return results with different format Here Splat method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data dim(ref_data) # [1] 4000 160 Using simmethods::Splat_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::Splat_estimation(ref_data = ref_data, verbose = T, seed = 10) # Estimating parameters using Splat Simulating datasets using Splat After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Simulate two or more groups Simulate two or more batches Simulate more groups and batches simutaniously Return results with different format Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group and one batch of cells.\nsimulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 3 columns # cell_name batch group # \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; # Cell1 Cell1 Batch1 Group1 # Cell2 Cell2 Batch1 Group1 # Cell3 Cell3 Batch1 Group1 # Cell4 Cell4 Batch1 Group1 # Cell5 Cell5 Batch1 Group1 # Cell6 Cell6 Batch1 Group1 head(rowData(SCE_result)) # DataFrame with 6 rows and 1 column # gene_name # \u0026lt;character\u0026gt; # Gene1 Gene1 # Gene2 Gene2 # Gene3 Gene3 # Gene4 Gene4 # Gene5 Gene5 # Gene6 Gene6 Determin the number of cells and genes In Splat, we can not set nCells directly and should set batchCells instead. For example, if we want to simulate 500 cells, we can type other_prior = list(batchCells = 500). For genes, we can just set nGenes. Here, we simulate a new dataset with 500 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = 500, nGenes = 1000), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 Simulate two or more groups In Splat, we can not set nGroups directly and should set prob.group instead. For example, if we want to simulate 2 groups, we can type other_prior = list(prob.group = c(0.5, 0.5)). Note that the sum of prob.group numeric vector must equal to 1, so we can also set prob.group = c(0.3, 0.7).\nIn addtion, if we want to simulate three or more groups, we should obey the rules:\nThe length of prob.group vector must always equal to the number of groups. The sum of prob.group numeric vector must equal to 1. For demonstration, we will simulate three groups using the learned parameters.\nsimulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = 500, nGenes = 1000, prob.group = c(0.1, 0.3, 0.6)), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 3 # de.prob: 0.1 # nBatches: 1 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$group) # # Group1 Group2 Group3 # 46 156 298 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) ## de.prob = 0.1 # yes # 0.1 We can see that the proportion of differential expressed genes is 0.1 (equals to the default). Next, if we want to know the fold change between two groups, we will do division with the groups that we are interested in.\n## fc between group2 and group1 fc_group1_to_group2 \u0026lt;- gene_info$DEFacGroup2/gene_info$DEFacGroup1 ## fc between group3 and group1 fc_group1_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup1 ## fc between group3 and group2 fc_group2_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup2 Simulate two or more batches In Splat, we can not set nBatches directly and should set batchCells instead. For example, if we want to simulate 2 batches, we can type other_prior = list(batchCells = c(250, 250)). Note that the sum of batchCells numeric vector represents the total number of cells and the length of the vector equals to the number of batches.\nIn addtion, if we want to simulate three or more batches, we should obey the rules:\nThe length of batchCells vector always equals to the number of batches. The sum of batchCells numeric vector represents the total number of cells. For demonstration, we will simulate three batches using the learned parameters.\nsimulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = c(200, 300), nGenes = 1000), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 2 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$batch) # # Batch1 Batch2 # 200 300 Simulate more groups and batches simutaniously As mentioned before, we can set prob.group and batchCells to determine the number of groups and batches and we can also set de.prob to specify the proportion of DEGs. Here, we simulate a dataset with following settings:\n1000 cells 5000 genes three groups with 0.2 proportion of DEGs two batches simulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = c(500, 500), nGenes = 5000, de.prob = 0.2, prob.group = c(0.2, 0.3, 0.5)), seed = 111 ) # nCells: 1000 # nGenes: 5000 # nGroups: 3 # de.prob: 0.2 # nBatches: 2 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 5000 1000 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$batch) # # Batch1 Batch2 # 500 500 table(cell_info$group) # # Group1 Group2 Group3 # 186 321 493 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) # yes # 0.1932 ### fc fc_group2_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup2 Return results with different format In simmethods package, we provide four formats of results to users without data format conversion, including list, SingleCellExperiment, Seurat and h5ad. The previous three formats are compatible with R environment and the last h5ad format is suitable for Python environment and can be imported by scanpy.read_h5ad function.\nlist simulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = c(100, 100), nGenes = 1000, de.prob = 0.1, prob.group = c(0.2, 0.3, 0.5)), seed = 111 ) # nCells: 200 # nGenes: 1000 # nGroups: 3 # de.prob: 0.1 # nBatches: 2 str(simulate_result) # List of 2 # $ simulate_result :List of 3 # ..$ count_data: int [1:1000, 1:200] 16 18 14 40 5 23 9 694 27 21 ... # .. ..- attr(*, \u0026quot;dimnames\u0026quot;)=List of 2 # .. .. ..$ : chr [1:1000] \u0026quot;Gene1\u0026quot; \u0026quot;Gene2\u0026quot; \u0026quot;Gene3\u0026quot; \u0026quot;Gene4\u0026quot; ... # .. .. ..$ : chr [1:200] \u0026quot;Cell1\u0026quot; \u0026quot;Cell2\u0026quot; \u0026quot;Cell3\u0026quot; \u0026quot;Cell4\u0026quot; ... # ..$ col_meta :\u0026#39;data.frame\u0026#39;: 200 obs. of 3 variables: # .. ..$ cell_name: chr [1:200] \u0026quot;Cell1\u0026quot; \u0026quot;Cell2\u0026quot; \u0026quot;Cell3\u0026quot; \u0026quot;Cell4\u0026quot; ... # .. ..$ batch : chr [1:200] \u0026quot;Batch1\u0026quot; \u0026quot;Batch1\u0026quot; \u0026quot;Batch1\u0026quot; \u0026quot;Batch1\u0026quot; ... # .. ..$ group : Factor w/ 3 levels \u0026quot;Group1\u0026quot;,\u0026quot;Group2\u0026quot;,..: 2 2 3 2 3 3 3 2 3 3 ... # ..$ row_meta :\u0026#39;data.frame\u0026#39;: 1000 obs. of 7 variables: # .. ..$ gene_name : chr [1:1000] \u0026quot;Gene1\u0026quot; \u0026quot;Gene2\u0026quot; \u0026quot;Gene3\u0026quot; \u0026quot;Gene4\u0026quot; ... # .. ..$ de_gene : chr [1:1000] \u0026quot;no\u0026quot; \u0026quot;no\u0026quot; \u0026quot;no\u0026quot; \u0026quot;no\u0026quot; ... # .. ..$ BatchFacBatch1: num [1:1000] 0.91 0.977 1.054 1.171 1.002 ... # .. ..$ BatchFacBatch2: num [1:1000] 1.105 0.95 0.76 0.776 0.996 ... # .. ..$ DEFacGroup1 : num [1:1000] 1 1 1 1 1 1 1 1 1 1 ... # .. ..$ DEFacGroup2 : num [1:1000] 1 1 1 1 1 1 1 1 1 1 ... # .. ..$ DEFacGroup3 : num [1:1000] 1 1 1 1 1 1 1 1 1 1 ... # $ simulate_detection:\u0026#39;data.frame\u0026#39;: 1 obs. of 4 variables: # ..$ Function_Call : chr \u0026quot;simulate_result\u0026lt;-splatter::splatSimulate(parameters,method=submethod,verbose=verbose)\u0026quot; # ..$ Elapsed_Time_sec : num 0.165 # ..$ Total_RAM_Used_MiB: num 7 # ..$ Peak_RAM_Used_MiB : num 4779828 counts \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] head(cell_info) # cell_name batch group # Cell1 Cell1 Batch1 Group2 # Cell2 Cell2 Batch1 Group2 # Cell3 Cell3 Batch1 Group3 # Cell4 Cell4 Batch1 Group2 # Cell5 Cell5 Batch1 Group3 # Cell6 Cell6 Batch1 Group3 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] head(gene_info) # gene_name de_gene BatchFacBatch1 BatchFacBatch2 DEFacGroup1 DEFacGroup2 # Gene1 Gene1 no 0.9098860 1.1054169 1 1 # Gene2 Gene2 no 0.9774161 0.9501320 1 1 # Gene3 Gene3 no 1.0541276 0.7597880 1 1 # Gene4 Gene4 no 1.1708139 0.7762219 1 1 # Gene5 Gene5 no 1.0017116 0.9963063 1 1 # Gene6 Gene6 no 0.7654326 1.1497335 1 1 # DEFacGroup3 # Gene1 1 # Gene2 1 # Gene3 1 # Gene4 1 # Gene5 1 # Gene6 1 SingleCellExperiment simulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SingleCellExperiment\u0026quot;, other_prior = list(batchCells = c(100, 100), nGenes = 1000, de.prob = 0.1, prob.group = c(0.2, 0.3, 0.5)), seed = 111 ) # nCells: 200 # nGenes: 1000 # nGroups: 3 # de.prob: 0.1 # nBatches: 2 counts \u0026lt;- counts(simulate_result[[\u0026quot;simulate_result\u0026quot;]]) ## cell information cell_info \u0026lt;- as.data.frame(colData(simulate_result[[\u0026quot;simulate_result\u0026quot;]])) head(cell_info) # cell_name batch group # Cell1 Cell1 Batch1 Group2 # Cell2 Cell2 Batch1 Group2 # Cell3 Cell3 Batch1 Group3 # Cell4 Cell4 Batch1 Group2 # Cell5 Cell5 Batch1 Group3 # Cell6 Cell6 Batch1 Group3 ## gene information gene_info \u0026lt;- as.data.frame(rowData(simulate_result[[\u0026quot;simulate_result\u0026quot;]])) head(gene_info) # gene_name de_gene BatchFacBatch1 BatchFacBatch2 DEFacGroup1 DEFacGroup2 # Gene1 Gene1 no 0.9098860 1.1054169 1 1 # Gene2 Gene2 no 0.9774161 0.9501320 1 1 # Gene3 Gene3 no 1.0541276 0.7597880 1 1 # Gene4 Gene4 no 1.1708139 0.7762219 1 1 # Gene5 Gene5 no 1.0017116 0.9963063 1 1 # Gene6 Gene6 no 0.7654326 1.1497335 1 1 # DEFacGroup3 # Gene1 1 # Gene2 1 # Gene3 1 # Gene4 1 # Gene5 1 # Gene6 1 Seurat simulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;Seurat\u0026quot;, other_prior = list(batchCells = c(100, 100), nGenes = 1000, de.prob = 0.1, prob.group = c(0.2, 0.3, 0.5)), seed = 111 ) # nCells: 200 # nGenes: 1000 # nGroups: 3 # de.prob: 0.1 # nBatches: 2 seurat_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] ## Overview seurat_result # An object of class Seurat # 1000 features across 200 samples within 1 assay # Active assay: originalexp (1000 features, 0 variable features) ## count matrix counts \u0026lt;- seurat_result@assays$originalexp@counts counts[1:10, 1:10] # 10 x 10 sparse Matrix of class \u0026quot;dgCMatrix\u0026quot; # [[ suppressing 10 column names \u0026#39;Cell1\u0026#39;, \u0026#39;Cell2\u0026#39;, \u0026#39;Cell3\u0026#39; ... ]] # # Gene1 16 . 7 5 . . . 11 220 1 # Gene2 18 . 12 10 . 1 1 32 222 2 # Gene3 14 . 4 2 1 . . 23 101 5 # Gene4 40 1 13 18 . 1 1 27 464 5 # Gene5 5 . 2 4 . . . 6 93 2 # Gene6 23 . 6 11 . . . 14 334 5 # Gene7 9 . 13 2 . . . 13 189 . # Gene8 694 7 509 229 26 6 12 774 7932 61 # Gene9 27 . 16 6 2 1 . 12 311 . # Gene10 21 . 13 6 . . . 24 199 5 ## cell information cell_info \u0026lt;- seurat_result@meta.data head(cell_info) # orig.ident nCount_originalexp nFeature_originalexp cell_name batch # Cell1 SeuratProject 65963 975 Cell1 Batch1 # Cell2 SeuratProject 1167 301 Cell2 Batch1 # Cell3 SeuratProject 45665 958 Cell3 Batch1 # Cell4 SeuratProject 26395 911 Cell4 Batch1 # Cell5 SeuratProject 3059 488 Cell5 Batch1 # Cell6 SeuratProject 1998 393 Cell6 Batch1 # group # Cell1 Group2 # Cell2 Group2 # Cell3 Group3 # Cell4 Group2 # Cell5 Group3 # Cell6 Group3 ## gene information gene_info \u0026lt;- seurat_result@assays[[\u0026quot;originalexp\u0026quot;]]@meta.features head(gene_info) # gene_name de_gene BatchFacBatch1 BatchFacBatch2 DEFacGroup1 DEFacGroup2 # Gene1 Gene1 no 0.9098860 1.1054169 1 1 # Gene2 Gene2 no 0.9774161 0.9501320 1 1 # Gene3 Gene3 no 1.0541276 0.7597880 1 1 # Gene4 Gene4 no 1.1708139 0.7762219 1 1 # Gene5 Gene5 no 1.0017116 0.9963063 1 1 # Gene6 Gene6 no 0.7654326 1.1497335 1 1 # DEFacGroup3 # Gene1 1 # Gene2 1 # Gene3 1 # Gene4 1 # Gene5 1 # Gene6 1 h5ad If we select h5ad format, it is not possible to return the result in R, so you can get the path where the h5ad files save to and we can go to the path and read it in Python by scanpy.read_h5ad function (if you have already installed Python and scanpy module).\nsimulate_result \u0026lt;- simmethods::Splat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;h5ad\u0026quot;, other_prior = list(batchCells = c(100, 100), nGenes = 1000, de.prob = 0.1, prob.group = c(0.2, 0.3, 0.5)), seed = 111 ) # nCells: 200 # nGenes: 1000 # nGroups: 3 # de.prob: 0.1 # nBatches: 2 # Creating h5Seurat file for version 3.1.5.9900 # Adding counts for originalexp # Adding data for originalexp # No variable features found for originalexp # Adding feature-level metadata for originalexp # Validating h5Seurat file # Adding data from originalexp as X # Transfering meta.features to var # Adding counts from originalexp as raw # Transfering meta.features to raw/var # Transfering meta.data to obs # Your data has been save to /var/folders/1l/xmc98tgx0m37wxtbtwnl6h7c0000gn/T//Rtmp5AFBiZ/20230218170540.h5ad save_path \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;save_path\u0026quot;]] save_path # [1] \u0026quot;/var/folders/1l/xmc98tgx0m37wxtbtwnl6h7c0000gn/T//Rtmp5AFBiZ/20230218170540.h5ad\u0026quot; Now, we can go to the path and check the data. Here, we read the h5ad file in R using reticulate R package (note that Python and scanpy module must have been installed).\n## install.packages(\u0026quot;reticulate\u0026quot;) scanpy \u0026lt;- reticulate::import(\u0026quot;scanpy\u0026quot;) data \u0026lt;- scanpy$read_h5ad(save_path) data ## Read h5ad file successfully # AnnData object with n_obs √ó n_vars = 200 √ó 1000 # obs: \u0026#39;orig.ident\u0026#39;, \u0026#39;nCount_originalexp\u0026#39;, \u0026#39;nFeature_originalexp\u0026#39;, \u0026#39;cell_name\u0026#39;, \u0026#39;batch\u0026#39;, \u0026#39;group\u0026#39; # var: \u0026#39;gene_name\u0026#39;, \u0026#39;de_gene\u0026#39;, \u0026#39;BatchFacBatch1\u0026#39;, \u0026#39;BatchFacBatch2\u0026#39;, \u0026#39;DEFacGroup1\u0026#39;, \u0026#39;DEFacGroup2\u0026#39;, \u0026#39;DEFacGroup3\u0026#39; "
},
{
	"uri": "/online/",
	"title": "Online Usage",
	"tags": [],
	"description": "",
	"content": "Online Usage simsite provides a guide tool for choosing suitable methods and another way for simulating single-cell RNA sequencing data online fast and conveniently. üíªüíªüíª\nChoose methods Simulation online "
},
{
	"uri": "/programming/2-estimation/",
	"title": "Estimation Parameters",
	"tags": [],
	"description": "",
	"content": " R Markdown Including Plots R Markdown This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com.\nWhen you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:\nsummary(cars) ## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00 Including Plots You can also embed plots, for example:\n"
},
{
	"uri": "/references/methods/simple/",
	"title": "Simple",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using Simple Datasets with default parameters Determin the number of cells and genes Here Simple method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data dim(ref_data) # [1] 4000 160 Using simmethods::Simple_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::Simple_estimation(ref_data = ref_data, verbose = T, seed = 10) # Estimating parameters using Simple Simulating datasets using Simple After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::Simple_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 1 column # cell_name # \u0026lt;character\u0026gt; # Cell1 Cell1 # Cell2 Cell2 # Cell3 Cell3 # Cell4 Cell4 # Cell5 Cell5 # Cell6 Cell6 head(rowData(SCE_result)) # DataFrame with 6 rows and 1 column # gene_name # \u0026lt;character\u0026gt; # Gene1 Gene1 # Gene2 Gene2 # Gene3 Gene3 # Gene4 Gene4 # Gene5 Gene5 # Gene6 Gene6 Determin the number of cells and genes Here, we simulate a new dataset with 500 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::Simple_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 500, nGenes = 1000), seed = 111 ) # nCells: 500 # nGenes: 1000 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 "
},
{
	"uri": "/online/2-simulation_online/",
	"title": "Simulation Online",
	"tags": [],
	"description": "",
	"content": " R Markdown Including Plots R Markdown This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com.\nWhen you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:\nsummary(cars) ## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00 Including Plots You can also embed plots, for example:\nNote that the echo = FALSE parameter was added to the code chunk to prevent printing of the R code that generated the plot.\n"
},
{
	"uri": "/references/",
	"title": "References",
	"tags": [],
	"description": "",
	"content": "References simmethods is the core package in the project. It contains 42+ simulation methods for single-cell RNA sequencing data. üìöüìöüìö\nMethods List: overview of all simulation methods and available parameters for every method Vignettes: detailed descriptional usage for every method "
},
{
	"uri": "/references/methods/kersplat/",
	"title": "Kersplat",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using Kersplat Datasets with default parameters Determin the number of cells and genes Here Kersplat method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data dim(ref_data) # [1] 4000 160 Using simmethods::Kersplat_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::Kersplat_estimation(ref_data = ref_data, verbose = T, seed = 10) # Estimating parameters using Kersplat # Warning in newKersplatParams(): The Kersplat simulation is still experimental # and may produce unreliable results. Please try it and report any issues to # https://github.com/Oshlack/splatter/issues. The development version may have # improved features. # Raw: 0.180467969462491 A: 5.24644589782513 B: 1.56749149061734 C: -3.99991188833989 Y: 0.796802242740237 # Warning in kersplatEstBCV(counts, params, verbose): Exponential corrected BCV is # negative.Using linear correction. # Warning in kersplatEstBCV(counts, params, verbose): Linear corrected BCV is # negative.Using existing bcv.common. Simulating datasets using Kersplat After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nsimulate_result \u0026lt;- simmethods::Kersplat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 1 column # cell_name # \u0026lt;character\u0026gt; # Cell1 Cell1 # Cell2 Cell2 # Cell3 Cell3 # Cell4 Cell4 # Cell5 Cell5 # Cell6 Cell6 Determin the number of cells and genes Here, we simulate a new dataset with 500 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::Kersplat_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 500, nGenes = 1000), seed = 111 ) # nCells: 500 # nGenes: 1000 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 "
},
{
	"uri": "/programming/3-simulation/",
	"title": "Simulation",
	"tags": [],
	"description": "",
	"content": " R Markdown Including Plots R Markdown This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com.\nWhen you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:\nsummary(cars) ## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00 Including Plots You can also embed plots, for example:\nNote that the echo = FALSE parameter was added to the code chunk to prevent printing of the R code that generated the plot.\n"
},
{
	"uri": "/programming/4-evaluate_datasets/",
	"title": "Evaluation Datasets",
	"tags": [],
	"description": "",
	"content": " R Markdown Including Plots R Markdown This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com.\nWhen you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:\nsummary(cars) ## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00 Including Plots You can also embed plots, for example:\nNote that the echo = FALSE parameter was added to the code chunk to prevent printing of the R code that generated the plot.\n"
},
{
	"uri": "/references/methods/splatpop/",
	"title": "SplatPop",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using SplatPop Datasets with default parameters Determin the number of cells and genes Simulate two or more groups Simulate two or more batches Simulate more groups and batches simutaniously Here SplatPop method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data dim(ref_data) # [1] 4000 160 Using simmethods::SplatPop_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::SplatPop_estimation(ref_data = ref_data, verbose = T, seed = 10) # Estimating parameters using SplatPop # Warning: no function found corresponding to methods exports from \u0026#39;BSgenome\u0026#39; for: # \u0026#39;releaseName\u0026#39; Simulating datasets using SplatPop After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Simulate two or more groups Simulate two or more batches Simulate more groups and batches simutaniously Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group and one batch of cells.\nsimulate_result \u0026lt;- simmethods::SplatPop_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 3 columns # cell_name batch group # \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; # Cell1 Cell1 Batch1 Group1 # Cell2 Cell2 Batch1 Group1 # Cell3 Cell3 Batch1 Group1 # Cell4 Cell4 Batch1 Group1 # Cell5 Cell5 Batch1 Group1 # Cell6 Cell6 Batch1 Group1 head(rowData(SCE_result)) # DataFrame with 6 rows and 1 column # gene_name # \u0026lt;character\u0026gt; # Gene1 Gene1 # Gene2 Gene2 # Gene3 Gene3 # Gene4 Gene4 # Gene5 Gene5 # Gene6 Gene6 Determin the number of cells and genes In SplatPop, we can not set nCells directly and should set batchCells instead. For example, if we want to simulate 500 cells, we can type other_prior = list(batchCells = 500). For genes, we can just set nGenes. Here, we simulate a new dataset with 500 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::SplatPop_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = 500, nGenes = 1000), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 Simulate two or more groups In SplatPop, we can not set nGroups directly and should set prob.group instead. For example, if we want to simulate 2 groups, we can type other_prior = list(prob.group = c(0.5, 0.5)). Note that the sum of prob.group numeric vector must equal to 1, so we can also set prob.group = c(0.3, 0.7).\nIn addtion, if we want to simulate three or more groups, we should obey the rules:\nThe length of prob.group vector must always equal to the number of groups. The sum of prob.group numeric vector must equal to 1. For demonstration, we will simulate three groups using the learned parameters.\nsimulate_result \u0026lt;- simmethods::SplatPop_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = 500, nGenes = 1000, prob.group = c(0.1, 0.3, 0.6)), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 3 # de.prob: 0.1 # nBatches: 1 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$group) # # Group1 Group2 Group3 # 50 150 300 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) ## de.prob = 0.1 # yes # 0.094 We can see that the proportion of differential expressed genes is 0.1 (equals to the default). Next, if we want to know the fold change between two groups, we will do division with the groups that we are interested in.\n## fc between group2 and group1 fc_group1_to_group2 \u0026lt;- gene_info$DEFacGroup2/gene_info$DEFacGroup1 ## fc between group3 and group1 fc_group1_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup1 ## fc between group3 and group2 fc_group2_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup2 Simulate two or more batches In SplatPop, we can not set nBatches directly and should set batchCells instead. For example, if we want to simulate 2 batches, we can type other_prior = list(batchCells = c(250, 250)). Note that the sum of batchCells numeric vector represents the total number of cells and the length of the vector equals to the number of batches.\nIn addtion, if we want to simulate three or more batches, we should obey the rules:\nThe length of batchCells vector always equals to the number of batches. The sum of batchCells numeric vector represents the total number of cells. For demonstration, we will simulate three batches using the learned parameters.\nsimulate_result \u0026lt;- simmethods::SplatPop_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = c(200, 300), nGenes = 1000), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 2 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$batch) # # Batch1 Batch2 # 210 290 Simulate more groups and batches simutaniously As mentioned before, we can set prob.group and batchCells to determine the number of groups and batches and we can also set de.prob to specify the proportion of DEGs. Here, we simulate a dataset with following settings:\n1000 cells 5000 genes three groups with 0.2 proportion of DEGs two batches simulate_result \u0026lt;- simmethods::SplatPop_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = c(500, 500), nGenes = 5000, de.prob = 0.2, prob.group = c(0.2, 0.3, 0.5)), seed = 111 ) # nCells: 1000 # nGenes: 5000 # nGroups: 3 # de.prob: 0.2 # nBatches: 2 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 5000 1000 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$batch) # # Batch1 Batch2 # 502 498 table(cell_info$group) # # Group1 Group2 Group3 # 220 302 478 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) # yes # 0.195 ### fc fc_group2_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup2 "
},
{
	"uri": "/references/methods/5-lun/",
	"title": "Lun",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using Lun Datasets with default parameters Determin the number of cells and genes Simulate two or more groups Here Lun method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data dim(ref_data) # [1] 4000 160 Using simmethods::Lun_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::Lun_estimation(ref_data = ref_data, verbose = T, seed = 10) # Estimating parameters using Lun Simulating datasets using Lun After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Simulate two or more groups Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group of cells.\nsimulate_result \u0026lt;- simmethods::Lun_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 1 # de.prob: 0.25 # fc.up.group: 5 # fc.down.group: 0 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 2 columns # cell_name group # \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; # Cell1 Cell1 Group1 # Cell2 Cell2 Group1 # Cell3 Cell3 Group1 # Cell4 Cell4 Group1 # Cell5 Cell5 Group1 # Cell6 Cell6 Group1 head(rowData(SCE_result)) # DataFrame with 6 rows and 1 column # gene_name # \u0026lt;character\u0026gt; # Gene1 Gene1 # Gene2 Gene2 # Gene3 Gene3 # Gene4 Gene4 # Gene5 Gene5 # Gene6 Gene6 Determin the number of cells and genes In Lun, we can not set nCells directly and should set groupCells instead. For example, if we want to simulate 500 cells, we can type other_prior = list(groupCells = 500). For genes, we can just set nGenes. Here, we simulate a new dataset with 500 cells and 2000 genes:\nsimulate_result \u0026lt;- simmethods::Lun_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(groupCells = 500, nGenes = 2000), seed = 111 ) # nCells: 500 # nGenes: 2000 # nGroups: 1 # de.prob: 0.5 # fc.up.group: 5 # fc.down.group: 0 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 2000 500 Simulate two or more groups In Lun, we can not set nGroups directly and should set prob.group instead. For example, if we want to simulate 2 groups, we can type other_prior = list(prob.group = c(0.5, 0.5)). Note that the sum of prob.group numeric vector must equal to 1, so we can also set prob.group = c(0.3, 0.7).\nIn addtion, if we want to simulate three or more groups, we should obey the rules:\nThe length of prob.group vector must always equal to the number of groups. The sum of prob.group numeric vector must equal to 1. For demonstration, we will simulate three groups using the learned parameters. We can set de.prob = 0.2 to simulate 20% genes as DEGs.\nsimulate_result \u0026lt;- simmethods::Lun_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(groupCells = 1000, nGenes = 3000, prob.group = c(0.1, 0.3, 0.6), de.prob = 0.2), seed = 111 ) # nCells: 1000 # nGenes: 3000 # nGroups: 3 # de.prob: 0.2 # fc.up.group: 5 # fc.down.group: 0 If you encounter the error which is like Warning: NAs producedError in [[\u0026lt;-.data.frame (tmp, paste0(‚ÄúDEFacGroup‚Äù, idx), value = c(5, :**, please set a higher gene number and try again.\nresult \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 3000 1000 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$group) # # Group1 Group2 Group3 # 100 300 600 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) ## de.prob = 0.2 # yes # 0.2 We can see that the proportion of differential expressed genes is 0.2 (default is 1). Next, if we want to know the fold change between two groups, we will do division with the groups that we are interested in.\n## fc between group2 and group1 fc_group1_to_group2 \u0026lt;- gene_info$DEFacGroup2/gene_info$DEFacGroup1 ## fc between group3 and group1 fc_group1_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup1 ## fc between group3 and group2 fc_group2_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup2 In addtion, users can also specify the foldchange of up-regulated or down-regulated DEGs by fc.up.group or fc.down.group.\nsimulate_result \u0026lt;- simmethods::Lun_simulation(parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], other_prior = list(prob.group = c(0.4, 0.6), de.prob = 0.2, fc.up.group = 2, fc.down.group = 0.5), return_format = \u0026quot;list\u0026quot;, verbose = TRUE, seed = 111) # nCells: 160 # nGenes: 4000 # nGroups: 2 # de.prob: 0.2 # fc.up.group: 2 # fc.down.group: 0.5 # Simulating datasets using Lun # Getting parameters... # Simulating means... # Simulating cell means... # Simulating counts... # Creating final dataset... # Sparsifying assays... # Automatically converting to sparse matrices, threshold = 0.95 # Converting \u0026#39;counts\u0026#39; to sparse matrix: estimated sparse size 0.82 * dense matrix # Skipping \u0026#39;CellMeans\u0026#39;: estimated sparse size 1.5 * dense matrix # Done! row_data \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### fc.up.group max(row_data$DEFacGroup1) # [1] 2 ### fc.down.group min(row_data$DEFacGroup1) # [1] 0.5 "
},
{
	"uri": "/references/methods/6-lun2/",
	"title": "Lun2",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using Lun2 Datasets with default parameters Determin the number of cells and genes Simulate two or more groups Here Lun2 method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nWhen you use Lun2 to estimate parameters from a real dataset, you must input a numeric vector to specify the groups or plates that each cell comes from, like other_prior = list(group.condition = the numeric vector).\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data group_condition \u0026lt;- simmethods::group_condition ## group_condition can must be a numeric vector. other_prior \u0026lt;- list(group.condition = as.numeric(group_condition)) Using simmethods::Lun2_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::Lun2_estimation(ref_data = ref_data, other_prior = other_prior, verbose = T, seed = 10) # Estimating parameters using Lun2 # Estimating number of groups... # Warning in regularize.values(x, y, ties, missing(ties), na.rm = na.rm): # collapsing to unique \u0026#39;x\u0026#39; values # Computing normalisation factors... # Warning in (function (x, sizes, min.mean = NULL, positive = FALSE, scaling = # NULL) : encountered non-positive size factor estimates # Estimating dispersions... # Estimating gene means... # Estimating plate effects... # Estimating zero-inflated parameters... # Warning in sqrt(diag(vc)[np]): NaNs produced # Warning in sqrt(diag(vc)[np]): NaNs produced # Warning in value[[3L]](cond): system is computationally singular: reciprocal # condition number = 9.2681e-48FALSE # Warning in sqrt(diag(vc)[np]): NaNs produced # Warning in sqrt(diag(vc)[np]): NaNs produced # Warning in sqrt(diag(vc)[np]): NaNs produced # Warning in sqrt(diag(vc)[np]): NaNs produced # Warning in sqrt(diag(vc)[np]): NaNs produced # Warning in sqrt(diag(vc)[np]): NaNs produced # Warning in value[[3L]](cond): system is computationally singular: reciprocal # condition number = 4.1192e-48FALSE Simulating datasets using Lun2 After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Simulate two or more groups Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group of cells.\nsimulate_result \u0026lt;- simmethods::Lun2_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 3973 # nPlates: 2 # de.prob: 0 # fc.group: 3 SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 3973 160 head(colData(SCE_result)) # DataFrame with 6 rows and 2 columns # cell_name plate # \u0026lt;character\u0026gt; \u0026lt;factor\u0026gt; # Cell1 Cell1 1 # Cell2 Cell2 1 # Cell3 Cell3 1 # Cell4 Cell4 1 # Cell5 Cell5 1 # Cell6 Cell6 1 head(rowData(SCE_result)) # DataFrame with 6 rows and 1 column # gene_name # \u0026lt;character\u0026gt; # Gene1 Gene1 # Gene2 Gene2 # Gene3 Gene3 # Gene4 Gene4 # Gene5 Gene5 # Gene6 Gene6 Determin the number of cells and genes In Lun2, we can not set nCells directly and should set cell.plates instead. For example, if we want to simulate 500 cells, we can type other_prior = list(cell.plates = rep(1, 500)). For genes, we can just set nGenes. Here, we simulate a new dataset with 500 cells and 2000 genes:\nsimulate_result \u0026lt;- simmethods::Lun2_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(cell.plates = rep(1, 500), nGenes = 2000), seed = 111 ) # nCells: 500 # nGenes: 2000 # nPlates: 1 # de.prob: 0 # fc.group: 3 # Warning in splatter::lun2Simulate(parameters, verbose = verbose, zinb = zinb): # Number of lib.sizes not equal to nCells. lib.sizes will be sampled. # Warning in splatter::lun2Simulate(parameters, verbose = verbose, zinb = zinb): # Number of gene parameters does not equal nGenes. Gene parameters will be # sampled. The cell.plates parameter represents the sampling source of cells in real experiments.\nresult \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 2000 500 Simulate two or more groups In Lun2, we can not set nGroups directly and should set cell.plates instead. For example, if we want to simulate 2 groups, we can type other_prior = list(cell.plates = sample(1:2, 500, replace = TRUE)). Note that the length of cell.plates numeric vector must be equal to the cell number.\nFor demonstration, we will simulate three groups using the learned parameters. We can set de.prob = 0.2 to simulate 20% genes as DEGs.\nsimulate_result \u0026lt;- simmethods::Lun2_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(cell.plates = sample(1:2, 500, replace = TRUE), nGenes = 2000, de.prob = 0.2, fc.group = 2), seed = 111 ) # nCells: 500 # nGenes: 2000 # nPlates: 2 # de.prob: 0.2 # fc.group: 2 # Warning in splatter::lun2Simulate(parameters, verbose = verbose, zinb = zinb): # Number of lib.sizes not equal to nCells. lib.sizes will be sampled. # Warning in splatter::lun2Simulate(parameters, verbose = verbose, zinb = zinb): # Number of gene parameters does not equal nGenes. Gene parameters will be # sampled. result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 2000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$plate) # # 1 2 # 236 264 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) ## de.prob = 0.2 # yes # 0.2 "
},
{
	"uri": "/references/methods/7-scrip/",
	"title": "SCRIP",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using SCRIP Datasets with default parameters Different modes in SCRIP Determin the number of cells and genes Simulate two or more groups Simulate two or more batches Simulate more groups and batches simutaniously Here SCRIP method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data dim(ref_data) # [1] 4000 160 Using simmethods::SCRIP_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::SCRIP_estimation(ref_data = ref_data, verbose = T, seed = 10) # Estimating parameters using SCRIP Simulating datasets using SCRIP After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Different modes in SCRIP Determin the number of cells and genes Simulate two or more groups Simulate two or more batches Simulate more groups and batches simutaniously Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group and one batch of cells.\nsimulate_result \u0026lt;- simmethods::SCRIP_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], ref_data = ref_data, return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) # nCells: 160 # nGenes: 4000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 The reference data must be input when simulating new datasets.\nSCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 3 columns # cell_name batch group # \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; # Cell1 Cell1 Batch1 Group1 # Cell2 Cell2 Batch1 Group1 # Cell3 Cell3 Batch1 Group1 # Cell4 Cell4 Batch1 Group1 # Cell5 Cell5 Batch1 Group1 # Cell6 Cell6 Batch1 Group1 Time consuming:\nsimulate_result$simulate_detection$Elapsed_Time_sec # [1] 20.288 Different modes in SCRIP SCRIP contains five different simulation modes, and you can specify which mode do you use (default is GP-trendedBCV):\nGP-trendedBCV GP-commonBCV BGP-commonBCV BP BGP-trendedBCV simulate_result \u0026lt;- simmethods::SCRIP_simulation(parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], ref_data = ref_data, other_prior = list(mode = \u0026quot;BP\u0026quot;), return_format = \u0026quot;list\u0026quot;, verbose = TRUE, seed = 111) # nCells: 160 # nGenes: 4000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 # Simulating datasets using SCRIP simulate_result \u0026lt;- simmethods::SCRIP_simulation(parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], ref_data = ref_data, other_prior = list(mode = \u0026quot;BGP-commonBCV\u0026quot;), return_format = \u0026quot;list\u0026quot;, verbose = TRUE, seed = 111) # nCells: 160 # nGenes: 4000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 # Simulating datasets using SCRIP Determin the number of cells and genes In SCRIP, we can not set nCells directly and should set batchCells instead. For example, if we want to simulate 500 cells, we can type other_prior = list(batchCells = 500). For genes, we can just set nGenes. Here, we simulate a new dataset with 500 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::SCRIP_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], ref_data = ref_data, return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = 500, nGenes = 1000), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 1 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 Simulate two or more groups In SCRIP, we can not set nGroups directly and should set prob.group instead. For example, if we want to simulate 2 groups, we can type other_prior = list(prob.group = c(0.5, 0.5)). Note that the sum of prob.group numeric vector must equal to 1, so we can also set prob.group = c(0.3, 0.7).\nIn addtion, if we want to simulate three or more groups, we should obey the rules:\nThe length of prob.group vector must always equal to the number of groups. The sum of prob.group numeric vector must equal to 1. For demonstration, we will simulate three groups using the learned parameters.\nsimulate_result \u0026lt;- simmethods::SCRIP_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], ref_data = ref_data, return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = 500, nGenes = 1000, prob.group = c(0.1, 0.3, 0.6)), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 3 # de.prob: 0.1 # nBatches: 1 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$group) # # Group1 Group2 Group3 # 46 156 298 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) ## de.prob = 0.1 # yes # 0.1 We can see that the proportion of differential expressed genes is 0.1 (equals to the default). Next, if we want to know the fold change between two groups, we will do division with the groups that we are interested in.\n## fc between group2 and group1 fc_group1_to_group2 \u0026lt;- gene_info$DEFacGroup2/gene_info$DEFacGroup1 ## fc between group3 and group1 fc_group1_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup1 ## fc between group3 and group2 fc_group2_to_group3 \u0026lt;- gene_info$DEFacGroup3/gene_info$DEFacGroup2 Simulate two or more batches In SCRIP, we can not set nBatches directly and should set batchCells instead. For example, if we want to simulate 2 batches, we can type other_prior = list(batchCells = c(250, 250)). Note that the sum of batchCells numeric vector represents the total number of cells and the length of the vector equals to the number of batches.\nIn addtion, if we want to simulate three or more batches, we should obey the rules:\nThe length of batchCells vector always equals to the number of batches. The sum of batchCells numeric vector represents the total number of cells. For demonstration, we will simulate three batches using the learned parameters.\nsimulate_result \u0026lt;- simmethods::SCRIP_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], ref_data = ref_data, return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = c(200, 300), nGenes = 1000), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 1 # de.prob: 0.1 # nBatches: 2 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$batch) # # Batch1 Batch2 # 200 300 Simulate more groups and batches simutaniously As mentioned before, we can set prob.group and batchCells to determine the number of groups and batches and we can also set de.prob to specify the proportion of DEGs. Here, we simulate a dataset with following settings:\n1000 cells 2000 genes three groups with 0.2 proportion of DEGs two batches simulate_result \u0026lt;- simmethods::SCRIP_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], ref_data = ref_data, return_format = \u0026quot;list\u0026quot;, other_prior = list(batchCells = c(500, 500), nGenes = 2000, de.prob = 0.2, prob.group = c(0.2, 0.3, 0.5)), seed = 111 ) # nCells: 1000 # nGenes: 2000 # nGroups: 3 # de.prob: 0.2 # nBatches: 2 result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 2000 1000 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$batch) # # Batch1 Batch2 # 500 500 table(cell_info$group) # # Group1 Group2 Group3 # 186 321 493 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) # yes # 0.1685 "
},
{
	"uri": "/references/methods/8-powsimr/",
	"title": "powsimR",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Estimate parameters without ERCC spike-in Estimate parameters with ERCC spike-in Simulating datasets using powsimR Datasets with default parameters Determin the number of cells and genes Simulate two or more groups Simulate two or more batches Simulate more groups and batches simutaniously Here powsimR method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- simmethods::data powsimR provides some choices for users to select suitable parameters according to different types of data, platforms, normalization methods, distributions and so on.\nRNAseq ‚Äúbulk‚Äù or ‚Äúsinglecell‚Äù (default). Protocol Options are ‚ÄúUMI‚Äù (default) (e.g.¬†10X Genomics, CEL-seq2) or ‚ÄúRead‚Äù (e.g.¬†Smart-seq2). Distribution ‚ÄúNB‚Äù (default) for negative binomial or ‚ÄúZINB‚Äù for zero-inflated negative binomial distribution fitting. Normalisation ‚ÄúTMM‚Äù (default), ‚ÄúMR‚Äù, ‚ÄúPosCounts‚Äù, ‚ÄúUQ‚Äù, ‚Äúscran‚Äù, ‚ÄúLinnorm‚Äù, ‚ÄúSCnorm‚Äù, ‚ÄúCensus‚Äù, ‚Äúdepth‚Äù, ‚Äúnone‚Äù. Estimate parameters without ERCC spike-in estimate_result \u0026lt;- powsimR_estimation( ref_data = ref_data, other_prior = list(RNAseq = \u0026quot;singlecell\u0026quot;, Protocol = \u0026quot;UMI\u0026quot;, Normalisation = \u0026quot;scran\u0026quot;), verbose = TRUE, seed = 111) # Warning: replacing previous import \u0026#39;DECENT::lrTest\u0026#39; by \u0026#39;MAST::lrTest\u0026#39; when # loading \u0026#39;powsimR\u0026#39; # Warning: replacing previous import \u0026#39;penalized::predict\u0026#39; by \u0026#39;stats::predict\u0026#39; when # loading \u0026#39;powsimR\u0026#39; # Warning: replacing previous import \u0026#39;zinbwave::glmWeightedF\u0026#39; by # \u0026#39;zingeR::glmWeightedF\u0026#39; when loading \u0026#39;powsimR\u0026#39; # Estimating parameters using estimateParam function Estimate parameters with ERCC spike-in powsimR also provides an another choice to estimate parameters (not neccessary) via spike-ins. If users want to use this, make sure that the reference data must contain ERCC spike-in counts. In addtion, users must set dilution.factor and volume information by other_prior = list(dilution.factor = xxx, volume = xxx).\nrownames(ref_data)[grep(pattern = \u0026quot;^ERCC\u0026quot;, x = rownames(ref_data))] # [1] \u0026quot;ERCC-00002\u0026quot; \u0026quot;ERCC-00003\u0026quot; \u0026quot;ERCC-00004\u0026quot; \u0026quot;ERCC-00009\u0026quot; \u0026quot;ERCC-00014\u0026quot; # [6] \u0026quot;ERCC-00019\u0026quot; \u0026quot;ERCC-00022\u0026quot; \u0026quot;ERCC-00025\u0026quot; \u0026quot;ERCC-00034\u0026quot; \u0026quot;ERCC-00035\u0026quot; # [11] \u0026quot;ERCC-00042\u0026quot; \u0026quot;ERCC-00043\u0026quot; \u0026quot;ERCC-00044\u0026quot; \u0026quot;ERCC-00046\u0026quot; \u0026quot;ERCC-00051\u0026quot; # [16] \u0026quot;ERCC-00053\u0026quot; \u0026quot;ERCC-00054\u0026quot; \u0026quot;ERCC-00059\u0026quot; \u0026quot;ERCC-00060\u0026quot; \u0026quot;ERCC-00062\u0026quot; # [21] \u0026quot;ERCC-00069\u0026quot; \u0026quot;ERCC-00071\u0026quot; \u0026quot;ERCC-00074\u0026quot; \u0026quot;ERCC-00076\u0026quot; \u0026quot;ERCC-00078\u0026quot; # [26] \u0026quot;ERCC-00079\u0026quot; \u0026quot;ERCC-00084\u0026quot; \u0026quot;ERCC-00092\u0026quot; \u0026quot;ERCC-00095\u0026quot; \u0026quot;ERCC-00096\u0026quot; # [31] \u0026quot;ERCC-00099\u0026quot; \u0026quot;ERCC-00108\u0026quot; \u0026quot;ERCC-00111\u0026quot; \u0026quot;ERCC-00112\u0026quot; \u0026quot;ERCC-00113\u0026quot; # [36] \u0026quot;ERCC-00116\u0026quot; \u0026quot;ERCC-00130\u0026quot; \u0026quot;ERCC-00131\u0026quot; \u0026quot;ERCC-00136\u0026quot; \u0026quot;ERCC-00144\u0026quot; # [41] \u0026quot;ERCC-00145\u0026quot; \u0026quot;ERCC-00148\u0026quot; \u0026quot;ERCC-00154\u0026quot; \u0026quot;ERCC-00157\u0026quot; \u0026quot;ERCC-00160\u0026quot; # [46] \u0026quot;ERCC-00162\u0026quot; \u0026quot;ERCC-00163\u0026quot; \u0026quot;ERCC-00165\u0026quot; \u0026quot;ERCC-00170\u0026quot; \u0026quot;ERCC-00171\u0026quot; Make sure there are ERCC names in reference data and users must input the dilution.factor and volume (microliter) to determine the concentration of ERCC molecules.\nestimate_result \u0026lt;- powsimR_estimation( ref_data = ref_data, other_prior = list(RNAseq = \u0026quot;singlecell\u0026quot;, Protocol = \u0026quot;UMI\u0026quot;, Normalisation = \u0026quot;scran\u0026quot;, dilution.factor = 50000, volume = 1), verbose = TRUE, seed = 111) # Estimating parameters using estimateParam function Simulating datasets using powsimR After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells and genes Simulate two or more groups Simulate two or more batches Simulate more groups and batches simutaniously powsimR provides some choices for users to select suitable parameters according to different normalization methods, and methods for differential expressed analysis.\nNormalisation ‚ÄúTMM‚Äù (default), ‚ÄúMR‚Äù, ‚ÄúPosCounts‚Äù, ‚ÄúUQ‚Äù, ‚Äúscran‚Äù, ‚ÄúLinnorm‚Äù, ‚Äúsctransform‚Äù, ‚ÄúSCnorm‚Äù, ‚ÄúCensus‚Äù, ‚Äúdepth‚Äù. DEmethod ‚ÄúT-Test‚Äù, ‚ÄúedgeR-LRT‚Äù, ‚ÄúedgeR-QL‚Äù, ‚ÄúedgeR-zingeR‚Äù, ‚ÄúedgeR-ZINB-WaVE‚Äù, ‚Äúlimma-voom‚Äù, ‚Äúlimma-trend‚Äù (default), ‚ÄúDESeq2‚Äù, ‚ÄúDESeq2-zingeR‚Äù, ‚ÄúDESeq2-ZINB-WaVE‚Äù, ‚ÄúROTS‚Äù, ‚ÄúbaySeq‚Äù, ‚ÄúNOISeq‚Äù, ‚ÄúEBSeq‚Äù, ‚ÄúMAST‚Äù, ‚ÄúBPSC‚Äù, ‚ÄúscDD‚Äù, ‚ÄúDECENT‚Äù. Datasets with default parameters The reference data contains 160 cells and 4000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data. In addtion, the simulated dataset will have one group and one batch of cells.\nsimulate_result \u0026lt;- simmethods::powsimR_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, verbose = TRUE, seed = 111) # nCells: 160 # nGenes: 4000 # nGroups: 2 # de.prob: 0.1 # fc.group: 2 # nBatches: 1 # # Setup Seed: 111 # You have chosen to simulate the expression of 4000 genes, which will be randomly drawn with replacement from the observed expression of 4000 genes. # Simulating datasets using powsimR # limma-trend is developed for bulk RNA-seq experiments. # Preparing output arrays. # # SIMULATION NUMBER 1 # Generating gene expression. # Generating spike-in expression. # 80 vs. 80 # Applying TMM normalisation # Applying limma-trend for DE analysis on raw count data. # Saving raw simulated counts. # Estimating moments of raw count data. SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 4000 160 head(colData(SCE_result)) # DataFrame with 6 rows and 2 columns # cell_name group # \u0026lt;character\u0026gt; \u0026lt;character\u0026gt; # Cell1 Cell1 Group1 # Cell2 Cell2 Group1 # Cell3 Cell3 Group1 # Cell4 Cell4 Group1 # Cell5 Cell5 Group1 # Cell6 Cell6 Group1 Time consuming:\nsimulate_result$simulate_detection$Elapsed_Time_sec # [1] 0.982 Determin the number of cells and genes Here, we simulate a new dataset with 500 cells and 1000 genes:\nsimulate_result \u0026lt;- simmethods::powsimR_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], other_prior = list(nCells = 500, nGenes = 1000), return_format = \u0026quot;list\u0026quot;, verbose = TRUE, seed = 111) # nCells: 500 # nGenes: 1000 # nGroups: 2 # de.prob: 0.1 # fc.group: 2 # nBatches: 1 # # Setup Seed: 111 # You have chosen to simulate the expression of 1000 genes, which will be randomly drawn without replacement from the observed expression of 4000 genes. # Simulating datasets using powsimR # limma-trend is developed for bulk RNA-seq experiments. # Preparing output arrays. # # SIMULATION NUMBER 1 # Generating gene expression. # Generating spike-in expression. # 250 vs. 250 # Applying TMM normalisation # Applying limma-trend for DE analysis on raw count data. # Saving raw simulated counts. # Estimating moments of raw count data. result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 Simulate two or more groups In powsimR, we can not set nGroups directly and should set prob.group instead. For example, if we want to simulate 2 groups, we can type other_prior = list(prob.group = c(0.5, 0.5)). Note that the sum of prob.group numeric vector must equal to 1, so we can also set prob.group = c(0.3, 0.7).\nIn addtion, if we want to simulate three or more groups, we should obey the rules:\nThe length of prob.group vector must always be 2 when using powsinR. The sum of prob.group numeric vector must equal to 1. For demonstration, we will simulate two groups using the learned parameters. (20% DEGs and 4 fold change)\nsimulate_result \u0026lt;- simmethods::powsimR_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 500, nGenes = 1000, prob.group = c(0.3, 0.7), de.prob = 0.2, fc.group = 4), seed = 111 ) # nCells: 500 # nGenes: 1000 # nGroups: 2 # de.prob: 0.2 # fc.group: 4 # nBatches: 1 # # You have chosen to simulate the expression of 1000 genes, which will be randomly drawn without replacement from the observed expression of 4000 genes. result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 1000 500 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$group) # # Group1 Group2 # 150 350 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### the proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) ## de.prob = 0.2 # yes # 0.2 Simulate two or more batches In powsimR, we can not set nBatches directly and should set prob.batch instead. For example, if we want to simulate 2 batches, we can type other_prior = list(prob.batch = c(0.5, 0.5)). Note that the sum of prob.batch numeric vector represents the total number of cells and the length of the vector equals to the number of batches.\nIn addtion, if we want to simulate three or more batches, we should obey the rules:\nThe length of prob.batch vector must always equal to the number of batches The sum of prob.batch numeric vector must equal to 1. For demonstration, we will simulate two batches using the learned parameters. (2 fold change)\nsimulate_result \u0026lt;- simmethods::powsimR_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], other_prior = list(prob.batch = c(0.4, 0.6), fc.batch = 2), return_format = \u0026quot;list\u0026quot;, verbose = TRUE, seed = 111) # nCells: 160 # nGenes: 4000 # nGroups: 2 # de.prob: 0.1 # fc.group: 2 # nBatches: 2 # fc.batch: 2 # Setup Seed: 111 # You have chosen to simulate the expression of 4000 genes, which will be randomly drawn with replacement from the observed expression of 4000 genes. # Simulating datasets using powsimR # limma-trend is developed for bulk RNA-seq experiments. # Preparing output arrays. # # SIMULATION NUMBER 1 # Generating gene expression. # Generating spike-in expression. # 32 vs. 32 # Applying TMM normalisation # Applying limma-trend for DE analysis on raw count data. # Saving raw simulated counts. # Estimating moments of raw count data. # 48 vs. 48 # Applying TMM normalisation # Applying limma-trend for DE analysis on raw count data. # Saving raw simulated counts. # Estimating moments of raw count data. result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 4000 160 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$batch) # # Batch1 Batch2 # 64 96 Simulate more groups and batches simutaniously As mentioned before, we can set prob.group and prob.batch to determine the number of groups and batches and we can also set de.prob to specify the proportion of DEGs. Here, we simulate a dataset with following settings:\n1000 cells 2000 genes two groups with 0.2 proportion of DEGs two batches simulate_result \u0026lt;- simmethods::powsimR_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 1000, nGenes = 2000, de.prob = 0.2, prob.group = c(0.4, 0.6), prob.batch = c(0.5, 0.5)), seed = 111 ) # nCells: 1000 # nGenes: 2000 # nGroups: 2 # de.prob: 0.2 # fc.group: 2 # nBatches: 2 # fc.batch: 2 # You have chosen to simulate the expression of 2000 genes, which will be randomly drawn without replacement from the observed expression of 4000 genes. result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 2000 1000 ## cell information cell_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;col_meta\u0026quot;]] table(cell_info$batch) # # Batch1 Batch2 # 500 500 table(cell_info$group) # # Group1 Group2 # 400 600 ## gene information gene_info \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;row_meta\u0026quot;]] ### proportion of DEGs table(gene_info$de_gene)[2]/nrow(result) # yes # 0.2 "
},
{
	"uri": "/references/methods/10-scdd/",
	"title": "scDD",
	"tags": [],
	"description": "",
	"content": " Estimating parameters from a real dataset Simulating datasets using scDD Datasets with default parameters Determin the number of cells Here scDD method will be demonstrated clearly and hope that this document can help you.\nEstimating parameters from a real dataset Before simulating datasets, it is important to estimate some essential parameters from a real dataset in order to make the simulated data more real. If you do not have a single-cell transcriptomics count matrix now, you can use the data collected in simmethods package by simmethods:data command.\nWhen you use scDD to estimate parameters from a real dataset, you must input a numeric vector to specify the groups or plates that each cell comes from, like other_prior = list(group.condition = the numeric vector).\nlibrary(simmethods) library(SingleCellExperiment) # Load data ref_data \u0026lt;- SingleCellExperiment::counts(scater::mockSCE()) set.seed(111) group_condition \u0026lt;- sample(c(1, 2), 200, replace = TRUE) ## group_condition can must be a numeric vector. other_prior \u0026lt;- list(group.condition = as.numeric(group_condition)) Using simmethods::scDD_estimation command to execute the estimation step.\nestimate_result \u0026lt;- simmethods::scDD_estimation(ref_data = ref_data, other_prior = other_prior, verbose = T, seed = 10) # Estimating parameters using scDD # Performing Median Normalization # Setting up parallel back-end using 1 cores # Clustering observed expression data for each gene # Notice: Number of permutations is set to zero; using # Kolmogorov-Smirnov to test for differences in distributions # instead of the Bayes Factor permutation test # Classifying significant genes into patterns Time consuming:\nestimate_result$estimate_detection$Elapsed_Time_sec # [1] 130.466 Simulating datasets using scDD After estimating parameter from a real dataset, we will simulate a dataset based on the learned parameters with different scenarios.\nDatasets with default parameters Determin the number of cells Datasets with default parameters The reference data contains 200 cells and 2000 genes, if we simulate datasets with default parameters and then we will obtain a new data which has the same size as the reference data.\nThe simulated dataset will always have two group of cells using scDD.\nsimulate_result \u0026lt;- simmethods::scDD_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;SCE\u0026quot;, seed = 111 ) SCE_result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]] dim(SCE_result) # [1] 2000 200 table(colData(SCE_result)$group) # # Group1 Group2 # 100 100 Determin the number of cells In scDD, users can only set nCells to specify the number of cells because the genes are already fixed after estimation step.\nsimulate_result \u0026lt;- simmethods::scDD_simulation( parameters = estimate_result[[\u0026quot;estimate_result\u0026quot;]], return_format = \u0026quot;list\u0026quot;, other_prior = list(nCells = 1000), seed = 111 ) result \u0026lt;- simulate_result[[\u0026quot;simulate_result\u0026quot;]][[\u0026quot;count_data\u0026quot;]] dim(result) # [1] 2000 1000 col_data \u0026lt;- simulate_result$simulate_result$col_meta table(col_data$group) # # Group1 Group2 # 500 500 "
},
{
	"uri": "/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "Overview simsite is a web-based reference vignettes for illustrating the usage of simulation methods for single-cell RNA sequencing data.\nIt contains three main sections:\nProgramming usage. All demonstrations and programming environment are in R. It shows a comprehensive pipeline from installing three main R packages (simutils, simmethods and simpipe) or just using simpipeDocker, estimating parameters from real data, simulating different kinds of new datasets and evaluating the simulated datasets.\nOnline usage. It contains some methods that show the best performance and users can simulate new datasets fast and conveniently.\nReferences. simmethods is the core package in our project. We collected 42+ methods and bundled them into a single package. For each method, we have already prepared a detailed vignette for users to learn to use the methods they are interested in.\nQuick start Programming start ‚¨Ö\nInstall R packages or download Docker images ‚¨Ö\nOnline usage start ‚¨Ö\nFeatures A comprehensive collection of simulation methods for single-cell RNA sequencing data.\nA Docker image is provided to help users establish the simulation environment easily and users can use it in local R.\nBoth local programming environment and interactive online tool can be used.\nDetailed vignettes for every simulation methods using simmethods package.\nCitation A comparison of simulation methods for single-cell RNA sequencing data.\nHelp and Issues If you need help or have any issue about our tools and vignettes. Send an email to duohongrui (duohongrui@cqnu.edu.cn) or raise an issue on github.\nNew Methods We are glad to add new simulation methods (especially for simulating spatial transcriptomics data) if some methods are innovative and creative that many users commonly used. If you have the requirements, please tell Hongrui Duo by email (duohongrui@cqnu.edu.cn) or raise an issue for that.\n"
},
{
	"uri": "/references/methods/",
	"title": "Vignettes",
	"tags": [],
	"description": "",
	"content": "Chapter X Some Chapter title Lorem Ipsum.\n"
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]